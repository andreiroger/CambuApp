========================================
CambuApp - Alpha 0.2 - Full Source Code
========================================
Generated: Tue Feb 10 06:48:57 PM UTC 2026


========================================
FILE: replit.md
========================================
# CambuApp - The Party Vibe Network

## Overview
A social platform for hosting and attending parties with a trust-based review system for both hosts and guests. Users can browse parties nearby, create/host parties, request to join, and review each other. Location-based party discovery ("Tinder for parties").

## Tech Stack
- **Frontend**: React + TypeScript, wouter routing, @tanstack/react-query, shadcn/ui, Tailwind CSS, Leaflet/react-leaflet for maps, qrcode for QR generation
- **Backend**: Express.js, express-session with MemoryStore
- **Database**: PostgreSQL with Drizzle ORM
- **Auth**: bcrypt password hashing (10 rounds) + SHA-256 pepper layer
- **AI**: Google Gemini (via Replit AI Integrations) for ID verification and party suggestions
- **Theme**: Dark-first design with purple (hue 280) primary colors

## Project Structure
- `shared/schema.ts` - Drizzle schema definitions (users, parties, party_attendees, party_requests, reviews, partyMessages, businesses)
- `server/routes.ts` - All API routes with session auth, validation, rate limiting, profanity filter
- `server/storage.ts` - DatabaseStorage class with Drizzle queries (optimized JOINs)
- `client/src/App.tsx` - Root component with routing, auth guard, theme provider
- `client/src/pages/` - All page components (auth, browse, party-detail, create-party, edit-party, host, attending, profile, settings, onboarding, legal, personality-test, map)
- `client/src/components/` - Shared components (mobile-nav, theme-provider, shadcn/ui)
- `client/src/hooks/` - Custom hooks (use-auth, use-toast, use-mobile)

## Key Features (Alpha 0.1 + 0.2)
- User registration/login with bcrypt-hashed passwords + SHA-256 pepper
- EULA and Terms enforcement with timestamps at registration
- Multi-step onboarding (personal info, vibe preferences, location with GPS detection)
- OCEAN personality test (Openness, Conscientiousness, Extraversion, Agreeableness, Neuroticism) with 90-day retake cooldown
- Browse parties with search and advanced filters (theme, price, crowd size, date, free-only, sort by popular/newest/price)
- Interactive Leaflet map integrated into Browse page (list/map toggle) with party markers (purple) and business markers (teal)
- Location-based filtering with Haversine formula (lat/lng/radius)
- Party detail view with join request flow, host trust signals, house rules, behavioral tips
- Party chat system with host moderation (message deletion)
- QR check-in: hosts generate QR codes, attendees scan to check in
- AI party assistant (Gemini-powered suggestions for what to bring)
- ID verification for alcohol parties using Gemini AI with retry logic and status tracking
- Host party creation and editing with image upload and camera support
- Host dashboard with request management (accept/decline) with authorization checks
- Attending parties view
- User profile with trust signals, personality traits display, avatar upload
- Settings with dark mode toggle, preferences
- Mobile bottom navigation bar (Browse, Host, Create, Going, Profile)
- Legal pages (Terms, Privacy, EULA) with required agreement checkbox during registration

## API Routes
All prefixed with /api:
- Auth: /api/auth/register (EULA enforcement), /api/auth/login (pepper verification), /api/auth/me, /api/auth/logout
- Users: /api/users/:id/stats (trust metrics), /api/users/:id (GET/PATCH), /api/users/:id/reviews
- Personality: /api/personality/test (POST, 90-day cooldown)
- Parties: /api/parties (with query params: theme, maxPrice, sort, crowdSize, dateFilter, freeOnly, lat, lng, radius, limit, offset), /api/parties/:id (GET/PATCH), /api/parties/host/mine, /api/parties/attending/mine
- Messages: /api/parties/:id/messages (GET/POST), /api/messages/:id (DELETE, host only)
- QR: /api/parties/:id/qr (GET, host only), /api/parties/:id/checkin (POST)
- Requests: /api/parties/:id/requests (GET/POST), /api/requests/:id/status (PATCH with host auth), /api/requests/mine
- Reviews: /api/reviews (POST)
- Map: /api/map (GET with lat/lng/radius/status params)
- AI: /api/ai/party-suggestions (POST)
- Uploads: /api/upload/party-image, /api/upload/avatar, /api/upload/id-document (multer)
- Verification: /api/verify-age (POST, Gemini AI with retry + status tracking)
- Legal: /api/legal/terms, /api/legal/privacy, /api/legal/eula
- Admin: /api/admin/stats, /api/admin/parties/:id, /api/admin/users/:id/ban, /api/admin/reviews/:id

## Schema Fields
- **Users**: fullName, username, password (bcrypt), passwordPepper (SHA-256), email, nickname, bio, avatar, dob, phone, city, country, address, latitude, longitude, isIdVerified, isAgeVerified, idDocumentUrl, verificationStatus, hostRating, guestRating, preferredVibe, gatheringSizePref, hostOrGuest, onboardingComplete, isAdmin, isBanned, agreedToTerms, eulaAcceptedAt, termsAcceptedAt, oceanOpenness, oceanConscientiousness, oceanExtraversion, oceanAgreeableness, oceanNeuroticism, oceanLastTaken
- **Parties**: hostId, title, theme, description, date, locationName, city, country, exactAddress, lat/lng, maxGuests, price, whatToBring, imageUrl, galleryUrls, includesAlcohol, status (upcoming/ongoing/finished), houseRules, targetGuests, vibe, qrToken
- **PartyAttendees**: partyId, userId, checkedIn, checkedInAt
- **PartyMessages**: partyId, senderId, message, createdAt
- **Businesses**: name, latitude, longitude, category, imageUrl, city, country

## Important Patterns
- Route ordering: /api/users/:id/stats must be BEFORE /api/users/:id to avoid parameter collision
- All React hooks must be declared BEFORE any early return statements
- PATCH routes use Zod validation schemas
- getAttendeeParties uses optimized JOIN query (not N+1 loop)
- Trust calculation: Profile completeness based on 10 user fields
- updateUser filters undefined values and returns existing user if no changes (prevents Drizzle "No values to set" error)
- Server-side age verification enforcement: POST /api/parties/:id/requests returns 403 if party includes alcohol and user not age-verified
- Password pepper: bcrypt hash stored in password field, SHA-256 HMAC pepper stored in passwordPepper field (backwards compatible with pre-pepper users)
- QR tokens generated as crypto.randomUUID() on party creation
- Chat messages require host authentication for deletion
- Gemini verification retries up to 2 times with status tracking (none/pending/verified/failed)

## Backend Features (Alpha 0.2)
- **Password Security**: Dual-layer with bcrypt + SHA-256 HMAC pepper (backwards compatible)
- **EULA Enforcement**: agreedToTerms + agreedToEula required at registration with timestamps
- **OCEAN Personality Test**: 5-dimension test with 90-day retake cooldown
- **Party Chat**: Real-time messages with 5-second polling, host moderation
- **QR Check-in**: UUID tokens generated per party, validated server-side
- **Interactive Map**: GET /api/map returns parties + businesses filtered by radius
- **AI Party Assistant**: Gemini-powered suggestions based on party details
- **Gemini Verification Polish**: Retry logic (2 attempts) and status tracking
- **Session Security**: httpOnly, sameSite=lax cookie flags
- **Rate Limiting**: express-rate-limit on auth (5/15min), party requests (10/15min), general API (100/15min)
- **Input Validation**: Max length constraints on title (100), description (2000), bio (500), message (500), house rules (1000), coordinate bounds
- **Pagination**: GET /api/parties returns { parties, total, hasMore } with limit/offset query params
- **Party Lifecycle**: Auto-updates party status (upcoming->ongoing->finished) on startup and hourly
- **Profanity Filter**: Custom ProfanityFilter class filters titles, descriptions, house rules, bios

## Running
`npm run dev` starts both Express server and Vite dev server on port 5000.


========================================
FILE: package.json
========================================
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "tsx script/build.ts",
    "start": "NODE_ENV=production node dist/index.cjs",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@google/genai": "^1.40.0",
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@tanstack/react-query": "^5.60.5",
    "@types/bad-words": "^3.0.3",
    "@types/bcrypt": "^6.0.0",
    "@types/leaflet": "^1.9.21",
    "@types/multer": "^2.0.0",
    "@types/qrcode": "^1.5.6",
    "bcrypt": "^6.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.3",
    "drizzle-zod": "^0.7.1",
    "embla-carousel-react": "^8.6.0",
    "express": "^5.0.1",
    "express-rate-limit": "^8.2.1",
    "express-session": "^1.19.0",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.4.2",
    "leaflet": "^1.9.4",
    "lucide-react": "^0.453.0",
    "memorystore": "^1.6.7",
    "multer": "^2.0.2",
    "next-themes": "^0.4.6",
    "p-limit": "^7.3.0",
    "p-retry": "^7.1.1",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pg": "^8.16.3",
    "qrcode": "^1.5.4",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-leaflet": "^4.2.1",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.25.76",
    "zod-validation-error": "^3.5.4"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.4.4",
    "@replit/vite-plugin-dev-banner": "^0.1.1",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.18",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "^5.0.0",
    "@types/express-session": "^1.18.2",
    "@types/node": "20.19.27",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.7.0",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.31.8",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.20.5",
    "typescript": "5.6.3",
    "vite": "^7.3.0"
  },
  "overrides": {
    "drizzle-kit": {
      "@esbuild-kit/esm-loader": "npm:tsx@^4.20.4"
    }
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}


========================================
FILE: tsconfig.json
========================================
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}


========================================
FILE: components.json
========================================
{
    "$schema": "https://ui.shadcn.com/schema.json",
    "style": "new-york",
    "rsc": false,
    "tsx": true,
    "tailwind": {
      "config": "tailwind.config.ts",
      "css": "client/src/index.css",
      "baseColor": "neutral",
      "cssVariables": true,
      "prefix": ""
    },
    "aliases": {
      "components": "@/components",
      "utils": "@/lib/utils",
      "ui": "@/components/ui",
      "lib": "@/lib",
      "hooks": "@/hooks"
    }
}

========================================
FILE: drizzle.config.ts
========================================
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});


========================================
FILE: tailwind.config.ts
========================================
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: ".5625rem", /* 9px */
        md: ".375rem", /* 6px */
        sm: ".1875rem", /* 3px */
      },
      colors: {
        // Flat / base colors (regular buttons)
        background: "hsl(var(--background) / <alpha-value>)",
        foreground: "hsl(var(--foreground) / <alpha-value>)",
        border: "hsl(var(--border) / <alpha-value>)",
        input: "hsl(var(--input) / <alpha-value>)",
        card: {
          DEFAULT: "hsl(var(--card) / <alpha-value>)",
          foreground: "hsl(var(--card-foreground) / <alpha-value>)",
          border: "hsl(var(--card-border) / <alpha-value>)",
        },
        popover: {
          DEFAULT: "hsl(var(--popover) / <alpha-value>)",
          foreground: "hsl(var(--popover-foreground) / <alpha-value>)",
          border: "hsl(var(--popover-border) / <alpha-value>)",
        },
        primary: {
          DEFAULT: "hsl(var(--primary) / <alpha-value>)",
          foreground: "hsl(var(--primary-foreground) / <alpha-value>)",
          border: "var(--primary-border)",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary) / <alpha-value>)",
          foreground: "hsl(var(--secondary-foreground) / <alpha-value>)",
          border: "var(--secondary-border)",
        },
        muted: {
          DEFAULT: "hsl(var(--muted) / <alpha-value>)",
          foreground: "hsl(var(--muted-foreground) / <alpha-value>)",
          border: "var(--muted-border)",
        },
        accent: {
          DEFAULT: "hsl(var(--accent) / <alpha-value>)",
          foreground: "hsl(var(--accent-foreground) / <alpha-value>)",
          border: "var(--accent-border)",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive) / <alpha-value>)",
          foreground: "hsl(var(--destructive-foreground) / <alpha-value>)",
          border: "var(--destructive-border)",
        },
        ring: "hsl(var(--ring) / <alpha-value>)",
        chart: {
          "1": "hsl(var(--chart-1) / <alpha-value>)",
          "2": "hsl(var(--chart-2) / <alpha-value>)",
          "3": "hsl(var(--chart-3) / <alpha-value>)",
          "4": "hsl(var(--chart-4) / <alpha-value>)",
          "5": "hsl(var(--chart-5) / <alpha-value>)",
        },
        sidebar: {
          ring: "hsl(var(--sidebar-ring) / <alpha-value>)",
          DEFAULT: "hsl(var(--sidebar) / <alpha-value>)",
          foreground: "hsl(var(--sidebar-foreground) / <alpha-value>)",
          border: "hsl(var(--sidebar-border) / <alpha-value>)",
        },
        "sidebar-primary": {
          DEFAULT: "hsl(var(--sidebar-primary) / <alpha-value>)",
          foreground: "hsl(var(--sidebar-primary-foreground) / <alpha-value>)",
          border: "var(--sidebar-primary-border)",
        },
        "sidebar-accent": {
          DEFAULT: "hsl(var(--sidebar-accent) / <alpha-value>)",
          foreground: "hsl(var(--sidebar-accent-foreground) / <alpha-value>)",
          border: "var(--sidebar-accent-border)"
        },
        status: {
          online: "rgb(34 197 94)",
          away: "rgb(245 158 11)",
          busy: "rgb(239 68 68)",
          offline: "rgb(156 163 175)",
        },
      },
      fontFamily: {
        sans: ["var(--font-sans)"],
        serif: ["var(--font-serif)"],
        mono: ["var(--font-mono)"],
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;


========================================
FILE: vite.config.ts
========================================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" &&
    process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
          await import("@replit/vite-plugin-dev-banner").then((m) =>
            m.devBanner(),
          ),
        ]
      : []),
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    },
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"],
    },
  },
});


========================================
FILE: shared/schema.ts
========================================
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, integer, boolean, real, uniqueIndex, index, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  fullName: text("full_name").notNull(),
  nickname: text("nickname"),
  avatar: text("avatar").default(""),
  bio: text("bio").default(""),
  isIdVerified: boolean("is_id_verified").default(false),
  isAgeVerified: boolean("is_age_verified").default(false),
  idDocumentUrl: text("id_document_url").default(""),
  verificationStatus: text("verification_status").default("none"),
  dob: text("dob"),
  email: text("email").notNull(),
  phone: text("phone").default(""),
  country: text("country").default(""),
  city: text("city").default(""),
  address: text("address").default(""),
  latitude: real("latitude"),
  longitude: real("longitude"),
  hostRating: real("host_rating").default(0),
  guestRating: real("guest_rating").default(0),
  notificationsEnabled: boolean("notifications_enabled").default(true),
  darkMode: boolean("dark_mode").default(false),
  searchRadius: integer("search_radius").default(50),
  preferredVibe: text("preferred_vibe").default(""),
  gatheringSizePref: text("gathering_size_pref").default(""),
  hostOrGuest: text("host_or_guest").default(""),
  agreedToTerms: boolean("agreed_to_terms").default(false),
  isBanned: boolean("is_banned").default(false),
  isAdmin: boolean("is_admin").default(false),
  onboardingComplete: boolean("onboarding_complete").default(false),
  oceanOpenness: real("ocean_openness"),
  oceanConscientiousness: real("ocean_conscientiousness"),
  oceanExtraversion: real("ocean_extraversion"),
  oceanAgreeableness: real("ocean_agreeableness"),
  oceanNeuroticism: real("ocean_neuroticism"),
  oceanLastTaken: text("ocean_last_taken"),
  eulaAcceptedAt: text("eula_accepted_at"),
  termsAcceptedAt: text("terms_accepted_at"),
  passwordPepper: text("password_pepper"),
}, (table) => [
  index("users_city_idx").on(table.city),
  index("users_country_idx").on(table.country),
]);

export const parties = pgTable("parties", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  hostId: varchar("host_id").notNull().references(() => users.id),
  title: text("title").notNull(),
  theme: text("theme").notNull(),
  description: text("description").notNull(),
  date: text("date").notNull(),
  locationName: text("location_name").notNull(),
  city: text("city").notNull(),
  country: text("country").notNull(),
  exactAddress: text("exact_address"),
  latitude: real("latitude").notNull(),
  longitude: real("longitude").notNull(),
  maxGuests: integer("max_guests").notNull(),
  price: integer("price").default(0),
  whatToBring: text("what_to_bring").array().default(sql`'{}'::text[]`),
  imageUrl: text("image_url").default(""),
  galleryUrls: text("gallery_urls").array().default(sql`'{}'::text[]`),
  includesAlcohol: boolean("includes_alcohol").default(false),
  createdAt: text("created_at").default(sql`now()`),
  status: text("status").notNull().default("upcoming"),
  houseRules: text("house_rules").default(""),
  targetGuests: text("target_guests").default(""),
  vibe: text("vibe").default(""),
  qrToken: text("qr_token"),
}, (table) => [
  index("parties_host_id_idx").on(table.hostId),
  index("parties_city_idx").on(table.city),
  index("parties_status_idx").on(table.status),
  index("parties_date_idx").on(table.date),
]);

export const partyAttendees = pgTable("party_attendees", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  partyId: varchar("party_id").notNull().references(() => parties.id),
  userId: varchar("user_id").notNull().references(() => users.id),
  checkedIn: boolean("checked_in").default(false),
  checkedInAt: text("checked_in_at"),
}, (table) => [
  uniqueIndex("party_user_unique").on(table.partyId, table.userId),
  index("attendees_party_id_idx").on(table.partyId),
  index("attendees_user_id_idx").on(table.userId),
]);

export const partyRequests = pgTable("party_requests", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  partyId: varchar("party_id").notNull().references(() => parties.id),
  userId: varchar("user_id").notNull().references(() => users.id),
  message: text("message").default(""),
  pledgedItems: text("pledged_items").default(""),
  status: text("status").notNull().default("pending"),
}, (table) => [
  index("requests_party_id_idx").on(table.partyId),
  index("requests_user_id_idx").on(table.userId),
  index("requests_status_idx").on(table.status),
]);

export const reviews = pgTable("reviews", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  authorId: varchar("author_id").notNull().references(() => users.id),
  targetId: varchar("target_id").notNull().references(() => users.id),
  partyId: varchar("party_id").references(() => parties.id),
  content: text("content").notNull(),
  rating: integer("rating").notNull(),
  type: text("type").notNull(),
  createdAt: text("created_at").default(sql`now()`),
}, (table) => [
  index("reviews_target_id_idx").on(table.targetId),
  index("reviews_author_id_idx").on(table.authorId),
]);

export const partyMessages = pgTable("party_messages", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  partyId: varchar("party_id").notNull().references(() => parties.id),
  senderId: varchar("sender_id").notNull().references(() => users.id),
  message: text("message").notNull(),
  createdAt: text("created_at").default(sql`now()`),
}, (table) => [
  index("messages_party_id_idx").on(table.partyId),
  index("messages_sender_id_idx").on(table.senderId),
]);

export const businesses = pgTable("businesses", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  latitude: real("latitude").notNull(),
  longitude: real("longitude").notNull(),
  category: text("category").notNull(),
  imageUrl: text("image_url").default(""),
  city: text("city").notNull(),
  country: text("country").notNull(),
}, (table) => [
  index("businesses_city_idx").on(table.city),
]);

export const insertUserSchema = createInsertSchema(users).omit({ id: true });
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

export const insertPartySchema = createInsertSchema(parties).omit({ id: true, createdAt: true });
export type InsertParty = z.infer<typeof insertPartySchema>;
export type Party = typeof parties.$inferSelect;

export const insertPartyAttendeeSchema = createInsertSchema(partyAttendees).omit({ id: true });
export type InsertPartyAttendee = z.infer<typeof insertPartyAttendeeSchema>;
export type PartyAttendee = typeof partyAttendees.$inferSelect;

export const insertPartyRequestSchema = createInsertSchema(partyRequests).omit({ id: true });
export type InsertPartyRequest = z.infer<typeof insertPartyRequestSchema>;
export type PartyRequest = typeof partyRequests.$inferSelect;

export const insertReviewSchema = createInsertSchema(reviews).omit({ id: true, createdAt: true });
export type InsertReview = z.infer<typeof insertReviewSchema>;
export type Review = typeof reviews.$inferSelect;

export const insertPartyMessageSchema = createInsertSchema(partyMessages).omit({ id: true, createdAt: true });
export type InsertPartyMessage = z.infer<typeof insertPartyMessageSchema>;
export type PartyMessage = typeof partyMessages.$inferSelect;

export const insertBusinessSchema = createInsertSchema(businesses).omit({ id: true });
export type InsertBusiness = z.infer<typeof insertBusinessSchema>;
export type Business = typeof businesses.$inferSelect;

export const updateUserSchema = createInsertSchema(users).omit({ id: true }).partial();
export type UpdateUser = z.infer<typeof updateUserSchema>;

export const updatePartySchema = createInsertSchema(parties).omit({ id: true, createdAt: true }).partial();
export type UpdateParty = z.infer<typeof updatePartySchema>;

export const updateRequestStatusSchema = z.object({
  status: z.enum(["accepted", "declined"]),
});

export const oceanTestSchema = z.object({
  openness: z.number().min(0).max(100),
  conscientiousness: z.number().min(0).max(100),
  extraversion: z.number().min(0).max(100),
  agreeableness: z.number().min(0).max(100),
  neuroticism: z.number().min(0).max(100),
});


========================================
FILE: server/index.ts
========================================
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { serveStatic } from "./static";
import { createServer } from "http";

const app = express();
const httpServer = createServer(app);

declare module "http" {
  interface IncomingMessage {
    rawBody: unknown;
  }
}

app.use(
  express.json({
    verify: (req, _res, buf) => {
      req.rawBody = buf;
    },
  }),
);

app.use(express.urlencoded({ extended: false }));

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  await registerRoutes(httpServer, app);

  app.use((err: any, _req: Request, res: Response, next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    console.error("Internal Server Error:", err);

    if (res.headersSent) {
      return next(err);
    }

    return res.status(status).json({ message });
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (process.env.NODE_ENV === "production") {
    serveStatic(app);
  } else {
    const { setupVite } = await import("./vite");
    await setupVite(httpServer, app);
  }

  // ALWAYS serve the app on the port specified in the environment variable PORT
  // Other ports are firewalled. Default to 5000 if not specified.
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = parseInt(process.env.PORT || "5000", 10);
  httpServer.listen(
    {
      port,
      host: "0.0.0.0",
      reusePort: true,
    },
    () => {
      log(`serving on port ${port}`);
    },
  );
})();


========================================
FILE: server/routes.ts
========================================
import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import session from "express-session";
import MemoryStore from "memorystore";
import { insertUserSchema, insertPartySchema, updateUserSchema, updatePartySchema, updateRequestStatusSchema, oceanTestSchema, insertPartyMessageSchema } from "@shared/schema";
import bcrypt from "bcrypt";
import crypto from "crypto";
import multer from "multer";
import rateLimit from "express-rate-limit";
const PROFANITY_LIST = [
  "ass", "asshole", "bastard", "bitch", "bullshit", "cock", "crap", "cunt",
  "damn", "dick", "fuck", "fucking", "goddamn", "hell", "motherfucker",
  "nigger", "nigga", "piss", "prick", "pussy", "shit", "slut", "whore",
  "wanker", "twat", "bollocks", "arse", "arsehole", "bellend", "bloody",
  "bugger", "chink", "fag", "faggot", "retard", "retarded", "spic", "kike"
];

class ProfanityFilter {
  private words: Set<string>;
  constructor() {
    this.words = new Set(PROFANITY_LIST.map(w => w.toLowerCase()));
  }
  clean(text: string): string {
    if (!text) return text;
    return text.replace(/\b\w+\b/g, (word) => {
      if (this.words.has(word.toLowerCase())) {
        return "*".repeat(word.length);
      }
      return word;
    });
  }
}

const profanityFilter = new ProfanityFilter();
import express from "express";
import path from "path";
import fs from "fs";

declare module "express-session" {
  interface SessionData {
    userId: string;
  }
}

const SessionStore = MemoryStore(session);

function cleanText(text: string | undefined | null): string {
  if (!text) return text as string;
  try {
    return profanityFilter.clean(text);
  } catch {
    return text;
  }
}

function haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

async function updatePartyStatuses() {
  try {
    const allParties = await storage.getAllParties();
    const now = new Date();
    const twoHoursFromNow = new Date(now.getTime() + 2 * 60 * 60 * 1000);

    for (const party of allParties) {
      const partyDate = new Date(party.date);

      if (party.status !== "finished" && partyDate < now) {
        await storage.updateParty(party.id, { status: "finished" });
        const requests = await storage.getPartyRequests(party.id);
        for (const req of requests) {
          if (req.status === "pending") {
            await storage.updateRequestStatus(req.id, "cancelled");
          }
        }
        console.log(`[LIFECYCLE] Party "${party.title}" (${party.id}) marked as finished`);
      } else if (party.status === "upcoming" && partyDate <= twoHoursFromNow && partyDate >= now) {
        await storage.updateParty(party.id, { status: "ongoing" });
        console.log(`[LIFECYCLE] Party "${party.title}" (${party.id}) marked as ongoing`);
      }
    }
  } catch (error) {
    console.error("[LIFECYCLE] Error updating party statuses:", error);
  }
}

const partyImageStorage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    const dir = "uploads/parties";
    fs.mkdirSync(dir, { recursive: true });
    cb(null, dir);
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const avatarStorage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    const dir = "uploads/avatars";
    fs.mkdirSync(dir, { recursive: true });
    cb(null, dir);
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const idDocStorage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    const dir = "uploads/ids";
    fs.mkdirSync(dir, { recursive: true });
    cb(null, dir);
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const imageFileFilter = (_req: any, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ["image/jpeg", "image/png", "image/webp"];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error("Only JPG, PNG, and WebP images are allowed"));
  }
};

const uploadPartyImage = multer({
  storage: partyImageStorage,
  limits: { fileSize: 5 * 1024 * 1024 },
  fileFilter: imageFileFilter,
});

const uploadAvatar = multer({
  storage: avatarStorage,
  limits: { fileSize: 5 * 1024 * 1024 },
  fileFilter: imageFileFilter,
});

const uploadIdDoc = multer({
  storage: idDocStorage,
  limits: { fileSize: 10 * 1024 * 1024 },
  fileFilter: imageFileFilter,
});

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: { message: "Too many authentication attempts, please try again later" },
  standardHeaders: true,
  legacyHeaders: false,
});

const requestCreationLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 10,
  message: { message: "Too many party requests, please try again later" },
  standardHeaders: true,
  legacyHeaders: false,
});

const generalApiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: { message: "Too many requests, please try again later" },
  standardHeaders: true,
  legacyHeaders: false,
});

const TERMS_OF_SERVICE = `CambuApp - Terms of Service

Last Updated: February 2026

Welcome to CambuApp. By accessing or using our platform, you agree to be bound by these Terms of Service ("Terms"). Please read them carefully before using the application.

1. ACCEPTANCE OF TERMS

By creating an account, accessing, or using CambuApp ("the Platform," "the Service"), you acknowledge that you have read, understood, and agree to be bound by these Terms of Service. If you do not agree to these Terms, you must not use the Platform.

2. ELIGIBILITY AND AGE VERIFICATION

2.1. You must be at least 18 years of age to create an account and use CambuApp.
2.2. CambuApp reserves the right to require age verification through government-issued identification documents at any time.
2.3. By using the Platform, you represent and warrant that you are at least 18 years old and have the legal capacity to enter into these Terms.
2.4. CambuApp may use automated or manual verification processes to confirm your age and identity. Providing false identification information is strictly prohibited and will result in immediate account termination.

3. USER ACCOUNTS

3.1. You are responsible for maintaining the confidentiality of your account credentials.
3.2. You agree to provide accurate, current, and complete information during registration and to update such information to keep it accurate and complete.
3.3. You are solely responsible for all activities that occur under your account.
3.4. CambuApp reserves the right to suspend or terminate accounts that violate these Terms or engage in suspicious activity.
3.5. You may not create multiple accounts or transfer your account to another person.

4. PARTY HOSTING RULES

4.1. Hosts are solely responsible for ensuring their events comply with all applicable local, state, and federal laws and regulations, including but not limited to noise ordinances, occupancy limits, alcohol licensing requirements, and fire safety codes.
4.2. Hosts must accurately describe their events, including location, date, time, expected attendance, and any costs or requirements.
4.3. Hosts are responsible for the safety and well-being of their guests during the event.
4.4. Hosts must not discriminate against guests based on race, color, religion, sex, national origin, disability, sexual orientation, gender identity, or any other protected characteristic.
4.5. Hosts are responsible for obtaining any necessary permits or permissions for their events.
4.6. Events involving alcohol must comply with all applicable alcohol laws. Hosts must ensure that no alcoholic beverages are served to individuals under the legal drinking age.

5. CODE OF CONDUCT

5.1. Users must treat all other users with respect and courtesy.
5.2. The following behaviors are strictly prohibited:
   a. Harassment, bullying, intimidation, or threatening behavior
   b. Discrimination or hate speech of any kind
   c. Sharing explicit, obscene, or offensive content
   d. Engaging in or promoting illegal activities
   e. Spamming, phishing, or other deceptive practices
   f. Impersonating another person or entity
   g. Posting false or misleading information about events
   h. Engaging in any form of fraud or deception
5.3. Users who violate the Code of Conduct may have their accounts suspended or permanently banned at CambuApp's sole discretion.

6. CONTENT AND INTELLECTUAL PROPERTY

6.1. Users retain ownership of content they create and share on the Platform.
6.2. By posting content on CambuApp, you grant the Platform a non-exclusive, worldwide, royalty-free license to use, display, reproduce, and distribute such content in connection with the Service.
6.3. You represent and warrant that you have all necessary rights to post any content you share on the Platform.
6.4. CambuApp reserves the right to remove any content that violates these Terms or is deemed inappropriate at its sole discretion.

7. LIABILITY AND DISCLAIMERS

7.1. CambuApp is a platform that facilitates connections between party hosts and guests. CambuApp is not responsible for the actions, conduct, or behavior of any user at any event.
7.2. CambuApp does not guarantee the safety, quality, legality, or suitability of any event listed on the Platform.
7.3. Users attend events at their own risk. CambuApp shall not be liable for any injuries, damages, losses, or claims arising from attendance at any event.
7.4. THE PLATFORM IS PROVIDED "AS IS" AND "AS AVAILABLE" WITHOUT WARRANTIES OF ANY KIND, EXPRESS OR IMPLIED.
7.5. IN NO EVENT SHALL CAMBUAPP BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES ARISING OUT OF OR RELATED TO YOUR USE OF THE PLATFORM.
7.6. CambuApp's total liability for any claims arising from or related to the Service shall not exceed the amount paid by you to CambuApp in the twelve (12) months preceding the claim.

8. PAYMENTS AND FEES

8.1. Some events may require payment. CambuApp may facilitate payment processing but is not responsible for refunds or disputes between hosts and guests.
8.2. CambuApp reserves the right to charge service fees for the use of certain features.
8.3. All fees are non-refundable unless otherwise stated.

9. TERMINATION

9.1. You may terminate your account at any time by contacting CambuApp support.
9.2. CambuApp reserves the right to suspend or terminate your account at any time, with or without cause, and with or without notice.
9.3. Upon termination, your right to use the Platform will immediately cease. Sections of these Terms that by their nature should survive termination shall survive.

10. GOVERNING LAW

10.1. These Terms shall be governed by and construed in accordance with applicable law, without regard to conflict of law principles.
10.2. Any disputes arising from these Terms or the use of the Platform shall be resolved through binding arbitration.

11. CHANGES TO TERMS

CambuApp reserves the right to modify these Terms at any time. We will notify users of material changes through the Platform. Your continued use of the Service after such modifications constitutes your acceptance of the updated Terms.

12. CONTACT

For questions about these Terms, please contact us through the CambuApp support channels within the application.`;

const PRIVACY_POLICY = `CambuApp - Privacy Policy

Last Updated: February 2026

CambuApp ("we," "our," or "us") is committed to protecting your privacy. This Privacy Policy explains how we collect, use, disclose, and safeguard your information when you use our mobile application and related services (collectively, the "Service").

1. INFORMATION WE COLLECT

1.1. Personal Information You Provide:
   - Account registration information (name, email address, phone number, date of birth)
   - Profile information (bio, profile photo, preferences, city, country)
   - Event-related information (party details, descriptions, locations)
   - Communications (messages between users, party requests, reviews)
   - Payment information (if applicable, processed through secure third-party payment processors)

1.2. Information Collected Automatically:
   - Device information (device type, operating system, unique device identifiers)
   - Log data (IP address, browser type, pages visited, time spent)
   - Usage data (features used, interactions, preferences)

2. LOCATION DATA

2.1. CambuApp collects and processes location data to provide location-based party discovery and filtering.
2.2. We collect:
   - Location coordinates you provide when creating events
   - Your general location for discovering nearby events (when you grant permission)
   - City and country information from your profile
2.3. Location data is used to:
   - Show you events near your location
   - Enable location-based search and filtering
   - Provide distance calculations to event venues
2.4. You can control location sharing through your device settings. Disabling location access may limit certain features of the Service.

3. IDENTITY DOCUMENTS AND AGE VERIFICATION

3.1. CambuApp may collect identity documents (government-issued ID, passport, or driver's license) for the purpose of age verification and identity confirmation.
3.2. Identity documents are:
   - Stored securely using industry-standard encryption
   - Used solely for verification purposes
   - Not shared with other users or third parties except as required by law
   - Retained only for as long as necessary to complete the verification process and maintain compliance records
3.3. By submitting identity documents, you consent to our processing of this sensitive information for verification purposes.

4. HOW WE USE YOUR INFORMATION

4.1. We use the information we collect to:
   - Provide, maintain, and improve the Service
   - Create and manage your account
   - Facilitate party discovery, hosting, and attendance
   - Process and manage party requests
   - Enable communication between hosts and guests
   - Verify your identity and age
   - Send notifications about events, requests, and account activity
   - Enforce our Terms of Service and Community Guidelines
   - Detect and prevent fraud, abuse, and security incidents
   - Analyze usage patterns to improve the user experience
   - Comply with legal obligations

5. INFORMATION SHARING AND DISCLOSURE

5.1. We may share your information in the following circumstances:
   - With other users as necessary for the Service (e.g., your profile information visible to party hosts)
   - With service providers who perform services on our behalf
   - In response to legal process or government requests
   - To protect the rights, property, or safety of CambuApp, our users, or others
   - In connection with a merger, acquisition, or sale of assets
5.2. We do not sell your personal information to third parties.

6. COOKIES AND TRACKING TECHNOLOGIES

6.1. CambuApp uses session cookies to maintain your login state and provide a seamless experience.
6.2. We may use analytics tools to understand how users interact with the Service.
6.3. You can control cookie preferences through your browser or device settings.

7. DATA SECURITY

7.1. We implement appropriate technical and organizational measures to protect your personal information against unauthorized access, alteration, disclosure, or destruction.
7.2. These measures include:
   - Encryption of sensitive data in transit and at rest
   - Secure password hashing using industry-standard algorithms
   - Regular security assessments and updates
   - Access controls limiting data access to authorized personnel
7.3. No method of transmission over the Internet or electronic storage is 100% secure. While we strive to protect your information, we cannot guarantee absolute security.

8. DATA RETENTION

8.1. We retain your personal information for as long as your account is active or as needed to provide the Service.
8.2. We may retain certain information after account deletion for legitimate business purposes, including legal compliance, dispute resolution, and enforcement of our agreements.
8.3. Identity verification documents are retained for the minimum period required by applicable law.

9. YOUR RIGHTS AND CHOICES

9.1. Depending on your jurisdiction, you may have the right to:
   - Access your personal information
   - Correct inaccurate information
   - Delete your account and personal information
   - Object to or restrict certain processing of your information
   - Data portability (receive your data in a structured, commonly used format)
   - Withdraw consent where processing is based on consent
9.2. To exercise these rights, please contact us through the CambuApp support channels.

10. CHILDREN'S PRIVACY

10.1. CambuApp is not intended for individuals under 18 years of age.
10.2. We do not knowingly collect personal information from children under 18.
10.3. If we learn that we have collected personal information from a child under 18, we will take steps to delete such information promptly.

11. INTERNATIONAL DATA TRANSFERS

11.1. Your information may be transferred to and processed in countries other than your country of residence.
11.2. We ensure appropriate safeguards are in place for international data transfers in compliance with applicable data protection laws.

12. CHANGES TO THIS PRIVACY POLICY

We may update this Privacy Policy from time to time. We will notify you of material changes through the Service or by other means. Your continued use of the Service after changes are posted constitutes your acceptance of the updated Privacy Policy.

13. CONTACT US

For questions or concerns about this Privacy Policy or our data practices, please contact us through the CambuApp support channels within the application.`;

const EULA_TEXT = `CambuApp - End User License Agreement (EULA)

Last Updated: February 2026

IMPORTANT: PLEASE READ THIS END USER LICENSE AGREEMENT ("AGREEMENT") CAREFULLY BEFORE USING CAMBUAPP. BY INSTALLING, ACCESSING, OR USING THE APPLICATION, YOU AGREE TO BE BOUND BY THE TERMS OF THIS AGREEMENT.

1. LICENSE GRANT

1.1. Subject to your compliance with this Agreement, CambuApp grants you a limited, non-exclusive, non-transferable, revocable license to:
   a. Download, install, and use the CambuApp application on your personal device(s)
   b. Access and use the CambuApp platform and its features for personal, non-commercial purposes
1.2. This license does not include the right to:
   a. Modify, adapt, translate, reverse engineer, decompile, or disassemble the application
   b. Create derivative works based on the application
   c. Copy, distribute, or publicly display the application or its content
   d. Use the application for any commercial purpose without prior written consent from CambuApp
   e. Remove, alter, or obscure any proprietary notices in the application

2. ACCOUNT AND ACCESS

2.1. To use CambuApp, you must create an account and provide accurate, complete information.
2.2. You are responsible for safeguarding your account credentials and for all activities that occur under your account.
2.3. You must notify CambuApp immediately of any unauthorized use of your account.
2.4. CambuApp reserves the right to disable any account at any time for any reason, including violation of this Agreement.

3. USER CONTENT

3.1. You are solely responsible for any content you create, upload, or share through the application, including but not limited to party descriptions, photos, reviews, and messages.
3.2. You warrant that any content you post does not infringe upon the intellectual property rights, privacy rights, or other rights of any third party.
3.3. CambuApp reserves the right to review, moderate, and remove any user content at its sole discretion.

4. RESTRICTIONS

4.1. You agree not to:
   a. Use the application for any unlawful purpose or in violation of any applicable laws
   b. Interfere with or disrupt the application's servers, networks, or infrastructure
   c. Attempt to gain unauthorized access to any portion of the application or its systems
   d. Use automated scripts, bots, or other means to interact with the application
   e. Harvest, collect, or store personal information of other users without their consent
   f. Use the application to transmit any malicious code, viruses, or harmful content
   g. Engage in any activity that could damage, disable, overburden, or impair the application
   h. Use the application to send unsolicited communications or spam
   i. Circumvent or attempt to circumvent any security features of the application
   j. Use the application in any manner that could interfere with other users' enjoyment of the Service

5. INTELLECTUAL PROPERTY

5.1. CambuApp and its entire contents, features, and functionality (including but not limited to software, text, graphics, logos, icons, images, audio, and video) are owned by CambuApp and are protected by copyright, trademark, patent, and other intellectual property laws.
5.2. The CambuApp name, logo, and all related names, logos, product and service names, designs, and slogans are trademarks of CambuApp. You may not use such marks without the prior written permission of CambuApp.

6. THIRD-PARTY SERVICES

6.1. The application may contain links to or integrate with third-party services, websites, or applications.
6.2. CambuApp is not responsible for the content, accuracy, or practices of any third-party services.
6.3. Your use of third-party services is governed by their respective terms and privacy policies.

7. DISCLAIMER OF WARRANTIES

7.1. THE APPLICATION IS PROVIDED "AS IS" AND "AS AVAILABLE" WITHOUT ANY WARRANTIES OF ANY KIND, WHETHER EXPRESS, IMPLIED, OR STATUTORY.
7.2. CAMBUAPP DISCLAIMS ALL WARRANTIES, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND THOSE ARISING FROM COURSE OF DEALING OR USAGE OF TRADE.
7.3. CAMBUAPP DOES NOT WARRANT THAT THE APPLICATION WILL BE UNINTERRUPTED, ERROR-FREE, SECURE, OR FREE OF VIRUSES OR OTHER HARMFUL COMPONENTS.

8. LIMITATION OF LIABILITY

8.1. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL CAMBUAPP BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS, DATA, USE, OR GOODWILL, ARISING OUT OF OR RELATED TO YOUR USE OF THE APPLICATION.
8.2. CAMBUAPP'S TOTAL LIABILITY FOR ALL CLAIMS ARISING FROM OR RELATED TO THIS AGREEMENT SHALL NOT EXCEED THE AMOUNT YOU PAID TO CAMBUAPP IN THE TWELVE (12) MONTHS PRECEDING THE CLAIM.

9. INDEMNIFICATION

9.1. You agree to indemnify, defend, and hold harmless CambuApp and its officers, directors, employees, agents, and affiliates from and against any claims, damages, losses, costs, and expenses (including reasonable attorneys' fees) arising from:
   a. Your use of the application
   b. Your violation of this Agreement
   c. Your violation of any rights of another party
   d. Any content you create or share through the application

10. TERMINATION

10.1. This Agreement is effective until terminated.
10.2. CambuApp may terminate this Agreement and your access to the application at any time, with or without cause, with or without notice.
10.3. You may terminate this Agreement by deleting your account and ceasing all use of the application.
10.4. Upon termination:
   a. All rights and licenses granted to you under this Agreement shall immediately cease
   b. You must immediately cease all use of the application
   c. CambuApp may delete your account and all associated data
10.5. Sections 5, 7, 8, 9, and 11 shall survive any termination of this Agreement.

11. GENERAL PROVISIONS

11.1. Governing Law: This Agreement shall be governed by applicable law without regard to its conflict of law provisions.
11.2. Severability: If any provision of this Agreement is found to be unenforceable, the remaining provisions shall continue in full force and effect.
11.3. Entire Agreement: This Agreement constitutes the entire agreement between you and CambuApp regarding the use of the application and supersedes all prior agreements and understandings.
11.4. Waiver: No waiver of any term of this Agreement shall be deemed a further or continuing waiver of such term or any other term.
11.5. Assignment: You may not assign or transfer this Agreement without CambuApp's prior written consent. CambuApp may assign this Agreement without restriction.
11.6. Updates: CambuApp may update the application and this Agreement from time to time. Continued use of the application after updates constitutes acceptance of the modified Agreement.

12. CONTACT INFORMATION

For questions about this Agreement, please contact us through the CambuApp support channels within the application.`;

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  app.use(session({
    secret: process.env.SESSION_SECRET || "cambuapp-secret",
    resave: false,
    saveUninitialized: false,
    store: new SessionStore({ checkPeriod: 86400000 }),
    cookie: { maxAge: 24 * 60 * 60 * 1000, httpOnly: true, secure: false, sameSite: "lax" as const }
  }));

  app.use("/uploads", express.static("uploads"));

  app.use("/api", generalApiLimiter);

  app.use((req, res, next) => {
    const start = Date.now();
    const originalSend = res.send;
    res.send = function (body) {
      const duration = Date.now() - start;
      console.log(`[REQUEST] ${req.method} ${req.path} ${res.statusCode} ${duration}ms`);
      return originalSend.call(this, body);
    };
    next();
  });

  app.use((err: any, _req: any, res: any, next: any) => {
    if (err) {
      console.error(`[ERROR] ${err.message}`);
      console.error(err.stack);
      if (!res.headersSent) {
        return res.status(500).json({ message: "Internal server error" });
      }
    }
    next(err);
  });

  // Auth Routes
  app.post("/api/auth/register", authLimiter, async (req, res) => {
    try {
      if (req.body.agreedToTerms !== true || req.body.agreedToEula !== true) {
        return res.status(400).json({ message: "You must agree to the Terms of Service and EULA to register" });
      }
      const parsed = insertUserSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid input", errors: parsed.error.errors });
      }
      if (parsed.data.bio && parsed.data.bio.length > 500) {
        return res.status(400).json({ message: "Bio must be 500 characters or less" });
      }
      const existing = await storage.getUserByUsername(parsed.data.username);
      if (existing) {
        return res.status(409).json({ message: "Username already taken" });
      }
      const hashedPassword = await bcrypt.hash(parsed.data.password, 10);
      const pepper = process.env.PASSWORD_PEPPER || "cambuapp-default-pepper-2026";
      const pepperHash = crypto.createHmac("sha256", pepper).update(hashedPassword).digest("hex");
      const cleanedData = {
        ...parsed.data,
        password: hashedPassword,
        passwordPepper: pepperHash,
        bio: cleanText(parsed.data.bio),
        eulaAcceptedAt: new Date().toISOString(),
        termsAcceptedAt: new Date().toISOString(),
      };
      const user = await storage.createUser(cleanedData);
      req.session.userId = user.id;
      const { password, ...userWithoutPassword } = user;
      return res.status(201).json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Registration failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/auth/login", authLimiter, async (req, res) => {
    try {
      const { username, password } = req.body;
      if (!username || !password) {
        return res.status(400).json({ message: "Username and password required" });
      }
      const user = await storage.getUserByUsername(username);
      if (!user) {
        console.log(`[SECURITY] Failed login attempt - IP: ${req.ip} - Username: ${username} (user not found)`);
        return res.status(401).json({ message: "Invalid credentials" });
      }
      if (user.isBanned) {
        console.log(`[SECURITY] Banned user login attempt - IP: ${req.ip} - Username: ${username}`);
        return res.status(403).json({ message: "Account has been suspended" });
      }
      const isValidPassword = await bcrypt.compare(password, user.password);
      if (!isValidPassword) {
        console.log(`[SECURITY] Failed login attempt - IP: ${req.ip} - Username: ${username} (wrong password)`);
        return res.status(401).json({ message: "Invalid credentials" });
      }
      if (user.passwordPepper) {
        const pepper = process.env.PASSWORD_PEPPER || "cambuapp-default-pepper-2026";
        const expectedPepper = crypto.createHmac("sha256", pepper).update(user.password).digest("hex");
        if (user.passwordPepper !== expectedPepper) {
          console.log(`[SECURITY] Pepper verification failed - IP: ${req.ip} - Username: ${username}`);
          return res.status(401).json({ message: "Invalid credentials" });
        }
      }
      req.session.userId = user.id;
      const { password: _, ...userWithoutPassword } = user;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Login failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/auth/me", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = user;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Auth check failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/auth/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ message: "Failed to logout" });
      }
      return res.json({ message: "Logged out" });
    });
  });

  // Personality Test Route
  app.post("/api/personality/test", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const parsed = oceanTestSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid input", errors: parsed.error.errors });
      }
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      if (user.oceanLastTaken) {
        const lastTaken = new Date(user.oceanLastTaken);
        const now = new Date();
        const diffDays = Math.floor((now.getTime() - lastTaken.getTime()) / (1000 * 60 * 60 * 24));
        if (diffDays < 90) {
          const daysLeft = 90 - diffDays;
          return res.status(400).json({ message: `You can retake the test in ${daysLeft} days` });
        }
      }
      const updated = await storage.updateUser(req.session.userId, {
        oceanOpenness: parsed.data.openness,
        oceanConscientiousness: parsed.data.conscientiousness,
        oceanExtraversion: parsed.data.extraversion,
        oceanAgreeableness: parsed.data.agreeableness,
        oceanNeuroticism: parsed.data.neuroticism,
        oceanLastTaken: new Date().toISOString(),
      });
      if (!updated) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = updated;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Personality test failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // User Routes
  app.get("/api/users/:id/stats", async (req, res) => {
    try {
      const userId = req.params.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const attendeeParties = await storage.getAttendeeParties(userId);
      const hostedParties = await storage.getPartiesByHost(userId);
      const reviews = await storage.getReviewsByTarget(userId);

      const filledFields = [
        user.fullName, user.nickname, user.bio, user.avatar,
        user.dob, user.phone, user.city, user.country,
        user.preferredVibe, user.gatheringSizePref
      ].filter(f => f && f.length > 0).length;
      const verifiedCount = user.isAgeVerified ? 1 : 0;
      const profileCompleteness = Math.round(((filledFields + verifiedCount) / 11) * 100);

      return res.json({
        partiesAttended: attendeeParties.length,
        partiesHosted: hostedParties.length,
        reviewCount: reviews.length,
        profileCompleteness,
      });
    } catch (error: any) {
      console.error("[ERROR] User stats failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/users/:id", async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = user;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Get user failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/users/:id", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      if (req.session.userId !== req.params.id) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const { password, ...bodyWithoutPassword } = req.body;
      const parsed = updateUserSchema.safeParse(bodyWithoutPassword);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid input", errors: parsed.error.errors });
      }
      if (parsed.data.bio && parsed.data.bio.length > 500) {
        return res.status(400).json({ message: "Bio must be 500 characters or less" });
      }
      if (parsed.data.latitude != null && (parsed.data.latitude < -90 || parsed.data.latitude > 90)) {
        return res.status(400).json({ message: "Latitude must be between -90 and 90" });
      }
      if (parsed.data.longitude != null && (parsed.data.longitude < -180 || parsed.data.longitude > 180)) {
        return res.status(400).json({ message: "Longitude must be between -180 and 180" });
      }
      const cleanedData = {
        ...parsed.data,
        bio: parsed.data.bio ? cleanText(parsed.data.bio) : parsed.data.bio,
      };
      const updated = await storage.updateUser(req.params.id, cleanedData);
      if (!updated) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password: _, ...userWithoutPassword } = updated;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Update user failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/users/:id/reviews", async (req, res) => {
    try {
      const reviews = await storage.getReviewsByTarget(req.params.id);
      return res.json(reviews);
    } catch (error: any) {
      console.error("[ERROR] Get reviews failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Party Routes - specific routes before parameterized routes
  app.get("/api/parties/host/mine", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const myParties = await storage.getPartiesByHost(req.session.userId);
      const enriched = await Promise.all(myParties.map(async (party) => {
        const host = await storage.getUser(party.hostId);
        const attendeeCount = await storage.getAttendeeCount(party.id);
        return {
          ...party,
          hostName: host?.fullName || "Unknown",
          hostAvatar: host?.avatar || "",
          hostVerified: host?.isIdVerified || false,
          attendeeCount,
        };
      }));
      return res.json(enriched);
    } catch (error: any) {
      console.error("[ERROR] Get host parties failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties/attending/mine", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const attendingParties = await storage.getAttendeeParties(req.session.userId);
      const enriched = await Promise.all(attendingParties.map(async (party) => {
        const host = await storage.getUser(party.hostId);
        const attendeeCount = await storage.getAttendeeCount(party.id);
        return {
          ...party,
          hostName: host?.fullName || "Unknown",
          hostAvatar: host?.avatar || "",
          hostVerified: host?.isIdVerified || false,
          attendeeCount,
        };
      }));
      return res.json(enriched);
    } catch (error: any) {
      console.error("[ERROR] Get attending parties failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties", async (req, res) => {
    try {
      const city = req.query.city as string | undefined;
      const lat = req.query.lat ? parseFloat(req.query.lat as string) : undefined;
      const lng = req.query.lng ? parseFloat(req.query.lng as string) : undefined;
      const radius = req.query.radius ? parseFloat(req.query.radius as string) : undefined;
      const limitParam = req.query.limit ? parseInt(req.query.limit as string, 10) : 20;
      const offsetParam = req.query.offset ? parseInt(req.query.offset as string, 10) : 0;
      const limit = Math.min(Math.max(1, limitParam), 100);
      const offset = Math.max(0, offsetParam);

      let allParties = city ? await storage.getPartiesByCity(city) : await storage.getParties();

      const statusParam = req.query.status as string | undefined;
      if (statusParam === "finished") {
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        allParties = allParties.filter(p => p.status === "finished" && new Date(p.date) >= thirtyDaysAgo);
      } else {
        allParties = allParties.filter(p => p.status === "upcoming" || p.status === "ongoing");
      }

      if (lat !== undefined && lng !== undefined && radius !== undefined) {
        if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
          return res.status(400).json({ message: "Invalid coordinates" });
        }
        allParties = allParties.filter(party => {
          if (party.latitude === null || party.longitude === null) return false;
          const distance = haversineDistance(lat, lng, party.latitude, party.longitude);
          return distance <= radius;
        });
      }

      const enriched = await Promise.all(allParties.map(async (party) => {
        const host = await storage.getUser(party.hostId);
        const attendeeCount = await storage.getAttendeeCount(party.id);
        return {
          ...party,
          hostName: host?.fullName || "Unknown",
          hostAvatar: host?.avatar || "",
          hostVerified: host?.isIdVerified || false,
          attendeeCount,
        };
      }));

      const sort = req.query.sort as string | undefined;
      if (sort === "popular") {
        enriched.sort((a, b) => b.attendeeCount - a.attendeeCount);
      } else if (sort === "price_low") {
        enriched.sort((a, b) => (a.price ?? 0) - (b.price ?? 0));
      } else if (sort === "price_high") {
        enriched.sort((a, b) => (b.price ?? 0) - (a.price ?? 0));
      } else if (sort === "date") {
        enriched.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
      } else {
        enriched.sort((a, b) => new Date(b.createdAt ?? "").getTime() - new Date(a.createdAt ?? "").getTime());
      }

      const total = enriched.length;
      const paginatedParties = enriched.slice(offset, offset + limit);
      const hasMore = offset + limit < total;

      return res.json({ parties: paginatedParties, total, hasMore });
    } catch (error: any) {
      console.error("[ERROR] Get parties failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties/:id", async (req, res) => {
    try {
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      const host = await storage.getUser(party.hostId);
      const attendeeCount = await storage.getAttendeeCount(party.id);
      return res.json({
        ...party,
        hostName: host?.fullName || "Unknown",
        hostAvatar: host?.avatar || "",
        hostVerified: host?.isIdVerified || false,
        attendeeCount,
      });
    } catch (error: any) {
      console.error("[ERROR] Get party failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/parties", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const parsed = insertPartySchema.safeParse({ ...req.body, hostId: req.session.userId });
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid input", errors: parsed.error.errors });
      }
      if (parsed.data.title.length > 100) {
        return res.status(400).json({ message: "Title must be 100 characters or less" });
      }
      if (parsed.data.description.length > 2000) {
        return res.status(400).json({ message: "Description must be 2000 characters or less" });
      }
      if (parsed.data.houseRules && parsed.data.houseRules.length > 1000) {
        return res.status(400).json({ message: "House rules must be 1000 characters or less" });
      }
      if (parsed.data.latitude < -90 || parsed.data.latitude > 90) {
        return res.status(400).json({ message: "Latitude must be between -90 and 90" });
      }
      if (parsed.data.longitude < -180 || parsed.data.longitude > 180) {
        return res.status(400).json({ message: "Longitude must be between -180 and 180" });
      }
      const cleanedData = {
        ...parsed.data,
        title: cleanText(parsed.data.title),
        description: cleanText(parsed.data.description),
        houseRules: parsed.data.houseRules ? cleanText(parsed.data.houseRules) : parsed.data.houseRules,
        qrToken: crypto.randomUUID(),
      };
      const party = await storage.createParty(cleanedData);
      return res.status(201).json(party);
    } catch (error: any) {
      console.error("[ERROR] Create party failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/parties/:id", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const parsed = updatePartySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid input", errors: parsed.error.errors });
      }
      if (parsed.data.title && parsed.data.title.length > 100) {
        return res.status(400).json({ message: "Title must be 100 characters or less" });
      }
      if (parsed.data.description && parsed.data.description.length > 2000) {
        return res.status(400).json({ message: "Description must be 2000 characters or less" });
      }
      if (parsed.data.houseRules && parsed.data.houseRules.length > 1000) {
        return res.status(400).json({ message: "House rules must be 1000 characters or less" });
      }
      if (parsed.data.latitude != null && (parsed.data.latitude < -90 || parsed.data.latitude > 90)) {
        return res.status(400).json({ message: "Latitude must be between -90 and 90" });
      }
      if (parsed.data.longitude != null && (parsed.data.longitude < -180 || parsed.data.longitude > 180)) {
        return res.status(400).json({ message: "Longitude must be between -180 and 180" });
      }
      const cleanedData = {
        ...parsed.data,
        title: parsed.data.title ? cleanText(parsed.data.title) : parsed.data.title,
        description: parsed.data.description ? cleanText(parsed.data.description) : parsed.data.description,
        houseRules: parsed.data.houseRules ? cleanText(parsed.data.houseRules) : parsed.data.houseRules,
      };
      const updated = await storage.updateParty(req.params.id, cleanedData);
      return res.json(updated);
    } catch (error: any) {
      console.error("[ERROR] Update party failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/parties/:id", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.deleteParty(req.params.id);
      return res.json({ message: "Party deleted" });
    } catch (error: any) {
      console.error("[ERROR] Delete party failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties/:id/attendees", async (req, res) => {
    try {
      const attendees = await storage.getPartyAttendees(req.params.id);
      const attendeesWithInfo = await Promise.all(
        attendees.map(async (a) => {
          const user = await storage.getUser(a.userId);
          return {
            ...a,
            username: user?.username || "",
            fullName: user?.fullName || "",
            avatar: user?.avatar || "",
            isIdVerified: user?.isIdVerified || false,
          };
        })
      );
      return res.json(attendeesWithInfo);
    } catch (error: any) {
      console.error("[ERROR] Get attendees failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Party Request Routes
  app.get("/api/requests/mine", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const requests = await storage.getUserRequests(req.session.userId);
      return res.json(requests);
    } catch (error: any) {
      console.error("[ERROR] Get user requests failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties/:id/requests", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const requests = await storage.getPartyRequests(req.params.id);
      const requestsWithInfo = await Promise.all(
        requests.map(async (r) => {
          const user = await storage.getUser(r.userId);
          return {
            ...r,
            username: user?.username || "",
            fullName: user?.fullName || "",
            avatar: user?.avatar || "",
            isIdVerified: user?.isIdVerified || false,
          };
        })
      );
      return res.json(requestsWithInfo);
    } catch (error: any) {
      console.error("[ERROR] Get party requests failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/parties/:id/requests", requestCreationLimiter, async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const partyId = req.params.id as string;
      const party = await storage.getParty(partyId);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId === req.session.userId) {
        return res.status(400).json({ message: "You cannot request to join your own party" });
      }
      if (party.includesAlcohol) {
        const user = await storage.getUser(req.session.userId);
        if (!user?.isAgeVerified) {
          return res.status(403).json({ message: "Age verification required for parties that include alcohol" });
        }
      }
      const existingRequest = await storage.getPartyRequestByUserAndParty(req.session.userId, partyId);
      if (existingRequest) {
        return res.status(409).json({ message: "You already have a pending or accepted request for this party" });
      }
      const message = req.body.message || "";
      if (message.length > 500) {
        return res.status(400).json({ message: "Message must be 500 characters or less" });
      }
      const request = await storage.createPartyRequest({
        partyId: partyId,
        userId: req.session.userId,
        message: cleanText(message),
        pledgedItems: req.body.pledgedItems || "",
        status: "pending",
      });
      return res.status(201).json(request);
    } catch (error: any) {
      console.error("[ERROR] Create party request failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/requests/:id/status", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const parsed = updateRequestStatusSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Status must be 'accepted' or 'declined'" });
      }
      const { status } = parsed.data;
      const request = await storage.getRequest(req.params.id);
      if (!request) {
        return res.status(404).json({ message: "Request not found" });
      }
      const party = await storage.getParty(request.partyId);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const updatedRequest = await storage.updateRequestStatus(req.params.id, status);
      if (!updatedRequest) {
        return res.status(404).json({ message: "Request not found" });
      }
      if (status === "accepted") {
        await storage.addAttendee(updatedRequest.partyId, updatedRequest.userId);
      }
      return res.json(updatedRequest);
    } catch (error: any) {
      console.error("[ERROR] Update request status failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Review Routes
  app.post("/api/reviews", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const review = await storage.createReview({
        ...req.body,
        authorId: req.session.userId,
      });
      return res.status(201).json(review);
    } catch (error: any) {
      console.error("[ERROR] Create review failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Image Upload Routes
  app.post("/api/upload/party-image", (req, res, next) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    next();
  }, uploadPartyImage.single("image"), (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: "No image file provided" });
    }
    const url = `/uploads/parties/${req.file.filename}`;
    return res.json({ url });
  });

  app.post("/api/upload/avatar", (req, res, next) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    next();
  }, uploadAvatar.single("image"), (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: "No image file provided" });
    }
    const url = `/uploads/avatars/${req.file.filename}`;
    return res.json({ url });
  });

  app.post("/api/upload/id-document", (req, res, next) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    next();
  }, uploadIdDoc.single("image"), (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: "No image file provided" });
    }
    const url = `/uploads/ids/${req.file.filename}`;
    return res.json({ url });
  });

  app.post("/api/verify-age", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const { imageBase64 } = req.body;
      if (!imageBase64) {
        return res.status(400).json({ message: "Image data is required" });
      }
      const dir = "uploads/ids";
      fs.mkdirSync(dir, { recursive: true });
      const mimeMatch = imageBase64.match(/^data:(image\/\w+);base64,/);
      const detectedMime = mimeMatch ? mimeMatch[1] : "image/png";
      const ext = detectedMime.split("/")[1] || "png";
      const filename = `verify-${req.session.userId}-${Date.now()}.${ext}`;
      const filepath = path.join(dir, filename);
      const base64Data = imageBase64.replace(/^data:image\/\w+;base64,/, "");
      fs.writeFileSync(filepath, Buffer.from(base64Data, "base64"));
      const idDocumentUrl = `/uploads/ids/${filename}`;

      await storage.updateUser(req.session.userId, { verificationStatus: "pending" });

      let isVerified = false;
      let aiMessage = "Verification pending";
      try {
        const { GoogleGenAI } = await import("@google/genai");
        const ai = new GoogleGenAI({
          apiKey: process.env.AI_INTEGRATIONS_GEMINI_API_KEY!,
          httpOptions: {
            apiVersion: "",
            baseUrl: process.env.AI_INTEGRATIONS_GEMINI_BASE_URL!,
          },
        });

        let response: any = null;
        for (let attempt = 0; attempt < 2; attempt++) {
          try {
            response = await ai.models.generateContent({
              model: "gemini-2.5-flash",
              contents: [
                {
                  role: "user",
                  parts: [
                    {
                      text: "This is an ID document image. Extract the date of birth from this ID. Determine if the person is 18 years old or older as of today. Respond ONLY with a JSON object in this exact format: {\"dob\": \"YYYY-MM-DD\", \"age\": NUMBER, \"is18Plus\": true/false, \"documentType\": \"passport/license/id_card/unknown\"}. If you cannot read the document or extract the date of birth, respond with: {\"dob\": null, \"age\": null, \"is18Plus\": false, \"documentType\": \"unreadable\"}",
                    },
                    {
                      inlineData: {
                        mimeType: detectedMime,
                        data: base64Data,
                      },
                    },
                  ],
                },
              ],
            });
            break;
          } catch (retryError: any) {
            console.error(`[WARN] Gemini attempt ${attempt + 1} failed:`, retryError.message);
            if (attempt === 1) throw retryError;
          }
        }

        const responseText = response?.candidates?.[0]?.content?.parts?.[0]?.text || response?.text || "";
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          const parsed = JSON.parse(jsonMatch[0]);
          isVerified = parsed.is18Plus === true;
          aiMessage = isVerified
            ? `Age verified: ${parsed.age} years old (${parsed.documentType})`
            : parsed.documentType === "unreadable"
              ? "Could not read the document. Please try again with a clearer photo."
              : `Verification failed: Must be 18+ (detected age: ${parsed.age})`;
        }
      } catch (aiError: any) {
        console.error("[WARN] Gemini AI verification failed, falling back:", aiError.message);
        aiMessage = "AI verification unavailable. Document saved for manual review.";
      }

      await storage.updateUser(req.session.userId, {
        isAgeVerified: isVerified,
        idDocumentUrl,
        verificationStatus: isVerified ? "verified" : "failed",
      });

      return res.json({
        message: aiMessage,
        status: isVerified ? "verified" : "failed",
        isVerified,
        idDocumentUrl,
      });
    } catch (error: any) {
      console.error("[ERROR] Age verification failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Chat Messages Routes
  app.get("/api/parties/:id/messages", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const messages = await storage.getPartyMessages(req.params.id);
      messages.sort((a, b) => new Date(a.createdAt || "").getTime() - new Date(b.createdAt || "").getTime());
      const messagesWithSender = await Promise.all(
        messages.map(async (msg) => {
          const sender = await storage.getUser(msg.senderId);
          return {
            ...msg,
            sender: {
              id: sender?.id || "",
              fullName: sender?.fullName || "",
              avatar: sender?.avatar || "",
              nickname: sender?.nickname || "",
            },
          };
        })
      );
      return res.json(messagesWithSender);
    } catch (error: any) {
      console.error("[ERROR] Get party messages failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/parties/:id/messages", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const { message } = req.body;
      if (!message || typeof message !== "string" || message.trim().length === 0) {
        return res.status(400).json({ message: "Message text is required" });
      }
      if (message.length > 500) {
        return res.status(400).json({ message: "Message must be 500 characters or less" });
      }
      const cleanedMessage = cleanText(message.trim());
      const created = await storage.createPartyMessage({
        partyId: req.params.id,
        senderId: req.session.userId,
        message: cleanedMessage,
      });
      return res.status(201).json(created);
    } catch (error: any) {
      console.error("[ERROR] Create party message failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/messages/:id", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const msg = await storage.getPartyMessage(req.params.id);
      if (!msg) {
        return res.status(404).json({ message: "Message not found" });
      }
      const party = await storage.getParty(msg.partyId);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Only the party host can delete messages" });
      }
      await storage.deletePartyMessage(req.params.id);
      return res.json({ message: "Message deleted" });
    } catch (error: any) {
      console.error("[ERROR] Delete message failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // QR Check-in Routes
  app.post("/api/parties/:id/checkin", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.qrToken !== req.body.qrToken) {
        return res.status(400).json({ message: "Invalid QR token" });
      }
      if (party.status !== "upcoming" && party.status !== "ongoing") {
        return res.status(400).json({ message: "Party is not active" });
      }
      const attendee = await storage.getAttendeeByPartyAndUser(req.params.id, req.session.userId);
      if (!attendee) {
        return res.status(403).json({ message: "You are not an attendee of this party" });
      }
      if (attendee.checkedIn) {
        return res.status(409).json({ message: "Already checked in" });
      }
      await storage.updateAttendee(attendee.id, {
        checkedIn: true,
        checkedInAt: new Date().toISOString(),
      });
      return res.json({ message: "Checked in successfully" });
    } catch (error: any) {
      console.error("[ERROR] Check-in failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties/:id/qr", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Only the host can view the QR token" });
      }
      return res.json({ qrToken: party.qrToken });
    } catch (error: any) {
      console.error("[ERROR] Get QR token failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Map Route
  app.get("/api/map", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const lat = req.query.lat ? parseFloat(req.query.lat as string) : undefined;
      const lng = req.query.lng ? parseFloat(req.query.lng as string) : undefined;
      const radius = req.query.radius ? parseFloat(req.query.radius as string) : 50;
      const statusFilter = req.query.status as string | undefined;

      let allParties = await storage.getAllParties();
      if (statusFilter) {
        allParties = allParties.filter(p => p.status === statusFilter);
      } else {
        allParties = allParties.filter(p => p.status === "upcoming" || p.status === "ongoing");
      }

      let allBusinesses = await storage.getBusinesses();

      if (lat !== undefined && lng !== undefined) {
        allParties = allParties.filter(party => {
          if (party.latitude === null || party.longitude === null) return false;
          return haversineDistance(lat, lng, party.latitude, party.longitude) <= radius;
        });
        allBusinesses = allBusinesses.filter(biz => {
          return haversineDistance(lat, lng, biz.latitude, biz.longitude) <= radius;
        });
      }

      const safeParties = allParties.map(({ exactAddress, ...p }) => p);
      return res.json({ parties: safeParties, businesses: allBusinesses });
    } catch (error: any) {
      console.error("[ERROR] Map data failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // AI Party Suggestions Route
  app.post("/api/ai/party-suggestions", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const { partyId } = req.body;
      if (!partyId) {
        return res.status(400).json({ message: "partyId is required" });
      }
      const party = await storage.getParty(partyId);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      const host = await storage.getUser(party.hostId);
      const attendees = await storage.getPartyAttendees(partyId);
      const attendeeUsers = await Promise.all(
        attendees.map(async (a) => {
          const user = await storage.getUser(a.userId);
          return user?.fullName || "Guest";
        })
      );

      const prompt = `You are a helpful party planning assistant for CambuApp. Based on the following party details, suggest what guests should bring, how to prepare, and any tips for a great experience.

Party Title: ${party.title}
Theme: ${party.theme}
Description: ${party.description}
Vibe: ${party.vibe || "Not specified"}
Date: ${party.date}
Location: ${party.locationName}, ${party.city}, ${party.country}
Max Guests: ${party.maxGuests}
Current Attendees: ${attendeeUsers.length}
What to Bring: ${party.whatToBring?.join(", ") || "Not specified"}
Includes Alcohol: ${party.includesAlcohol ? "Yes" : "No"}
House Rules: ${party.houseRules || "None"}
Host: ${host?.fullName || "Unknown"}

Please provide practical, fun suggestions in a friendly tone. Keep it concise (under 300 words).`;

      try {
        const { GoogleGenAI } = await import("@google/genai");
        const ai = new GoogleGenAI({
          apiKey: process.env.AI_INTEGRATIONS_GEMINI_API_KEY!,
          httpOptions: {
            apiVersion: "",
            baseUrl: process.env.AI_INTEGRATIONS_GEMINI_BASE_URL!,
          },
        });
        const response = await ai.models.generateContent({
          model: "gemini-2.5-flash",
          contents: [{ role: "user", parts: [{ text: prompt }] }],
        });
        const suggestions = response.text || "Unable to generate suggestions at this time.";
        return res.json({ suggestions });
      } catch (aiError: any) {
        console.error("[WARN] AI suggestions failed:", aiError.message);
        return res.json({ suggestions: "AI suggestions are currently unavailable. Please try again later." });
      }
    } catch (error: any) {
      console.error("[ERROR] AI party suggestions failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin Routes
  const requireAdmin = async (req: any, res: any, next: any) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    const user = await storage.getUser(req.session.userId);
    if (!user || !user.isAdmin) {
      return res.status(403).json({ message: "Admin access required" });
    }
    next();
  };

  app.get("/api/admin/stats", requireAdmin, async (_req, res) => {
    try {
      const allUsers = await storage.getAllUsers();
      const allParties = await storage.getAllParties();

      const totalUsers = allUsers.length;
      const totalParties = allParties.length;
      const activeParties = allParties.filter(p => p.status === "upcoming" || p.status === "ongoing").length;
      const finishedParties = allParties.filter(p => p.status === "finished").length;
      const bannedUsers = allUsers.filter(u => u.isBanned).length;
      const verifiedUsers = allUsers.filter(u => u.isIdVerified).length;

      return res.json({
        totalUsers,
        totalParties,
        activeParties,
        finishedParties,
        bannedUsers,
        verifiedUsers,
      });
    } catch (error: any) {
      console.error("[ERROR] Admin stats failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/parties/:id", requireAdmin, async (req, res) => {
    try {
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      await storage.deleteParty(req.params.id);
      console.log(`[ADMIN] Party ${req.params.id} deleted by admin ${req.session.userId}`);
      return res.json({ message: "Party deleted by admin" });
    } catch (error: any) {
      console.error("[ERROR] Admin delete party failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/users/:id/ban", requireAdmin, async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const newBanStatus = !user.isBanned;
      const updated = await storage.updateUser(req.params.id, { isBanned: newBanStatus });
      console.log(`[ADMIN] User ${req.params.id} ${newBanStatus ? "banned" : "unbanned"} by admin ${req.session.userId}`);
      if (!updated) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = updated;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Admin ban user failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/reviews/:id", requireAdmin, async (req, res) => {
    try {
      await storage.deleteReview(req.params.id);
      console.log(`[ADMIN] Review ${req.params.id} deleted by admin ${req.session.userId}`);
      return res.json({ message: "Review deleted by admin" });
    } catch (error: any) {
      console.error("[ERROR] Admin delete review failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Legal Routes
  app.get("/api/legal/terms", (_req, res) => {
    return res.json({ content: TERMS_OF_SERVICE });
  });

  app.get("/api/legal/privacy", (_req, res) => {
    return res.json({ content: PRIVACY_POLICY });
  });

  app.get("/api/legal/eula", (_req, res) => {
    return res.json({ content: EULA_TEXT });
  });

  updatePartyStatuses().catch(console.error);
  setInterval(() => {
    updatePartyStatuses().catch(console.error);
  }, 60 * 60 * 1000);

  return httpServer;
}


========================================
FILE: server/storage.ts
========================================
import {
  type User, type InsertUser,
  type Party, type InsertParty,
  type PartyAttendee, type InsertPartyAttendee,
  type PartyRequest, type InsertPartyRequest,
  type Review, type InsertReview,
  type PartyMessage, type InsertPartyMessage,
  type Business, type InsertBusiness,
  users, parties, partyAttendees, partyRequests, reviews, partyMessages, businesses,
} from "@shared/schema";
import { eq, and, count, or } from "drizzle-orm";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
import * as schema from "@shared/schema";

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool, { schema });

export interface IStorage {
  getUser(id: string): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: string, data: Partial<InsertUser>): Promise<User | undefined>;
  getParties(): Promise<Party[]>;
  getPartiesByCity(city: string): Promise<Party[]>;
  getParty(id: string): Promise<Party | undefined>;
  getPartiesByHost(hostId: string): Promise<Party[]>;
  createParty(party: InsertParty): Promise<Party>;
  updateParty(id: string, data: Partial<InsertParty>): Promise<Party | undefined>;
  deleteParty(id: string): Promise<void>;
  getPartyAttendees(partyId: string): Promise<PartyAttendee[]>;
  getAttendeeParties(userId: string): Promise<Party[]>;
  addAttendee(partyId: string, userId: string): Promise<PartyAttendee>;
  removeAttendee(partyId: string, userId: string): Promise<void>;
  getAttendeeCount(partyId: string): Promise<number>;
  getPartyRequests(partyId: string): Promise<PartyRequest[]>;
  getUserRequests(userId: string): Promise<PartyRequest[]>;
  createPartyRequest(request: InsertPartyRequest): Promise<PartyRequest>;
  updateRequestStatus(id: string, status: string): Promise<PartyRequest | undefined>;
  getRequest(id: string): Promise<PartyRequest | undefined>;
  getReviewsByTarget(targetId: string): Promise<Review[]>;
  getReviewsByAuthor(authorId: string): Promise<Review[]>;
  createReview(review: InsertReview): Promise<Review>;
  getPartiesCount(): Promise<number>;
  getPartyRequestByUserAndParty(userId: string, partyId: string): Promise<PartyRequest | undefined>;
  getAllUsers(): Promise<User[]>;
  getAllParties(): Promise<Party[]>;
  deleteReview(id: string): Promise<void>;
  getPartyMessages(partyId: string): Promise<PartyMessage[]>;
  createPartyMessage(message: InsertPartyMessage): Promise<PartyMessage>;
  deletePartyMessage(id: string): Promise<void>;
  getPartyMessage(id: string): Promise<PartyMessage | undefined>;
  getBusinesses(): Promise<Business[]>;
  getBusinessesByCity(city: string): Promise<Business[]>;
  createBusiness(business: InsertBusiness): Promise<Business>;
  getAttendeeByPartyAndUser(partyId: string, userId: string): Promise<PartyAttendee | undefined>;
  updateAttendee(id: string, data: Partial<InsertPartyAttendee>): Promise<PartyAttendee | undefined>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }

  async createUser(user: InsertUser): Promise<User> {
    const [created] = await db.insert(users).values(user).returning();
    return created;
  }

  async updateUser(id: string, data: Partial<InsertUser>): Promise<User | undefined> {
    const filteredData = Object.fromEntries(
      Object.entries(data).filter(([_, v]) => v !== undefined)
    );
    if (Object.keys(filteredData).length === 0) {
      return this.getUser(id);
    }
    const [updated] = await db.update(users).set(filteredData).where(eq(users.id, id)).returning();
    return updated;
  }

  async getParties(): Promise<Party[]> {
    return db.select().from(parties);
  }

  async getPartiesByCity(city: string): Promise<Party[]> {
    return db.select().from(parties).where(eq(parties.city, city));
  }

  async getParty(id: string): Promise<Party | undefined> {
    const [party] = await db.select().from(parties).where(eq(parties.id, id));
    return party;
  }

  async getPartiesByHost(hostId: string): Promise<Party[]> {
    return db.select().from(parties).where(eq(parties.hostId, hostId));
  }

  async createParty(party: InsertParty): Promise<Party> {
    const [created] = await db.insert(parties).values(party).returning();
    return created;
  }

  async updateParty(id: string, data: Partial<InsertParty>): Promise<Party | undefined> {
    const [updated] = await db.update(parties).set(data).where(eq(parties.id, id)).returning();
    return updated;
  }

  async deleteParty(id: string): Promise<void> {
    await db.delete(parties).where(eq(parties.id, id));
  }

  async getPartyAttendees(partyId: string): Promise<PartyAttendee[]> {
    return db.select().from(partyAttendees).where(eq(partyAttendees.partyId, partyId));
  }

  async getAttendeeParties(userId: string): Promise<Party[]> {
    const result = await db
      .select({ party: parties })
      .from(partyAttendees)
      .innerJoin(parties, eq(partyAttendees.partyId, parties.id))
      .where(eq(partyAttendees.userId, userId));
    return result.map(r => r.party);
  }

  async addAttendee(partyId: string, userId: string): Promise<PartyAttendee> {
    const [created] = await db.insert(partyAttendees).values({ partyId, userId }).returning();
    return created;
  }

  async removeAttendee(partyId: string, userId: string): Promise<void> {
    await db.delete(partyAttendees).where(
      and(eq(partyAttendees.partyId, partyId), eq(partyAttendees.userId, userId))
    );
  }

  async getAttendeeCount(partyId: string): Promise<number> {
    const [result] = await db.select({ count: count() }).from(partyAttendees).where(eq(partyAttendees.partyId, partyId));
    return result?.count ?? 0;
  }

  async getPartyRequests(partyId: string): Promise<PartyRequest[]> {
    return db.select().from(partyRequests).where(eq(partyRequests.partyId, partyId));
  }

  async getUserRequests(userId: string): Promise<PartyRequest[]> {
    return db.select().from(partyRequests).where(eq(partyRequests.userId, userId));
  }

  async createPartyRequest(request: InsertPartyRequest): Promise<PartyRequest> {
    const [created] = await db.insert(partyRequests).values(request).returning();
    return created;
  }

  async updateRequestStatus(id: string, status: string): Promise<PartyRequest | undefined> {
    const [updated] = await db.update(partyRequests).set({ status }).where(eq(partyRequests.id, id)).returning();
    return updated;
  }

  async getRequest(id: string): Promise<PartyRequest | undefined> {
    const [request] = await db.select().from(partyRequests).where(eq(partyRequests.id, id));
    return request;
  }

  async getReviewsByTarget(targetId: string): Promise<Review[]> {
    return db.select().from(reviews).where(eq(reviews.targetId, targetId));
  }

  async getReviewsByAuthor(authorId: string): Promise<Review[]> {
    return db.select().from(reviews).where(eq(reviews.authorId, authorId));
  }

  async createReview(review: InsertReview): Promise<Review> {
    const [created] = await db.insert(reviews).values(review).returning();
    return created;
  }

  async getPartiesCount(): Promise<number> {
    const [result] = await db.select({ count: count() }).from(parties);
    return result?.count ?? 0;
  }

  async getPartyRequestByUserAndParty(userId: string, partyId: string): Promise<PartyRequest | undefined> {
    const [request] = await db.select().from(partyRequests).where(
      and(
        eq(partyRequests.userId, userId),
        eq(partyRequests.partyId, partyId),
        or(eq(partyRequests.status, "pending"), eq(partyRequests.status, "accepted"))
      )
    );
    return request;
  }

  async getAllUsers(): Promise<User[]> {
    return db.select().from(users);
  }

  async getAllParties(): Promise<Party[]> {
    return db.select().from(parties);
  }

  async deleteReview(id: string): Promise<void> {
    await db.delete(reviews).where(eq(reviews.id, id));
  }

  async getPartyMessages(partyId: string): Promise<PartyMessage[]> {
    return db.select().from(partyMessages).where(eq(partyMessages.partyId, partyId));
  }

  async createPartyMessage(message: InsertPartyMessage): Promise<PartyMessage> {
    const [created] = await db.insert(partyMessages).values(message).returning();
    return created;
  }

  async deletePartyMessage(id: string): Promise<void> {
    await db.delete(partyMessages).where(eq(partyMessages.id, id));
  }

  async getPartyMessage(id: string): Promise<PartyMessage | undefined> {
    const [msg] = await db.select().from(partyMessages).where(eq(partyMessages.id, id));
    return msg;
  }

  async getBusinesses(): Promise<Business[]> {
    return db.select().from(businesses);
  }

  async getBusinessesByCity(city: string): Promise<Business[]> {
    return db.select().from(businesses).where(eq(businesses.city, city));
  }

  async createBusiness(business: InsertBusiness): Promise<Business> {
    const [created] = await db.insert(businesses).values(business).returning();
    return created;
  }

  async getAttendeeByPartyAndUser(partyId: string, userId: string): Promise<PartyAttendee | undefined> {
    const [attendee] = await db.select().from(partyAttendees).where(
      and(eq(partyAttendees.partyId, partyId), eq(partyAttendees.userId, userId))
    );
    return attendee;
  }

  async updateAttendee(id: string, data: Partial<InsertPartyAttendee>): Promise<PartyAttendee | undefined> {
    const filteredData = Object.fromEntries(
      Object.entries(data).filter(([_, v]) => v !== undefined)
    );
    if (Object.keys(filteredData).length === 0) {
      return undefined;
    }
    const [updated] = await db.update(partyAttendees).set(filteredData).where(eq(partyAttendees.id, id)).returning();
    return updated;
  }
}

export const storage = new DatabaseStorage();


========================================
FILE: server/vite.ts
========================================
import { type Express } from "express";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import fs from "fs";
import path from "path";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export async function setupVite(server: Server, app: Express) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server, path: "/vite-hmr" },
    allowedHosts: true as const,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);

  app.use("/{*path}", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}


========================================
FILE: server/static.ts
========================================
import express, { type Express } from "express";
import fs from "fs";
import path from "path";

export function serveStatic(app: Express) {
  const distPath = path.resolve(__dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("/{*path}", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}


========================================
FILE: script/build.ts
========================================
import { build as esbuild } from "esbuild";
import { build as viteBuild } from "vite";
import { rm, readFile } from "fs/promises";

// server deps to bundle to reduce openat(2) syscalls
// which helps cold start times
const allowlist = [
  "@google/generative-ai",
  "axios",
  "connect-pg-simple",
  "cors",
  "date-fns",
  "drizzle-orm",
  "drizzle-zod",
  "express",
  "express-rate-limit",
  "express-session",
  "jsonwebtoken",
  "memorystore",
  "multer",
  "nanoid",
  "nodemailer",
  "openai",
  "passport",
  "passport-local",
  "pg",
  "stripe",
  "uuid",
  "ws",
  "xlsx",
  "zod",
  "zod-validation-error",
];

async function buildAll() {
  await rm("dist", { recursive: true, force: true });

  console.log("building client...");
  await viteBuild();

  console.log("building server...");
  const pkg = JSON.parse(await readFile("package.json", "utf-8"));
  const allDeps = [
    ...Object.keys(pkg.dependencies || {}),
    ...Object.keys(pkg.devDependencies || {}),
  ];
  const externals = allDeps.filter((dep) => !allowlist.includes(dep));

  await esbuild({
    entryPoints: ["server/index.ts"],
    platform: "node",
    bundle: true,
    format: "cjs",
    outfile: "dist/index.cjs",
    define: {
      "process.env.NODE_ENV": '"production"',
    },
    minify: true,
    external: externals,
    logLevel: "info",
  });
}

buildAll().catch((err) => {
  console.error(err);
  process.exit(1);
});


========================================
FILE: client/index.html
========================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <title>CambuApp - The Party Vibe Network</title>
    <meta name="description" content="CambuApp connects partygoers and nightlife enthusiasts. Discover events, meet people, and experience the vibrant party scene in your city." />
    <meta property="og:title" content="CambuApp - The Party Vibe Network" />
    <meta property="og:description" content="CambuApp connects partygoers and nightlife enthusiasts. Discover events, meet people, and experience the vibrant party scene in your city." />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="CambuApp - The Party Vibe Network" />
    <meta name="twitter:description" content="CambuApp connects partygoers and nightlife enthusiasts. Discover events, meet people, and experience the vibrant party scene in your city." />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&family=Fira+Code:wght@300..700&family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Lora:ital,wght@0,400..700;1,400..700&family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&family=Montserrat:ital,wght@0,100..900;1,100..900&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Outfit:wght@100..900&family=Oxanium:wght@200..800&family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=Plus+Jakarta+Sans:ital,wght@0,200..800;1,200..800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100..900;1,100..900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&family=Space+Grotesk:wght@300..700&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

========================================
FILE: client/src/main.tsx
========================================
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

createRoot(document.getElementById("root")!).render(<App />);


========================================
FILE: client/src/App.tsx
========================================
import { Switch, Route, useLocation, Redirect } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { ThemeProvider } from "@/components/theme-provider";
import { useAuth } from "@/hooks/use-auth";
import NotFound from "@/pages/not-found";
import AuthPage from "@/pages/auth-page";
import OnboardingPage from "@/pages/onboarding-page";
import BrowsePage from "@/pages/browse-page";
import PartyDetailPage from "@/pages/party-detail-page";
import ProfilePage from "@/pages/profile-page";
import SettingsPage from "@/pages/settings-page";
import CreatePartyPage from "@/pages/create-party-page";
import HostPage from "@/pages/host-page";
import AttendingPage from "@/pages/attending-page";
import LegalPage from "@/pages/legal-page";
import PersonalityTestPage from "@/pages/personality-test-page";
import MapPage from "@/pages/map-page";
import EditPartyPage from "@/pages/edit-party-page";
import { MobileNav } from "@/components/mobile-nav";
import { Skeleton } from "@/components/ui/skeleton";

function AuthGuard({ children }: { children: React.ReactNode }) {
  const { user, isLoading, isAuthenticated } = useAuth();
  const [location] = useLocation();

  if (isLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="flex flex-col items-center gap-4">
          <Skeleton className="h-12 w-12 rounded-full" />
          <Skeleton className="h-4 w-32" />
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <Redirect to="/auth" />;
  }

  if (user && (!user.city || !user.country) && location !== "/onboarding") {
    return <Redirect to="/onboarding" />;
  }

  return <>{children}</>;
}

function Router() {
  return (
    <Switch>
      <Route path="/auth" component={AuthPage} />
      <Route path="/legal/:type" component={LegalPage} />
      <Route path="/">
        <AuthGuard>
          <BrowsePage />
        </AuthGuard>
      </Route>
      <Route path="/browse">
        <AuthGuard>
          <BrowsePage />
        </AuthGuard>
      </Route>
      <Route path="/onboarding">
        <AuthGuard>
          <OnboardingPage />
        </AuthGuard>
      </Route>
      <Route path="/party/:id">
        <AuthGuard>
          <PartyDetailPage />
        </AuthGuard>
      </Route>
      <Route path="/profile">
        <AuthGuard>
          <ProfilePage />
        </AuthGuard>
      </Route>
      <Route path="/personality-test">
        <AuthGuard>
          <PersonalityTestPage />
        </AuthGuard>
      </Route>
      <Route path="/settings">
        <AuthGuard>
          <SettingsPage />
        </AuthGuard>
      </Route>
      <Route path="/create-party">
        <AuthGuard>
          <CreatePartyPage />
        </AuthGuard>
      </Route>
      <Route path="/host">
        <AuthGuard>
          <HostPage />
        </AuthGuard>
      </Route>
      <Route path="/attending">
        <AuthGuard>
          <AttendingPage />
        </AuthGuard>
      </Route>
      <Route path="/map">
        <AuthGuard>
          <MapPage />
        </AuthGuard>
      </Route>
      <Route path="/edit-party/:id">
        <AuthGuard>
          <EditPartyPage />
        </AuthGuard>
      </Route>
      <Route component={NotFound} />
    </Switch>
  );
}

function AppContent() {
  const { isAuthenticated } = useAuth();
  const [location] = useLocation();
  const hideNav = ["/auth", "/onboarding"].includes(location) || location.startsWith("/legal");

  return (
    <div className="min-h-screen bg-background">
      <Router />
      {isAuthenticated && !hideNav && <MobileNav />}
    </div>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>
        <TooltipProvider>
          <AppContent />
          <Toaster />
        </TooltipProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

export default App;


========================================
FILE: client/src/index.css
========================================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* LIGHT MODE */
:root {
  --button-outline: rgba(0,0,0, .10);
  --badge-outline: rgba(0,0,0, .05);
  --opaque-button-border-intensity: -8;
  --elevate-1: rgba(0,0,0, .03);
  --elevate-2: rgba(0,0,0, .08);
  --background: 0 0% 100%;
  --foreground: 0 0% 9%;
  --border: 0 0% 91%;
  --card: 0 0% 98%;
  --card-foreground: 0 0% 9%;
  --card-border: 0 0% 95%;
  --sidebar: 0 0% 96%;
  --sidebar-foreground: 0 0% 9%;
  --sidebar-border: 0 0% 93%;
  --sidebar-primary: 280 85% 45%;
  --sidebar-primary-foreground: 280 20% 98%;
  --sidebar-accent: 280 12% 92%;
  --sidebar-accent-foreground: 280 8% 15%;
  --sidebar-ring: 280 85% 45%;
  --popover: 0 0% 94%;
  --popover-foreground: 0 0% 9%;
  --popover-border: 0 0% 91%;
  --primary: 280 85% 45%;
  --primary-foreground: 280 20% 98%;
  --secondary: 280 6% 90%;
  --secondary-foreground: 280 6% 15%;
  --muted: 280 4% 92%;
  --muted-foreground: 280 4% 35%;
  --accent: 280 8% 94%;
  --accent-foreground: 280 8% 15%;
  --destructive: 0 84% 42%;
  --destructive-foreground: 0 20% 98%;
  --input: 0 0% 75%;
  --ring: 280 85% 45%;
  --chart-1: 280 70% 35%;
  --chart-2: 320 65% 38%;
  --chart-3: 200 70% 35%;
  --chart-4: 40 75% 40%;
  --chart-5: 160 65% 35%;
  --font-sans: Open Sans, sans-serif;
  --font-serif: Georgia, serif;
  --font-mono: Menlo, monospace;
  --radius: .5rem;
  --shadow-2xs: 0px 2px 0px 0px hsl(280 85% 45% / 0.00);
  --shadow-xs: 0px 2px 0px 0px hsl(280 85% 45% / 0.00);
  --shadow-sm: 0px 2px 0px 0px hsl(280 85% 45% / 0.00), 0px 1px 2px -1px hsl(280 85% 45% / 0.00);
  --shadow: 0px 2px 0px 0px hsl(280 85% 45% / 0.00), 0px 1px 2px -1px hsl(280 85% 45% / 0.00);
  --shadow-md: 0px 2px 0px 0px hsl(280 85% 45% / 0.00), 0px 2px 4px -1px hsl(280 85% 45% / 0.00);
  --shadow-lg: 0px 2px 0px 0px hsl(280 85% 45% / 0.00), 0px 4px 6px -1px hsl(280 85% 45% / 0.00);
  --shadow-xl: 0px 2px 0px 0px hsl(280 85% 45% / 0.00), 0px 8px 10px -1px hsl(280 85% 45% / 0.00);
  --shadow-2xl: 0px 2px 0px 0px hsl(280 85% 45% / 0.00);
  --tracking-normal: 0em;
  --spacing: 0.25rem;

/* Fallback for older browsers */
  --sidebar-primary-border: hsl(var(--sidebar-primary));
  --sidebar-primary-border: hsl(from hsl(var(--sidebar-primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --sidebar-accent-border: hsl(var(--sidebar-accent));
  --sidebar-accent-border: hsl(from hsl(var(--sidebar-accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --primary-border: hsl(var(--primary));
  --primary-border: hsl(from hsl(var(--primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --secondary-border: hsl(var(--secondary));
  --secondary-border: hsl(from hsl(var(--secondary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --muted-border: hsl(var(--muted));
  --muted-border: hsl(from hsl(var(--muted)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --accent-border: hsl(var(--accent));
  --accent-border: hsl(from hsl(var(--accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --destructive-border: hsl(var(--destructive));
  --destructive-border: hsl(from hsl(var(--destructive)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);
}

.dark {
  --button-outline: rgba(255,255,255, .10);
  --badge-outline: rgba(255,255,255, .05);
  --opaque-button-border-intensity: 9;
  --elevate-1: rgba(255,255,255, .04);
  --elevate-2: rgba(255,255,255, .09);
  --background: 0 0% 7%;
  --foreground: 0 0% 95%;
  --border: 0 0% 16%;
  --card: 0 0% 9%;
  --card-foreground: 0 0% 95%;
  --card-border: 0 0% 12%;
  --sidebar: 0 0% 11%;
  --sidebar-foreground: 0 0% 95%;
  --sidebar-border: 0 0% 14%;
  --sidebar-primary: 280 85% 55%;
  --sidebar-primary-foreground: 280 20% 98%;
  --sidebar-accent: 280 12% 14%;
  --sidebar-accent-foreground: 280 8% 90%;
  --sidebar-ring: 280 85% 55%;
  --popover: 0 0% 13%;
  --popover-foreground: 0 0% 95%;
  --popover-border: 0 0% 16%;
  --primary: 280 85% 55%;
  --primary-foreground: 280 20% 98%;
  --secondary: 280 6% 16%;
  --secondary-foreground: 280 6% 90%;
  --muted: 280 4% 15%;
  --muted-foreground: 280 4% 70%;
  --accent: 280 8% 13%;
  --accent-foreground: 280 8% 90%;
  --destructive: 0 84% 42%;
  --destructive-foreground: 0 20% 98%;
  --input: 0 0% 30%;
  --ring: 280 85% 55%;
  --chart-1: 280 70% 65%;
  --chart-2: 320 65% 68%;
  --chart-3: 200 70% 65%;
  --chart-4: 40 75% 70%;
  --chart-5: 160 65% 65%;
  --shadow-2xs: 0px 2px 0px 0px hsl(280 85% 55% / 0.00);
  --shadow-xs: 0px 2px 0px 0px hsl(280 85% 55% / 0.00);
  --shadow-sm: 0px 2px 0px 0px hsl(280 85% 55% / 0.00), 0px 1px 2px -1px hsl(280 85% 55% / 0.00);
  --shadow: 0px 2px 0px 0px hsl(280 85% 55% / 0.00), 0px 1px 2px -1px hsl(280 85% 55% / 0.00);
  --shadow-md: 0px 2px 0px 0px hsl(280 85% 55% / 0.00), 0px 2px 4px -1px hsl(280 85% 55% / 0.00);
  --shadow-lg: 0px 2px 0px 0px hsl(280 85% 55% / 0.00), 0px 4px 6px -1px hsl(280 85% 55% / 0.00);
  --shadow-xl: 0px 2px 0px 0px hsl(280 85% 55% / 0.00), 0px 8px 10px -1px hsl(280 85% 55% / 0.00);
  --shadow-2xl: 0px 2px 0px 0px hsl(280 85% 55% / 0.00);

/* Fallback for older browsers */
  --sidebar-primary-border: hsl(var(--sidebar-primary));
  --sidebar-primary-border: hsl(from hsl(var(--sidebar-primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --sidebar-accent-border: hsl(var(--sidebar-accent));
  --sidebar-accent-border: hsl(from hsl(var(--sidebar-accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --primary-border: hsl(var(--primary));
  --primary-border: hsl(from hsl(var(--primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --secondary-border: hsl(var(--secondary));
  --secondary-border: hsl(from hsl(var(--secondary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --muted-border: hsl(var(--muted));
  --muted-border: hsl(from hsl(var(--muted)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --accent-border: hsl(var(--accent));
  --accent-border: hsl(from hsl(var(--accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --destructive-border: hsl(var(--destructive));
  --destructive-border: hsl(from hsl(var(--destructive)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply font-sans antialiased bg-background text-foreground;
  }
}

/**
 * Using the elevate system.
 * Automatic contrast adjustment.
 *
 * <element className="hover-elevate" />
 * <element className="active-elevate-2" />
 *
 * // Using the tailwind utility when a data attribute is "on"
 * <element className="toggle-elevate data-[state=on]:toggle-elevated" />
 * // Or manually controlling the toggle state
 * <element className="toggle-elevate toggle-elevated" />
 *
 * Elevation systems have to handle many states.
 * - not-hovered, vs. hovered vs. active  (three mutually exclusive states)
 * - toggled or not
 * - focused or not (this is not handled with these utilities)
 *
 * Even without handling focused or not, this is six possible combinations that
 * need to be distinguished from eachother visually.
 */
@layer utilities {

  /* Hide ugly search cancel button in Chrome until we can style it properly */
  input[type="search"]::-webkit-search-cancel-button {
    @apply hidden;
  }

  /* Placeholder styling for contentEditable div */
  [contenteditable][data-placeholder]:empty::before {
    content: attr(data-placeholder);
    color: hsl(var(--muted-foreground));
    pointer-events: none;
  }

  /* .no-default-hover-elevate/no-default-active-elevate is an escape hatch so consumers of
   * buttons/badges can remove the automatic brightness adjustment on interactions
   * and program their own. */
  .no-default-hover-elevate {}

  .no-default-active-elevate {}


  /**
   * Toggleable backgrounds go behind the content. Hoverable/active goes on top.
   * This way they can stack/compound. Both will overlap the parent's borders!
   * So borders will be automatically adjusted both on toggle, and hover/active,
   * and they will be compounded.
   */
  .toggle-elevate::before,
  .toggle-elevate-2::before {
    content: "";
    pointer-events: none;
    position: absolute;
    inset: 0px;
    /*border-radius: inherit;   match rounded corners */
    border-radius: inherit;
    z-index: -1;
    /* sits behind content but above backdrop */
  }

  .toggle-elevate.toggle-elevated::before {
    background-color: var(--elevate-2);
  }

  /* If there's a 1px border, adjust the inset so that it covers that parent's border */
  .border.toggle-elevate::before {
    inset: -1px;
  }

  /* Does not work on elements with overflow:hidden! */
  .hover-elevate:not(.no-default-hover-elevate),
  .active-elevate:not(.no-default-active-elevate),
  .hover-elevate-2:not(.no-default-hover-elevate),
  .active-elevate-2:not(.no-default-active-elevate) {
    position: relative;
    z-index: 0;
  }

  .hover-elevate:not(.no-default-hover-elevate)::after,
  .active-elevate:not(.no-default-active-elevate)::after,
  .hover-elevate-2:not(.no-default-hover-elevate)::after,
  .active-elevate-2:not(.no-default-active-elevate)::after {
    content: "";
    pointer-events: none;
    position: absolute;
    inset: 0px;
    /*border-radius: inherit;   match rounded corners */
    border-radius: inherit;
    z-index: 999;
    /* sits in front of content */
  }

  .hover-elevate:hover:not(.no-default-hover-elevate)::after,
  .active-elevate:active:not(.no-default-active-elevate)::after {
    background-color: var(--elevate-1);
  }

  .hover-elevate-2:hover:not(.no-default-hover-elevate)::after,
  .active-elevate-2:active:not(.no-default-active-elevate)::after {
    background-color: var(--elevate-2);
  }

  /* If there's a 1px border, adjust the inset so that it covers that parent's border */
  .border.hover-elevate:not(.no-hover-interaction-elevate)::after,
  .border.active-elevate:not(.no-active-interaction-elevate)::after,
  .border.hover-elevate-2:not(.no-hover-interaction-elevate)::after,
  .border.active-elevate-2:not(.no-active-interaction-elevate)::after,
  .border.hover-elevate:not(.no-hover-interaction-elevate)::after {
    inset: -1px;
  }

  .glass {
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
  }
  
  .dark .glass {
    background: rgba(0, 0, 0, 0.5);
  }
  
  .light .glass,
  :root:not(.dark) .glass {
    background: rgba(255, 255, 255, 0.7);
  }
}


========================================
FILE: client/src/lib/queryClient.ts
========================================
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const res = await fetch(queryKey.join("/") as string, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});


========================================
FILE: client/src/lib/utils.ts
========================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


========================================
FILE: client/src/hooks/use-auth.ts
========================================
import { useQuery, useMutation } from "@tanstack/react-query";
import { apiRequest, queryClient, getQueryFn } from "@/lib/queryClient";
import { useLocation } from "wouter";
import type { User } from "@shared/schema";

export function useAuth() {
  const [, setLocation] = useLocation();

  const { data: user, isLoading } = useQuery<User | null>({
    queryKey: ["/api/auth/me"],
    queryFn: getQueryFn({ on401: "returnNull" }),
    retry: false,
    staleTime: 5 * 60 * 1000,
  });

  const logoutMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", "/api/auth/logout");
    },
    onSuccess: () => {
      queryClient.setQueryData(["/api/auth/me"], null);
      setLocation("/auth");
    },
  });

  return {
    user: user ?? null,
    isLoading,
    isAuthenticated: !!user,
    logout: logoutMutation.mutate,
  };
}


========================================
FILE: client/src/hooks/use-toast.ts
========================================
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }


========================================
FILE: client/src/hooks/use-mobile.tsx
========================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}


========================================
FILE: client/src/components/mobile-nav.tsx
========================================
import { useLocation } from "wouter";
import { Search, Home, Calendar, User, Plus } from "lucide-react";

const navItems = [
  { path: "/browse", label: "Browse", icon: Search },
  { path: "/host", label: "Host", icon: Home },
  { path: "/create-party", label: "Create", icon: Plus },
  { path: "/attending", label: "Going", icon: Calendar },
  { path: "/profile", label: "Profile", icon: User },
];

export function MobileNav() {
  const [location, setLocation] = useLocation();

  const isActive = (path: string) => {
    if (path === "/browse") return location === "/" || location === "/browse";
    if (path === "/host") return location === "/host";
    return location === path;
  };

  return (
    <nav className="fixed bottom-4 inset-x-4 glass border border-border/30 p-1.5 flex justify-around z-50 rounded-[28px]" data-testid="mobile-nav">
      {navItems.map((item) => {
        const active = isActive(item.path);
        const Icon = item.icon;
        const isCreate = item.path === "/create-party";

        return (
          <button
            key={item.path}
            onClick={() => setLocation(item.path)}
            data-testid={`nav-${item.label.toLowerCase()}`}
            className={`relative flex flex-col items-center gap-0.5 px-3 py-2 rounded-[22px] transition-all duration-200 ${
              isCreate
                ? "bg-primary text-primary-foreground px-4"
                : active
                  ? "bg-foreground/10 dark:bg-foreground/15 text-foreground"
                  : "text-muted-foreground"
            }`}
          >
            <Icon size={20} strokeWidth={active || isCreate ? 2.5 : 2} />
            <span className="text-[10px] font-medium leading-none">{item.label}</span>
          </button>
        );
      })}
    </nav>
  );
}


========================================
FILE: client/src/components/theme-provider.tsx
========================================
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "light" | "dark";

interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
  setTheme: (theme: Theme) => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setThemeState] = useState<Theme>(() => {
    if (typeof window !== "undefined") {
      return (localStorage.getItem("cambuapp-theme") as Theme) || "dark";
    }
    return "dark";
  });

  useEffect(() => {
    const root = document.documentElement;
    if (theme === "dark") {
      root.classList.add("dark");
    } else {
      root.classList.remove("dark");
    }
    localStorage.setItem("cambuapp-theme", theme);
  }, [theme]);

  const toggleTheme = () => {
    setThemeState((prev) => (prev === "dark" ? "light" : "dark"));
  };

  const setTheme = (t: Theme) => setThemeState(t);

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) throw new Error("useTheme must be used within ThemeProvider");
  return context;
}


========================================
FILE: client/src/pages/auth-page.tsx
========================================
import { useState, useEffect } from "react";
import { useLocation, Link } from "wouter";
import { useMutation } from "@tanstack/react-query";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { PartyPopper, Sparkles, Loader2 } from "lucide-react";

const loginSchema = z.object({
  username: z.string().min(1, "Username is required"),
  password: z.string().min(1, "Password is required"),
});

const registerSchema = z.object({
  username: z.string().min(3, "Username must be at least 3 characters"),
  email: z.string().email("Please enter a valid email"),
  password: z.string().min(6, "Password must be at least 6 characters"),
  fullName: z.string().min(2, "Full name is required"),
  agreedToTerms: z.boolean().refine(v => v === true, "You must agree to the terms and EULA"),
});

type LoginValues = z.infer<typeof loginSchema>;
type RegisterValues = z.infer<typeof registerSchema>;

export default function AuthPage() {
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const { user, isLoading: authLoading } = useAuth();
  const [activeTab, setActiveTab] = useState("signin");

  const loginForm = useForm<LoginValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: { username: "", password: "" },
  });

  const registerForm = useForm<RegisterValues>({
    resolver: zodResolver(registerSchema),
    defaultValues: { username: "", email: "", password: "", fullName: "", agreedToTerms: false },
  });

  const loginMutation = useMutation({
    mutationFn: async (values: LoginValues) => {
      const res = await apiRequest("POST", "/api/auth/login", values);
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      toast({ title: "Welcome back!", description: "You've signed in successfully." });
      setLocation("/");
    },
    onError: (error: Error) => {
      toast({
        title: "Sign in failed",
        description: error.message.includes("401") ? "Invalid username or password" : error.message,
        variant: "destructive",
      });
    },
  });

  const registerMutation = useMutation({
    mutationFn: async (values: RegisterValues) => {
      const res = await apiRequest("POST", "/api/auth/register", { ...values, agreedToEula: values.agreedToTerms });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      toast({ title: "Account created!", description: "Let's set up your profile." });
      setLocation("/onboarding");
    },
    onError: (error: Error) => {
      toast({
        title: "Registration failed",
        description: error.message.includes("409") ? "Username already taken" : error.message,
        variant: "destructive",
      });
    },
  });

  useEffect(() => {
    if (user && !authLoading) {
      setLocation("/");
    }
  }, [user, authLoading, setLocation]);

  if (authLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (user) return null;

  return (
    <div className="min-h-screen bg-background flex flex-col">
      <div className="relative overflow-hidden py-16 px-4 flex flex-col items-center justify-center"
        style={{
          background: "linear-gradient(135deg, hsl(280 85% 15%) 0%, hsl(280 85% 8%) 50%, hsl(300 60% 10%) 100%)",
        }}
      >
        <div
          className="absolute inset-0 opacity-20"
          style={{
            background: "radial-gradient(circle at 30% 50%, hsl(280 85% 55% / 0.4) 0%, transparent 50%), radial-gradient(circle at 70% 30%, hsl(320 65% 50% / 0.3) 0%, transparent 40%)",
          }}
        />
        <div className="relative z-10 text-center">
          <div className="flex items-center justify-center gap-3 mb-3">
            <PartyPopper className="w-10 h-10 text-primary-foreground" />
            <h1 className="text-4xl font-bold text-primary-foreground tracking-tight" data-testid="text-app-title">
              CambuApp
            </h1>
            <Sparkles className="w-8 h-8 text-primary-foreground opacity-80" />
          </div>
          <p className="text-primary-foreground/70 text-lg" data-testid="text-app-tagline">
            The Party Vibe Network
          </p>
        </div>
      </div>

      <div className="flex-1 flex items-start justify-center px-4 -mt-8 pb-12">
        <Card className="w-full max-w-md relative z-10">
          <CardContent className="pt-6">
            <Tabs value={activeTab} onValueChange={setActiveTab}>
              <TabsList className="w-full mb-6">
                <TabsTrigger value="signin" className="flex-1" data-testid="tab-signin">
                  Sign In
                </TabsTrigger>
                <TabsTrigger value="signup" className="flex-1" data-testid="tab-signup">
                  Sign Up
                </TabsTrigger>
              </TabsList>

              <TabsContent value="signin">
                <Form {...loginForm}>
                  <form
                    onSubmit={loginForm.handleSubmit((v) => loginMutation.mutate(v))}
                    className="space-y-4"
                    data-testid="form-signin"
                  >
                    <FormField
                      control={loginForm.control}
                      name="username"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Username</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="Enter your username"
                              data-testid="input-login-username"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={loginForm.control}
                      name="password"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Password</FormLabel>
                          <FormControl>
                            <Input
                              type="password"
                              placeholder="Enter your password"
                              data-testid="input-login-password"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <Button
                      type="submit"
                      className="w-full"
                      disabled={loginMutation.isPending}
                      data-testid="button-signin"
                    >
                      {loginMutation.isPending ? (
                        <Loader2 className="w-4 h-4 animate-spin mr-2" />
                      ) : null}
                      Sign In
                    </Button>
                  </form>
                </Form>
                <p className="text-center text-sm text-muted-foreground mt-4">
                  Don't have an account?{" "}
                  <button
                    type="button"
                    className="text-foreground underline underline-offset-2"
                    onClick={() => setActiveTab("signup")}
                    data-testid="link-goto-signup"
                  >
                    Sign up
                  </button>
                </p>
              </TabsContent>

              <TabsContent value="signup">
                <Form {...registerForm}>
                  <form
                    onSubmit={registerForm.handleSubmit((v) => registerMutation.mutate(v))}
                    className="space-y-4"
                    data-testid="form-signup"
                  >
                    <FormField
                      control={registerForm.control}
                      name="fullName"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Full Name</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="Your full name"
                              data-testid="input-register-fullname"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={registerForm.control}
                      name="username"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Username</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="Choose a username"
                              data-testid="input-register-username"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={registerForm.control}
                      name="email"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Email</FormLabel>
                          <FormControl>
                            <Input
                              type="email"
                              placeholder="you@example.com"
                              data-testid="input-register-email"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={registerForm.control}
                      name="password"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Password</FormLabel>
                          <FormControl>
                            <Input
                              type="password"
                              placeholder="At least 6 characters"
                              data-testid="input-register-password"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={registerForm.control}
                      name="agreedToTerms"
                      render={({ field }) => (
                        <FormItem>
                          <div className="flex items-start gap-3">
                            <FormControl>
                              <Checkbox
                                checked={field.value}
                                onCheckedChange={field.onChange}
                                data-testid="checkbox-agree-terms"
                              />
                            </FormControl>
                            <FormLabel className="text-sm font-normal leading-snug cursor-pointer">
                              I agree to the{" "}
                              <Link href="/legal/terms" className="underline underline-offset-2" data-testid="link-terms">
                                Terms of Service
                              </Link>
                              ,{" "}
                              <Link href="/legal/privacy" className="underline underline-offset-2" data-testid="link-privacy">
                                Privacy Policy
                              </Link>
                              , and{" "}
                              <Link href="/legal/eula" className="underline underline-offset-2" data-testid="link-eula">
                                EULA
                              </Link>
                            </FormLabel>
                          </div>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <Button
                      type="submit"
                      className="w-full"
                      disabled={registerMutation.isPending}
                      data-testid="button-signup"
                    >
                      {registerMutation.isPending ? (
                        <Loader2 className="w-4 h-4 animate-spin mr-2" />
                      ) : null}
                      Create Account
                    </Button>
                  </form>
                </Form>
                <p className="text-center text-sm text-muted-foreground mt-4">
                  Already have an account?{" "}
                  <button
                    type="button"
                    className="text-foreground underline underline-offset-2"
                    onClick={() => setActiveTab("signin")}
                    data-testid="link-goto-signin"
                  >
                    Sign in
                  </button>
                </p>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}


========================================
FILE: client/src/pages/browse-page.tsx
========================================
import { useState, useMemo } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Link, useLocation } from "wouter";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";
import { Search, SlidersHorizontal, MapPin, Calendar, Users, DollarSign, Wine, Star, ChevronDown, ChevronUp, PartyPopper, Loader2, Map as MapIcon } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { format, isAfter, isBefore, endOfWeek, endOfMonth, addMonths, subDays, subWeeks } from "date-fns";
import type { Party } from "@shared/schema";

interface EnrichedParty extends Party {
  hostName: string;
  hostAvatar: string;
  hostVerified: boolean;
  attendeeCount: number;
}

interface PartiesResponse {
  parties: EnrichedParty[];
  total: number;
  hasMore: boolean;
}

const THEMES = [
  "All",
  "Cyberpunk/Neon",
  "Cocktail/Lounge",
  "Pool Party",
  "Indie/Bohemian",
  "Festival/EDM",
  "House Party",
  "Dinner Party",
  "Outdoor/BBQ",
  "Game Night",
];

function formatPartyDate(dateStr: string) {
  try {
    return format(new Date(dateStr), "MMM d, yyyy 'at' h:mm a");
  } catch {
    return dateStr;
  }
}

function PartyCardSkeleton() {
  return (
    <Card className="overflow-visible">
      <Skeleton className="h-48 w-full rounded-t-md rounded-b-none" />
      <CardContent className="p-4 space-y-3">
        <Skeleton className="h-5 w-3/4" />
        <Skeleton className="h-4 w-1/2" />
        <Skeleton className="h-4 w-2/3" />
        <div className="flex items-center gap-2">
          <Skeleton className="h-4 w-16" />
          <Skeleton className="h-4 w-20" />
        </div>
      </CardContent>
    </Card>
  );
}

export default function BrowsePage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [, navigate] = useLocation();
  const [search, setSearch] = useState("");
  const [filtersOpen, setFiltersOpen] = useState(false);
  const [sortBy, setSortBy] = useState("newest");
  const [maxPrice, setMaxPrice] = useState([200]);
  const [themeFilter, setThemeFilter] = useState("All");
  const [crowdSize, setCrowdSize] = useState("All");
  const [dateFilter, setDateFilter] = useState("All dates");
  const [freeOnly, setFreeOnly] = useState(false);
  const [browseMode, setBrowseMode] = useState<"upcoming" | "past">("upcoming");
  const [offset, setOffset] = useState(0);
  const [allParties, setAllParties] = useState<EnrichedParty[]>([]);
  const [gpsLat, setGpsLat] = useState<number | null>(user?.latitude ?? null);
  const [gpsLng, setGpsLng] = useState<number | null>(user?.longitude ?? null);
  const [searchRadius, setSearchRadius] = useState([user?.searchRadius ?? 50]);
  const [locating, setLocating] = useState(false);

  const buildQueryUrl = () => {
    const params = new URLSearchParams();
    if (offset > 0) params.set("offset", String(offset));
    if (browseMode !== "past" && gpsLat !== null && gpsLng !== null) {
      params.set("lat", String(gpsLat));
      params.set("lng", String(gpsLng));
      params.set("radius", String(searchRadius[0]));
    }
    if (browseMode === "past") {
      params.set("status", "finished");
    }
    const qs = params.toString();
    return `/api/parties${qs ? `?${qs}` : ""}`;
  };

  const { data, isLoading } = useQuery<PartiesResponse>({
    queryKey: ["/api/parties", offset, gpsLat, gpsLng, searchRadius[0], browseMode],
    queryFn: async () => {
      const res = await fetch(buildQueryUrl(), { credentials: "include" });
      if (!res.ok) throw new Error("Failed to fetch parties");
      return res.json();
    },
  });


  const parties = useMemo(() => {
    if (!data?.parties) return allParties;
    if (offset === 0) return data.parties;
    const existingIds = new Set(allParties.map(p => p.id));
    const newParties = data.parties.filter(p => !existingIds.has(p.id));
    return [...allParties, ...newParties];
  }, [data, offset, allParties]);

  const hasMore = data?.hasMore ?? false;

  const handleLoadMore = () => {
    setAllParties(parties);
    setOffset(parties.length);
  };

  const locationMutation = useMutation({
    mutationFn: async ({ lat, lng }: { lat: number; lng: number }) => {
      if (!user) throw new Error("Not authenticated");
      const res = await apiRequest("PATCH", `/api/users/${user.id}`, {
        latitude: lat,
        longitude: lng,
      });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      queryClient.invalidateQueries({ queryKey: ["/api/parties"] });
      toast({ title: "Location updated", description: "Showing parties near you." });
    },
    onError: () => {
      toast({ title: "Failed to update location", variant: "destructive" });
    },
  });

  const handleUseLocation = () => {
    if (!navigator.geolocation) {
      toast({ title: "Geolocation not supported", description: "Your browser does not support location services.", variant: "destructive" });
      return;
    }
    setLocating(true);
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        setGpsLat(lat);
        setGpsLng(lng);
        setOffset(0);
        setAllParties([]);
        locationMutation.mutate({ lat, lng });
        setLocating(false);
      },
      (err) => {
        setLocating(false);
        toast({ title: "Location access denied", description: "Please enable location permissions.", variant: "destructive" });
      },
      { enableHighAccuracy: true, timeout: 10000 }
    );
  };

  const handleRadiusChange = (value: number[]) => {
    setSearchRadius(value);
    setOffset(0);
    setAllParties([]);
  };

  const activeFilterCount = useMemo(() => {
    let count = 0;
    if (sortBy !== "newest") count++;
    if (themeFilter !== "All") count++;
    if (maxPrice[0] < 200) count++;
    if (crowdSize !== "All") count++;
    if (dateFilter !== "All dates") count++;
    if (freeOnly) count++;
    return count;
  }, [sortBy, themeFilter, maxPrice, crowdSize, dateFilter, freeOnly]);

  const filteredParties = useMemo(() => {
    if (!parties) return [];
    let result = [...parties];

    if (search.trim()) {
      const q = search.toLowerCase();
      result = result.filter(
        (p) =>
          p.title.toLowerCase().includes(q) ||
          p.theme.toLowerCase().includes(q)
      );
    }

    if (themeFilter !== "All") {
      result = result.filter((p) => p.theme === themeFilter);
    }

    result = result.filter((p) => (p.price ?? 0) <= maxPrice[0]);

    if (freeOnly) {
      result = result.filter((p) => (p.price ?? 0) === 0);
    }

    if (crowdSize === "Intimate (1-15)") {
      result = result.filter((p) => p.maxGuests <= 15);
    } else if (crowdSize === "Medium (16-40)") {
      result = result.filter((p) => p.maxGuests >= 16 && p.maxGuests <= 40);
    } else if (crowdSize === "Large (41+)") {
      result = result.filter((p) => p.maxGuests > 40);
    }

    if (dateFilter !== "All dates") {
      const now = new Date();
      if (browseMode === "upcoming") {
        if (dateFilter === "This week") {
          const weekEnd = endOfWeek(now, { weekStartsOn: 1 });
          result = result.filter((p) => {
            const partyDate = new Date(p.date);
            return isAfter(partyDate, now) && isBefore(partyDate, weekEnd);
          });
        } else if (dateFilter === "This month") {
          const monthEnd = endOfMonth(now);
          result = result.filter((p) => {
            const partyDate = new Date(p.date);
            return isAfter(partyDate, now) && isBefore(partyDate, monthEnd);
          });
        } else if (dateFilter === "Next 3 months") {
          const threeMonthsOut = addMonths(now, 3);
          result = result.filter((p) => {
            const partyDate = new Date(p.date);
            return isAfter(partyDate, now) && isBefore(partyDate, threeMonthsOut);
          });
        }
      } else {
        if (dateFilter === "Last week") {
          const oneWeekAgo = subWeeks(now, 1);
          result = result.filter((p) => {
            const partyDate = new Date(p.date);
            return isAfter(partyDate, oneWeekAgo) && isBefore(partyDate, now);
          });
        } else if (dateFilter === "Last 2 weeks") {
          const twoWeeksAgo = subWeeks(now, 2);
          result = result.filter((p) => {
            const partyDate = new Date(p.date);
            return isAfter(partyDate, twoWeeksAgo) && isBefore(partyDate, now);
          });
        } else if (dateFilter === "Last month") {
          const oneMonthAgo = subDays(now, 30);
          result = result.filter((p) => {
            const partyDate = new Date(p.date);
            return isAfter(partyDate, oneMonthAgo) && isBefore(partyDate, now);
          });
        }
      }
    }

    if (sortBy === "price_low") {
      result.sort((a, b) => (a.price ?? 0) - (b.price ?? 0));
    } else if (sortBy === "price_high") {
      result.sort((a, b) => (b.price ?? 0) - (a.price ?? 0));
    } else if (sortBy === "popular") {
      result.sort((a, b) => b.attendeeCount - a.attendeeCount);
    } else if (sortBy === "soonest") {
      if (browseMode === "past") {
        result.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
      } else {
        result.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
      }
    } else {
      result.sort((a, b) => new Date(b.createdAt ?? "").getTime() - new Date(a.createdAt ?? "").getTime());
    }

    return result;
  }, [parties, search, sortBy, maxPrice, themeFilter, crowdSize, dateFilter, freeOnly, browseMode]);

  return (
    <div className="min-h-screen bg-background pb-28">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-5xl mx-auto px-4 py-3">
          <div className="flex items-center gap-3 flex-wrap">
            <Link href="/" className="flex items-center gap-2 shrink-0">
              <PartyPopper className="h-6 w-6 text-primary" />
              <span className="text-lg font-bold" data-testid="text-app-name">CambuApp</span>
            </Link>
            <div className="flex items-center gap-1 shrink-0">
              <Button
                variant={browseMode === "upcoming" ? "default" : "ghost"}
                size="sm"
                onClick={() => { setBrowseMode("upcoming"); setOffset(0); setAllParties([]); setDateFilter("All dates"); }}
                data-testid="button-browse-upcoming"
              >
                Upcoming
              </Button>
              <Button
                variant={browseMode === "past" ? "default" : "ghost"}
                size="sm"
                onClick={() => { setBrowseMode("past"); setOffset(0); setAllParties([]); setDateFilter("All dates"); }}
                data-testid="button-browse-past"
              >
                Past
              </Button>
            </div>
            <div className="flex-1 min-w-[180px] relative">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                type="search"
                placeholder="Search parties..."
                value={search}
                onChange={(e) => setSearch(e.target.value)}
                className="pl-9"
                data-testid="input-search"
              />
            </div>
            <Button
              variant="outline"
              onClick={handleUseLocation}
              disabled={locating}
              data-testid="button-use-location"
            >
              {locating ? (
                <Loader2 className="h-4 w-4 animate-spin mr-1" />
              ) : (
                <MapPin className="h-4 w-4 mr-1" />
              )}
              {gpsLat !== null ? "Update location" : "Use my location"}
            </Button>
            <Button
              variant="outline"
              size="icon"
              onClick={() => navigate("/map")}
              data-testid="button-toggle-map"
            >
              <MapIcon className="h-4 w-4" />
            </Button>
            <div className="relative">
              <Button
                variant="outline"
                size="icon"
                onClick={() => setFiltersOpen(!filtersOpen)}
                data-testid="button-toggle-filters"
              >
                {filtersOpen ? <ChevronUp className="h-4 w-4" /> : <SlidersHorizontal className="h-4 w-4" />}
              </Button>
              {activeFilterCount > 0 && (
                <Badge
                  className="absolute -top-2 -right-2 h-5 min-w-[20px] flex items-center justify-center text-xs px-1"
                  data-testid="badge-filter-count"
                >
                  {activeFilterCount}
                </Badge>
              )}
            </div>
          </div>

          {gpsLat !== null && browseMode !== "past" && (
            <div className="mt-3 flex items-center gap-3 flex-wrap">
              <label className="text-sm text-muted-foreground whitespace-nowrap">
                Search radius: {searchRadius[0]} km
              </label>
              <div className="flex-1 min-w-[120px] max-w-[240px]">
                <Slider
                  value={searchRadius}
                  onValueChange={handleRadiusChange}
                  min={1}
                  max={100}
                  step={1}
                  data-testid="slider-search-radius"
                />
              </div>
            </div>
          )}

          {filtersOpen && (
            <div className="mt-3 pb-1 grid grid-cols-2 sm:grid-cols-3 gap-4">
              <div className="space-y-1.5">
                <label className="text-sm text-muted-foreground">Sort by</label>
                <Select value={sortBy} onValueChange={setSortBy}>
                  <SelectTrigger data-testid="select-sort">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="newest">Newest</SelectItem>
                    <SelectItem value="soonest">Soonest</SelectItem>
                    <SelectItem value="price_low">Price (low to high)</SelectItem>
                    <SelectItem value="price_high">Price (high to low)</SelectItem>
                    <SelectItem value="popular">Most popular</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-1.5">
                <label className="text-sm text-muted-foreground">Theme</label>
                <Select value={themeFilter} onValueChange={setThemeFilter}>
                  <SelectTrigger data-testid="select-theme">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {THEMES.map((t) => (
                      <SelectItem key={t} value={t}>
                        {t}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-1.5">
                <label className="text-sm text-muted-foreground">Max price: ${maxPrice[0]}</label>
                <Slider
                  value={maxPrice}
                  onValueChange={setMaxPrice}
                  max={500}
                  step={5}
                  data-testid="slider-max-price"
                />
              </div>

              <div className="space-y-1.5">
                <label className="text-sm text-muted-foreground">Crowd size</label>
                <Select value={crowdSize} onValueChange={setCrowdSize}>
                  <SelectTrigger data-testid="select-crowd-size">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="All">All</SelectItem>
                    <SelectItem value="Intimate (1-15)">Intimate (1-15)</SelectItem>
                    <SelectItem value="Medium (16-40)">Medium (16-40)</SelectItem>
                    <SelectItem value="Large (41+)">Large (41+)</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-1.5">
                <label className="text-sm text-muted-foreground">Date</label>
                <Select value={dateFilter} onValueChange={setDateFilter}>
                  <SelectTrigger data-testid="select-date-filter">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="All dates">All dates</SelectItem>
                    {browseMode === "past" ? (
                      <>
                        <SelectItem value="Last week">Last week</SelectItem>
                        <SelectItem value="Last 2 weeks">Last 2 weeks</SelectItem>
                        <SelectItem value="Last month">Last month</SelectItem>
                      </>
                    ) : (
                      <>
                        <SelectItem value="This week">This week</SelectItem>
                        <SelectItem value="This month">This month</SelectItem>
                        <SelectItem value="Next 3 months">Next 3 months</SelectItem>
                      </>
                    )}
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-1.5 flex flex-col justify-end">
                <Button
                  variant={freeOnly ? "default" : "outline"}
                  className="w-full toggle-elevate"
                  onClick={() => setFreeOnly(!freeOnly)}
                  data-testid="button-free-only"
                >
                  <DollarSign className="h-4 w-4 mr-1" />
                  Free only
                </Button>
              </div>
            </div>
          )}
        </div>
      </header>

      <main className="max-w-5xl mx-auto px-4 py-6">
        {isLoading && offset === 0 ? (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            {Array.from({ length: 6 }).map((_, i) => (
              <PartyCardSkeleton key={i} />
            ))}
          </div>
        ) : filteredParties.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-20 text-center" data-testid="text-empty-state">
            <PartyPopper className="h-12 w-12 text-muted-foreground mb-4" />
            <h2 className="text-xl font-semibold mb-2">{browseMode === "past" ? "No past parties found" : "No parties found in your area"}</h2>
            <p className="text-muted-foreground">Try adjusting your filters or search terms</p>
          </div>
        ) : (
          <>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
              {filteredParties.map((party) => (
                <Link key={party.id} href={`/party/${party.id}`} data-testid={`link-party-${party.id}`}>
                  <Card className="overflow-visible hover-elevate cursor-pointer group">
                    <div className="relative h-48 overflow-hidden rounded-t-md">
                      <img
                        src={party.imageUrl || "/images/party-house.png"}
                        alt={party.title}
                        className="w-full h-full object-cover transition-transform duration-300 group-hover:scale-105"
                      />
                      <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent" />
                      {browseMode === "past" && (
                        <Badge variant="outline" className="absolute top-3 left-3 text-xs bg-background/80 backdrop-blur-sm" data-testid={`badge-past-${party.id}`}>
                          Past
                        </Badge>
                      )}
                      <div className="absolute bottom-3 left-3 right-3 flex items-end justify-between gap-2">
                        <Badge variant="secondary" className="text-xs" data-testid={`badge-theme-${party.id}`}>
                          {party.theme}
                        </Badge>
                        {party.includesAlcohol && (
                          <Wine className="h-4 w-4 text-white/90" />
                        )}
                      </div>
                    </div>
                    <CardContent className="p-4 space-y-2">
                      <h3 className="font-semibold text-base leading-tight line-clamp-1" data-testid={`text-title-${party.id}`}>
                        {party.title}
                      </h3>
                      <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                        <Calendar className="h-3.5 w-3.5 shrink-0" />
                        <span className="truncate">{formatPartyDate(party.date)}</span>
                      </div>
                      <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                        <MapPin className="h-3.5 w-3.5 shrink-0" />
                        <span className="truncate">{party.locationName}, {party.city}</span>
                      </div>
                      <div className="flex items-center justify-between gap-2 pt-1 flex-wrap">
                        <span className="font-bold text-base" data-testid={`text-price-${party.id}`}>
                          {(party.price ?? 0) === 0 ? "FREE" : `$${party.price}`}
                        </span>
                        <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                          <Users className="h-3.5 w-3.5" />
                          <span>{party.attendeeCount ?? 0}/{party.maxGuests} guests</span>
                        </div>
                      </div>
                      <div className="flex items-center gap-2 pt-1 text-sm text-muted-foreground">
                        <Star className="h-3.5 w-3.5 text-primary" />
                        <span className="truncate">Hosted by {party.hostName || "Unknown Host"}</span>
                      </div>
                    </CardContent>
                  </Card>
                </Link>
              ))}
            </div>
            {hasMore && (
              <div className="flex justify-center mt-6">
                <Button
                  variant="outline"
                  onClick={handleLoadMore}
                  disabled={isLoading}
                  data-testid="button-load-more"
                >
                  {isLoading ? (
                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                  ) : null}
                  Load more
                </Button>
              </div>
            )}
          </>
        )}
      </main>
    </div>
  );
}


========================================
FILE: client/src/pages/create-party-page.tsx
========================================
import { useState, useRef } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation } from "@tanstack/react-query";
import { useLocation, Link } from "wouter";
import { z } from "zod";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { ArrowLeft, Plus, X, PartyPopper, Info, Camera, Upload } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";

const THEMES = [
  "Cyberpunk/Neon",
  "Cocktail/Lounge",
  "Pool Party",
  "Indie/Bohemian",
  "Festival/EDM",
  "House Party",
  "Dinner Party",
  "Outdoor/BBQ",
  "Game Night",
  "Karaoke",
  "Other",
];

const COUNTRY_DATA: Record<string, string[]> = {
  "USA": ["New York", "Los Angeles", "Chicago", "Miami", "Austin", "San Francisco", "Seattle", "Denver"],
  "United Kingdom": ["London", "Manchester", "Birmingham", "Edinburgh", "Bristol", "Glasgow", "Liverpool"],
  "Germany": ["Berlin", "Munich", "Hamburg", "Cologne", "Frankfurt", "Stuttgart", "Dsseldorf"],
  "Romania": ["Bucharest", "Cluj-Napoca", "Timioara", "Iai", "Constana", "Braov", "Sibiu", "Vama Veche"],
};

const createPartySchema = z.object({
  title: z.string().min(1, "Title is required"),
  theme: z.string().min(1, "Theme is required"),
  description: z.string().min(1, "Description is required"),
  date: z.string().min(1, "Date is required"),
  time: z.string().min(1, "Time is required"),
  locationName: z.string().min(1, "Location name is required"),
  country: z.string().min(1, "Country is required"),
  city: z.string().min(1, "City is required"),
  exactAddress: z.string().optional(),
  maxGuests: z.number().min(1, "Must allow at least 1 guest"),
  price: z.number().min(0, "Price cannot be negative"),
  imageUrl: z.string().optional(),
  includesAlcohol: z.boolean(),
  houseRules: z.string().optional(),
  targetGuests: z.string().optional(),
  vibe: z.string().optional(),
});

type CreatePartyForm = z.infer<typeof createPartySchema>;

export default function CreatePartyPage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [, setLocation] = useLocation();
  const [whatToBring, setWhatToBring] = useState<string[]>([]);
  const [bringItem, setBringItem] = useState("");
  const [imageUploading, setImageUploading] = useState(false);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const imageInputRef = useRef<HTMLInputElement>(null);

  async function handleImageUpload(file: File) {
    setImageUploading(true);
    try {
      const formData = new FormData();
      formData.append("image", file);
      const res = await fetch("/api/upload/party-image", {
        method: "POST",
        body: formData,
        credentials: "include",
      });
      if (!res.ok) throw new Error("Upload failed");
      const data = await res.json();
      form.setValue("imageUrl", data.url);
      setImagePreview(data.url);
      toast({ title: "Image uploaded", description: "Party image has been set." });
    } catch {
      toast({ title: "Upload failed", description: "Could not upload image. Please try again.", variant: "destructive" });
    } finally {
      setImageUploading(false);
    }
  }

  const form = useForm<CreatePartyForm>({
    resolver: zodResolver(createPartySchema),
    defaultValues: {
      title: "",
      theme: "",
      description: "",
      date: "",
      time: "",
      locationName: "",
      country: "",
      city: "",
      exactAddress: "",
      maxGuests: 20,
      price: 0,
      imageUrl: "",
      includesAlcohol: false,
      houseRules: "",
      targetGuests: "",
      vibe: "",
    },
  });

  const selectedCountry = form.watch("country");
  const cities = selectedCountry ? COUNTRY_DATA[selectedCountry] ?? [] : [];

  const createMutation = useMutation({
    mutationFn: async (values: CreatePartyForm) => {
      const dateTime = `${values.date} ${values.time}`;
      await apiRequest("POST", "/api/parties", {
        hostId: user?.id,
        title: values.title,
        theme: values.theme,
        description: values.description,
        date: dateTime,
        locationName: values.locationName,
        city: values.city,
        country: values.country,
        exactAddress: values.exactAddress || "",
        latitude: 40.7128,
        longitude: -73.9626,
        maxGuests: values.maxGuests,
        price: values.price,
        whatToBring,
        imageUrl: values.imageUrl || "/images/party-neon-techno.png",
        galleryUrls: [],
        includesAlcohol: values.includesAlcohol,
        houseRules: values.houseRules || "",
        targetGuests: values.targetGuests || "",
        vibe: values.vibe || "",
      });
    },
    onSuccess: () => {
      toast({ title: "Party created!", description: "Your party has been published." });
      setLocation("/host");
    },
    onError: (error: Error) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  function addBringItem() {
    const trimmed = bringItem.trim();
    if (trimmed && !whatToBring.includes(trimmed)) {
      setWhatToBring([...whatToBring, trimmed]);
      setBringItem("");
    }
  }

  function removeBringItem(item: string) {
    setWhatToBring(whatToBring.filter((i) => i !== item));
  }

  return (
    <div className="min-h-screen bg-background pb-28">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/browse">
            <Button variant="ghost" size="icon" data-testid="button-back">
              <ArrowLeft className="h-5 w-5" />
            </Button>
          </Link>
          <div className="flex items-center gap-2">
            <PartyPopper className="h-5 w-5 text-primary" />
            <h1 className="text-lg font-bold">Create a Party</h1>
          </div>
        </div>
      </header>

      <main className="max-w-2xl mx-auto px-4 py-6">
        <Form {...form}>
          <form onSubmit={form.handleSubmit((v) => createMutation.mutate(v))} className="space-y-6">
            <Card className="bg-primary/5 border-0" data-testid="card-host-tips">
              <CardContent className="p-4">
                <div className="flex items-start gap-2">
                  <Info className="h-4 w-4 text-muted-foreground shrink-0 mt-0.5" />
                  <div>
                    <p className="text-sm font-medium text-muted-foreground">Tips for hosting a great party:</p>
                    <ul className="text-xs text-muted-foreground mt-1 space-y-0.5 list-disc list-inside">
                      <li>Be specific about what guests should expect</li>
                      <li>Set clear house rules upfront</li>
                      <li>Respond to requests quickly</li>
                      <li>Welcome your guests warmly</li>
                    </ul>
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="text-base">Basic Info</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <FormField
                  control={form.control}
                  name="title"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Title</FormLabel>
                      <FormControl>
                        <Input placeholder="Give your party a catchy name that stands out" {...field} data-testid="input-title" />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="theme"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Theme</FormLabel>
                      <Select onValueChange={field.onChange} value={field.value}>
                        <FormControl>
                          <SelectTrigger data-testid="select-theme">
                            <SelectValue placeholder="Select a theme" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {THEMES.map((t) => (
                            <SelectItem key={t} value={t}>{t}</SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="description"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Description</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder="Paint a picture of your party. What will guests experience? What makes it special? Include the atmosphere, activities, and any highlights."
                          className="min-h-[100px]"
                          {...field}
                          data-testid="input-description"
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="text-base">Vibe & Guidelines</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <FormField
                  control={form.control}
                  name="vibe"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Vibe</FormLabel>
                      <FormControl>
                        <Input placeholder="What's the vibe? e.g., Chill, High-energy, Intimate, Wild..." {...field} data-testid="input-vibe" />
                      </FormControl>
                      <p className="text-sm text-muted-foreground">Help guests know what to expect</p>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="targetGuests"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Target Guests</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder="Who should come? e.g., Music lovers, ages 21-35, people who love dancing..."
                          {...field}
                          data-testid="input-target-guests"
                        />
                      </FormControl>
                      <p className="text-sm text-muted-foreground">Describe your ideal guest to attract the right crowd</p>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="houseRules"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>House Rules</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder="e.g., No shoes inside, BYOB, respect the neighbors, clean up after yourself..."
                          {...field}
                          data-testid="input-house-rules"
                        />
                      </FormControl>
                      <p className="text-sm text-muted-foreground">Set clear expectations so everyone has a great time</p>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="text-base">Date & Time</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="date"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Date</FormLabel>
                        <FormControl>
                          <Input type="date" {...field} data-testid="input-date" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <FormField
                    control={form.control}
                    name="time"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Time</FormLabel>
                        <FormControl>
                          <Input type="time" {...field} data-testid="input-time" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="text-base">Location</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <FormField
                  control={form.control}
                  name="locationName"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Location Name</FormLabel>
                      <FormControl>
                        <Input placeholder="e.g., My Rooftop, The Warehouse, Beach House" {...field} data-testid="input-location-name" />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="country"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Country</FormLabel>
                        <Select
                          onValueChange={(val) => {
                            field.onChange(val);
                            form.setValue("city", "");
                          }}
                          value={field.value}
                        >
                          <FormControl>
                            <SelectTrigger data-testid="select-country">
                              <SelectValue placeholder="Select country" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {Object.keys(COUNTRY_DATA).map((c) => (
                              <SelectItem key={c} value={c}>{c}</SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="city"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>City</FormLabel>
                        <Select onValueChange={field.onChange} value={field.value} disabled={!selectedCountry}>
                          <FormControl>
                            <SelectTrigger data-testid="select-city">
                              <SelectValue placeholder="Select city" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {cities.map((c) => (
                              <SelectItem key={c} value={c}>{c}</SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={form.control}
                  name="exactAddress"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Exact Address (optional)</FormLabel>
                      <FormControl>
                        <Input placeholder="Street address" {...field} data-testid="input-exact-address" />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="text-base">Details</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="maxGuests"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Max Guests</FormLabel>
                        <FormControl>
                          <Input
                            type="number"
                            min={1}
                            {...field}
                            onChange={(e) => field.onChange(parseInt(e.target.value) || 0)}
                            data-testid="input-max-guests"
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="price"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Price ($)</FormLabel>
                        <FormControl>
                          <Input
                            type="number"
                            min={0}
                            {...field}
                            onChange={(e) => field.onChange(parseInt(e.target.value) || 0)}
                            data-testid="input-price"
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <div className="space-y-2">
                  <FormLabel>What to Bring</FormLabel>
                  <div className="flex items-center gap-2">
                    <Input
                      placeholder="e.g. Drinks, Snacks"
                      value={bringItem}
                      onChange={(e) => setBringItem(e.target.value)}
                      onKeyDown={(e) => {
                        if (e.key === "Enter") {
                          e.preventDefault();
                          addBringItem();
                        }
                      }}
                      data-testid="input-what-to-bring"
                    />
                    <Button type="button" variant="outline" onClick={addBringItem} data-testid="button-add-bring-item">
                      <Plus className="h-4 w-4" />
                    </Button>
                  </div>
                  {whatToBring.length > 0 && (
                    <div className="flex flex-wrap gap-2 pt-1">
                      {whatToBring.map((item) => (
                        <Badge key={item} variant="secondary" className="gap-1" data-testid={`badge-bring-${item}`}>
                          {item}
                          <button
                            type="button"
                            onClick={() => removeBringItem(item)}
                            className="ml-1"
                            data-testid={`button-remove-bring-${item}`}
                          >
                            <X className="h-3 w-3" />
                          </button>
                        </Badge>
                      ))}
                    </div>
                  )}
                </div>

                <FormField
                  control={form.control}
                  name="includesAlcohol"
                  render={({ field }) => (
                    <FormItem className="flex items-center justify-between gap-2 rounded-md border p-3">
                      <FormLabel className="cursor-pointer">Includes Alcohol</FormLabel>
                      <FormControl>
                        <Switch
                          checked={field.value}
                          onCheckedChange={field.onChange}
                          data-testid="switch-includes-alcohol"
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <div className="space-y-2">
                  <FormLabel>Party Image (optional)</FormLabel>
                  <input
                    ref={imageInputRef}
                    type="file"
                    accept="image/*"
                    capture="environment"
                    className="hidden"
                    data-testid="input-party-image-file"
                    onChange={(e) => {
                      const file = e.target.files?.[0];
                      if (file) handleImageUpload(file);
                    }}
                  />
                  {imagePreview || form.getValues("imageUrl") ? (
                    <div className="relative rounded-md overflow-visible">
                      <img
                        src={imagePreview || form.getValues("imageUrl")}
                        alt="Party preview"
                        className="w-full h-48 object-cover rounded-md"
                        data-testid="img-party-preview"
                      />
                      <div className="flex items-center gap-2 mt-2">
                        <Button
                          type="button"
                          variant="outline"
                          onClick={() => imageInputRef.current?.click()}
                          disabled={imageUploading}
                          data-testid="button-change-party-image"
                        >
                          <Camera className="h-4 w-4 mr-2" />
                          {imageUploading ? "Uploading..." : "Change Image"}
                        </Button>
                        <Button
                          type="button"
                          variant="ghost"
                          onClick={() => {
                            form.setValue("imageUrl", "");
                            setImagePreview(null);
                          }}
                          data-testid="button-remove-party-image"
                        >
                          <X className="h-4 w-4 mr-2" />
                          Remove
                        </Button>
                      </div>
                    </div>
                  ) : (
                    <Button
                      type="button"
                      variant="outline"
                      className="w-full h-32 border-dashed flex flex-col gap-2"
                      onClick={() => imageInputRef.current?.click()}
                      disabled={imageUploading}
                      data-testid="button-upload-party-image"
                    >
                      {imageUploading ? (
                        <span className="text-sm text-muted-foreground">Uploading...</span>
                      ) : (
                        <>
                          <Upload className="h-6 w-6 text-muted-foreground" />
                          <span className="text-sm text-muted-foreground">Upload a photo or take one</span>
                        </>
                      )}
                    </Button>
                  )}
                </div>
              </CardContent>
            </Card>

            <Button
              type="submit"
              size="lg"
              className="w-full"
              disabled={createMutation.isPending}
              data-testid="button-publish-party"
            >
              {createMutation.isPending ? "Publishing..." : "Publish Party"}
            </Button>
          </form>
        </Form>
      </main>
    </div>
  );
}


========================================
FILE: client/src/pages/edit-party-page.tsx
========================================
import { useState, useRef, useEffect } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useParams, useLocation } from "wouter";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Skeleton } from "@/components/ui/skeleton";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { ArrowLeft, Save, Loader2, Upload, Camera } from "lucide-react";
import type { Party } from "@shared/schema";

const THEME_OPTIONS = [
  { value: "house-party", label: "House Party" },
  { value: "outdoor", label: "Outdoor" },
  { value: "pool-party", label: "Pool Party" },
  { value: "rooftop", label: "Rooftop" },
  { value: "club", label: "Club" },
  { value: "beach", label: "Beach" },
  { value: "bbq", label: "BBQ" },
  { value: "themed", label: "Themed" },
  { value: "other", label: "Other" },
];

export default function EditPartyPage() {
  const { id } = useParams<{ id: string }>();
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const { user } = useAuth();
  const imageInputRef = useRef<HTMLInputElement>(null);

  const [title, setTitle] = useState("");
  const [theme, setTheme] = useState("");
  const [description, setDescription] = useState("");
  const [date, setDate] = useState("");
  const [locationName, setLocationName] = useState("");
  const [city, setCity] = useState("");
  const [country, setCountry] = useState("");
  const [maxGuests, setMaxGuests] = useState(0);
  const [price, setPrice] = useState(0);
  const [houseRules, setHouseRules] = useState("");
  const [targetGuests, setTargetGuests] = useState("");
  const [vibe, setVibe] = useState("");
  const [whatToBring, setWhatToBring] = useState<string[]>([]);
  const [includesAlcohol, setIncludesAlcohol] = useState(false);
  const [imageUrl, setImageUrl] = useState("");
  const [imageUploading, setImageUploading] = useState(false);
  const [initialized, setInitialized] = useState(false);

  const { data: party, isLoading } = useQuery<Party>({
    queryKey: ["/api/parties", id],
    queryFn: async () => {
      const res = await apiRequest("GET", `/api/parties/${id}`);
      return res.json();
    },
    enabled: !!id,
  });

  useEffect(() => {
    if (party && !initialized) {
      setTitle(party.title || "");
      setTheme(party.theme || "");
      setDescription(party.description || "");
      if (party.date) {
        const d = new Date(party.date);
        if (!isNaN(d.getTime())) {
          const local = new Date(d.getTime() - d.getTimezoneOffset() * 60000);
          setDate(local.toISOString().slice(0, 16));
        } else {
          setDate(party.date);
        }
      }
      setLocationName(party.locationName || "");
      setCity(party.city || "");
      setCountry(party.country || "");
      setMaxGuests(party.maxGuests || 0);
      setPrice(party.price || 0);
      setHouseRules(party.houseRules || "");
      setTargetGuests(party.targetGuests || "");
      setVibe(party.vibe || "");
      setWhatToBring(party.whatToBring || []);
      setIncludesAlcohol(party.includesAlcohol || false);
      setImageUrl(party.imageUrl || "");
      setInitialized(true);
    }
  }, [party, initialized]);

  useEffect(() => {
    if (party && user && party.hostId !== user.id) {
      toast({ title: "Not authorized", description: "You are not the host of this party.", variant: "destructive" });
      setLocation("/browse");
    }
  }, [party, user, setLocation, toast]);

  async function handleImageUpload(file: File) {
    setImageUploading(true);
    try {
      const formData = new FormData();
      formData.append("image", file);
      const res = await fetch("/api/upload/party-image", {
        method: "POST",
        body: formData,
        credentials: "include",
      });
      if (!res.ok) throw new Error("Upload failed");
      const data = await res.json();
      setImageUrl(data.url);
      toast({ title: "Image uploaded", description: "Party image has been updated." });
    } catch {
      toast({ title: "Upload failed", description: "Could not upload image. Please try again.", variant: "destructive" });
    } finally {
      setImageUploading(false);
    }
  }

  const updateMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("PATCH", `/api/parties/${id}`, {
        title,
        theme,
        description,
        date,
        locationName,
        city,
        country,
        maxGuests,
        price,
        houseRules,
        targetGuests,
        vibe,
        whatToBring,
        includesAlcohol,
        imageUrl,
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/parties", id] });
      queryClient.invalidateQueries({ queryKey: ["/api/parties"] });
      toast({ title: "Party updated!", description: "Your changes have been saved." });
      setLocation(`/party/${id}`);
    },
    onError: (error: Error) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    updateMutation.mutate();
  }

  if (isLoading) {
    return (
      <div className="min-h-screen bg-background pb-28">
        <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
          <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
            <Skeleton className="h-9 w-9 rounded-md" />
            <Skeleton className="h-6 w-32" />
          </div>
        </header>
        <main className="max-w-2xl mx-auto px-4 py-6 space-y-6">
          <Skeleton className="h-48 w-full rounded-md" />
          <Skeleton className="h-10 w-full rounded-md" />
          <Skeleton className="h-10 w-full rounded-md" />
          <Skeleton className="h-32 w-full rounded-md" />
        </main>
      </div>
    );
  }

  if (!party) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <p className="text-muted-foreground" data-testid="text-not-found">Party not found</p>
      </div>
    );
  }

  if (user && party.hostId !== user.id) {
    return null;
  }

  return (
    <div className="min-h-screen bg-background pb-28">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Button
            variant="ghost"
            size="icon"
            onClick={() => setLocation(`/party/${id}`)}
            data-testid="button-back"
          >
            <ArrowLeft className="h-5 w-5" />
          </Button>
          <h1 className="text-lg font-bold">Edit Party</h1>
        </div>
      </header>

      <main className="max-w-2xl mx-auto px-4 py-6">
        <form onSubmit={handleSubmit} className="space-y-6">
          <Card>
            <CardContent className="p-4 space-y-4">
              <div className="space-y-2">
                <Label htmlFor="title">Title</Label>
                <Input
                  id="title"
                  value={title}
                  onChange={(e) => setTitle(e.target.value.slice(0, 100))}
                  maxLength={100}
                  placeholder="Party title"
                  data-testid="input-title"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="theme">Theme</Label>
                <Select value={theme} onValueChange={setTheme}>
                  <SelectTrigger data-testid="input-theme">
                    <SelectValue placeholder="Select a theme" />
                  </SelectTrigger>
                  <SelectContent>
                    {THEME_OPTIONS.map((t) => (
                      <SelectItem key={t.value} value={t.value}>{t.label}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-2">
                <Label htmlFor="description">Description</Label>
                <Textarea
                  id="description"
                  value={description}
                  onChange={(e) => setDescription(e.target.value.slice(0, 2000))}
                  maxLength={2000}
                  placeholder="Describe your party"
                  className="min-h-[100px]"
                  data-testid="textarea-description"
                />
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-4 space-y-4">
              <div className="space-y-2">
                <Label htmlFor="date">Date & Time</Label>
                <Input
                  id="date"
                  type="datetime-local"
                  value={date}
                  onChange={(e) => setDate(e.target.value)}
                  data-testid="input-date"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="locationName">Location Name</Label>
                <Input
                  id="locationName"
                  value={locationName}
                  onChange={(e) => setLocationName(e.target.value)}
                  placeholder="e.g., My Rooftop"
                  data-testid="input-location"
                />
              </div>

              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="city">City</Label>
                  <Input
                    id="city"
                    value={city}
                    onChange={(e) => setCity(e.target.value)}
                    placeholder="City"
                    data-testid="input-city"
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="country">Country</Label>
                  <Input
                    id="country"
                    value={country}
                    onChange={(e) => setCountry(e.target.value)}
                    placeholder="Country"
                    data-testid="input-country"
                  />
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-4 space-y-4">
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="maxGuests">Max Guests</Label>
                  <Input
                    id="maxGuests"
                    type="number"
                    min={1}
                    value={maxGuests}
                    onChange={(e) => setMaxGuests(parseInt(e.target.value) || 0)}
                    data-testid="input-max-guests"
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="price">Price ($)</Label>
                  <Input
                    id="price"
                    type="number"
                    min={0}
                    value={price}
                    onChange={(e) => setPrice(parseInt(e.target.value) || 0)}
                    data-testid="input-price"
                  />
                  <p className="text-xs text-muted-foreground">0 = free</p>
                </div>
              </div>

              <div className="space-y-2">
                <Label htmlFor="houseRules">House Rules</Label>
                <Textarea
                  id="houseRules"
                  value={houseRules}
                  onChange={(e) => setHouseRules(e.target.value.slice(0, 1000))}
                  maxLength={1000}
                  placeholder="Set your house rules"
                  data-testid="textarea-house-rules"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="targetGuests">Target Guests</Label>
                <Input
                  id="targetGuests"
                  value={targetGuests}
                  onChange={(e) => setTargetGuests(e.target.value)}
                  placeholder="Who should come?"
                  data-testid="input-target-guests"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="vibe">Vibe</Label>
                <Input
                  id="vibe"
                  value={vibe}
                  onChange={(e) => setVibe(e.target.value)}
                  placeholder="What's the vibe?"
                  data-testid="input-vibe"
                />
              </div>

              <div className="flex items-center gap-2">
                <Checkbox
                  id="includesAlcohol"
                  checked={includesAlcohol}
                  onCheckedChange={(checked) => setIncludesAlcohol(checked === true)}
                  data-testid="checkbox-alcohol"
                />
                <Label htmlFor="includesAlcohol" className="cursor-pointer">Includes Alcohol</Label>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-4 space-y-4">
              <Label>Party Image</Label>
              <input
                ref={imageInputRef}
                type="file"
                accept="image/*"
                className="hidden"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) handleImageUpload(file);
                }}
              />
              {imageUrl && (
                <img
                  src={imageUrl}
                  alt="Party preview"
                  className="w-full h-48 object-cover rounded-md"
                  data-testid="img-party-preview"
                />
              )}
              <div className="flex items-center gap-2 flex-wrap">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => imageInputRef.current?.click()}
                  disabled={imageUploading}
                  data-testid="button-upload-image"
                >
                  {imageUploading ? (
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  ) : (
                    <Upload className="h-4 w-4 mr-2" />
                  )}
                  {imageUploading ? "Uploading..." : "Upload Image"}
                </Button>
              </div>
            </CardContent>
          </Card>

          <Button
            type="submit"
            className="w-full"
            disabled={updateMutation.isPending}
            data-testid="button-save"
          >
            {updateMutation.isPending ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <Save className="h-4 w-4 mr-2" />
            )}
            {updateMutation.isPending ? "Saving..." : "Save Changes"}
          </Button>
        </form>
      </main>
    </div>
  );
}


========================================
FILE: client/src/pages/host-page.tsx
========================================
import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Link } from "wouter";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Skeleton } from "@/components/ui/skeleton";
import { Plus, Calendar, Users, MapPin, Check, X, MessageSquare, Gift, ChevronDown, ChevronUp, PartyPopper } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { format } from "date-fns";
import type { Party } from "@shared/schema";

function formatPartyDate(dateStr: string) {
  try {
    return format(new Date(dateStr), "MMM d, yyyy 'at' h:mm a");
  } catch {
    return dateStr;
  }
}

interface RequestWithUser {
  id: string;
  partyId: string;
  userId: string;
  message: string;
  pledgedItems: string;
  status: string;
  user?: {
    id: string;
    fullName: string;
    avatar: string;
    nickname: string;
  };
}

function PartyRequestsList({ partyId }: { partyId: string }) {
  const { toast } = useToast();

  const { data: requests, isLoading } = useQuery<RequestWithUser[]>({
    queryKey: ["/api/parties", partyId, "requests"],
  });

  const updateStatusMutation = useMutation({
    mutationFn: async ({ requestId, status }: { requestId: string; status: string }) => {
      await apiRequest("PATCH", `/api/requests/${requestId}/status`, { status });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/parties", partyId, "requests"] });
      queryClient.invalidateQueries({ queryKey: ["/api/parties/host/mine"] });
      toast({ title: "Request updated" });
    },
    onError: (error: Error) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  const pendingRequests = requests?.filter((r) => r.status === "pending") ?? [];

  if (isLoading) {
    return (
      <div className="space-y-3 pt-3">
        {Array.from({ length: 2 }).map((_, i) => (
          <div key={i} className="flex items-center gap-3">
            <Skeleton className="h-10 w-10 rounded-full" />
            <div className="flex-1 space-y-1">
              <Skeleton className="h-4 w-24" />
              <Skeleton className="h-3 w-40" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  if (pendingRequests.length === 0) {
    return (
      <p className="text-sm text-muted-foreground pt-3" data-testid="text-no-pending-requests">
        No pending requests
      </p>
    );
  }

  return (
    <div className="space-y-3 pt-3">
      {pendingRequests.map((req) => (
        <div
          key={req.id}
          className="flex items-start gap-3 rounded-md border p-3"
          data-testid={`card-request-${req.id}`}
        >
          <Avatar>
            <AvatarImage src={req.user?.avatar} />
            <AvatarFallback>{(req.user?.fullName || "?")[0]}</AvatarFallback>
          </Avatar>
          <div className="flex-1 min-w-0 space-y-1">
            <p className="font-medium text-sm" data-testid={`text-requester-name-${req.id}`}>
              {req.user?.fullName || req.user?.nickname || "Unknown"}
            </p>
            {req.message && (
              <div className="flex items-start gap-1.5 text-sm text-muted-foreground">
                <MessageSquare className="h-3.5 w-3.5 shrink-0 mt-0.5" />
                <span className="line-clamp-2">{req.message}</span>
              </div>
            )}
            {req.pledgedItems && (
              <div className="flex items-start gap-1.5 text-sm text-muted-foreground">
                <Gift className="h-3.5 w-3.5 shrink-0 mt-0.5" />
                <span>{req.pledgedItems}</span>
              </div>
            )}
          </div>
          <div className="flex items-center gap-1 shrink-0">
            <Button
              size="icon"
              variant="ghost"
              onClick={() => updateStatusMutation.mutate({ requestId: req.id, status: "accepted" })}
              disabled={updateStatusMutation.isPending}
              data-testid={`button-accept-request-${req.id}`}
            >
              <Check className="h-4 w-4 text-green-500" />
            </Button>
            <Button
              size="icon"
              variant="ghost"
              onClick={() => updateStatusMutation.mutate({ requestId: req.id, status: "declined" })}
              disabled={updateStatusMutation.isPending}
              data-testid={`button-decline-request-${req.id}`}
            >
              <X className="h-4 w-4 text-red-500" />
            </Button>
          </div>
        </div>
      ))}
    </div>
  );
}

function HostedPartyCard({ party }: { party: Party & { attendeeCount?: number } }) {
  const [expanded, setExpanded] = useState(false);
  const { toast } = useToast();

  const cancelMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("PATCH", `/api/parties/${party.id}`, { status: "cancelled" });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/parties/host/mine"] });
      toast({ title: "Party cancelled" });
    },
    onError: (error: Error) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  const handleCancel = () => {
    if (window.confirm("Are you sure you want to cancel this party? This cannot be undone.")) {
      cancelMutation.mutate();
    }
  };

  return (
    <Card className="overflow-visible" data-testid={`card-hosted-party-${party.id}`}>
      <Link href={`/party/${party.id}`}>
        <div className="flex gap-4 p-4 cursor-pointer hover-elevate rounded-t-md">
          <div className="w-24 h-24 rounded-md overflow-hidden shrink-0">
            <img
              src={party.imageUrl || "/images/party-house.png"}
              alt={party.title}
              className="w-full h-full object-cover"
            />
          </div>
          <div className="flex-1 min-w-0 space-y-1">
            <h3 className="font-semibold leading-tight line-clamp-1" data-testid={`text-party-title-${party.id}`}>
              {party.title}
            </h3>
            <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
              <Calendar className="h-3.5 w-3.5 shrink-0" />
              <span className="truncate">{formatPartyDate(party.date)}</span>
            </div>
            <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
              <MapPin className="h-3.5 w-3.5 shrink-0" />
              <span className="truncate">{party.locationName}, {party.city}</span>
            </div>
            <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
              <Users className="h-3.5 w-3.5 shrink-0" />
              <span>{party.attendeeCount ?? 0}/{party.maxGuests} guests</span>
            </div>
          </div>
        </div>
      </Link>
      {(party.status === "upcoming" || party.status === "ongoing") && (
        <div className="px-4 pb-2">
          <Button
            variant="outline"
            className="w-full text-destructive border-destructive/50"
            onClick={handleCancel}
            disabled={cancelMutation.isPending}
            data-testid={`button-cancel-party-${party.id}`}
          >
            {cancelMutation.isPending ? "Cancelling..." : "Cancel Party"}
          </Button>
        </div>
      )}
      <div className="border-t px-4 py-2">
        <Button
          variant="ghost"
          className="w-full justify-between"
          onClick={() => setExpanded(!expanded)}
          data-testid={`button-toggle-requests-${party.id}`}
        >
          <span className="text-sm">Join Requests</span>
          {expanded ? <ChevronUp className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />}
        </Button>
        {expanded && (
          <div className="pb-3">
            <PartyRequestsList partyId={party.id} />
          </div>
        )}
      </div>
    </Card>
  );
}

function HostPageSkeleton() {
  return (
    <div className="space-y-4">
      {Array.from({ length: 3 }).map((_, i) => (
        <Card key={i} className="overflow-visible">
          <div className="flex gap-4 p-4">
            <Skeleton className="w-24 h-24 rounded-md" />
            <div className="flex-1 space-y-2">
              <Skeleton className="h-5 w-3/4" />
              <Skeleton className="h-4 w-1/2" />
              <Skeleton className="h-4 w-2/3" />
            </div>
          </div>
        </Card>
      ))}
    </div>
  );
}

export default function HostPage() {
  const { user } = useAuth();

  const { data: parties, isLoading } = useQuery<(Party & { attendeeCount?: number })[]>({
    queryKey: ["/api/parties/host/mine"],
  });

  return (
    <div className="min-h-screen bg-background pb-28">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center justify-between gap-3 flex-wrap">
          <h1 className="text-lg font-bold">My Hosted Parties</h1>
          <Link href="/create-party">
            <Button data-testid="button-create-party">
              <Plus className="h-4 w-4 mr-2" />
              Create Party
            </Button>
          </Link>
        </div>
      </header>

      <main className="max-w-2xl mx-auto px-4 py-6 space-y-4">
        {isLoading ? (
          <HostPageSkeleton />
        ) : !parties || parties.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-20 text-center" data-testid="text-empty-state">
            <PartyPopper className="h-12 w-12 text-muted-foreground mb-4" />
            <h2 className="text-xl font-semibold mb-2">No parties yet</h2>
            <p className="text-muted-foreground mb-6">Create your first party and start hosting!</p>
            <Link href="/create-party">
              <Button data-testid="button-create-party-empty">
                <Plus className="h-4 w-4 mr-2" />
                Create a Party
              </Button>
            </Link>
          </div>
        ) : (
          parties.map((party) => (
            <HostedPartyCard key={party.id} party={party} />
          ))
        )}
      </main>
    </div>
  );
}


========================================
FILE: client/src/pages/attending-page.tsx
========================================
import { useQuery } from "@tanstack/react-query";
import { Link } from "wouter";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Calendar, MapPin, Users, PartyPopper, DollarSign, ArrowLeft } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { format } from "date-fns";
import type { Party } from "@shared/schema";

interface AttendingParty extends Party {
  hostName?: string;
  attendeeCount?: number;
}

function formatPartyDate(dateStr: string) {
  try {
    return format(new Date(dateStr), "MMM d, yyyy 'at' h:mm a");
  } catch {
    return dateStr;
  }
}

function AttendingCardSkeleton() {
  return (
    <Card className="overflow-visible">
      <div className="flex gap-4 p-4">
        <Skeleton className="w-24 h-24 rounded-md" />
        <div className="flex-1 space-y-2">
          <Skeleton className="h-5 w-3/4" />
          <Skeleton className="h-4 w-1/2" />
          <Skeleton className="h-4 w-2/3" />
          <Skeleton className="h-4 w-1/3" />
        </div>
      </div>
    </Card>
  );
}

export default function AttendingPage() {
  const { user } = useAuth();

  const { data: parties, isLoading } = useQuery<AttendingParty[]>({
    queryKey: ["/api/parties/attending/mine"],
  });

  return (
    <div className="min-h-screen bg-background pb-28">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/browse">
            <Button variant="ghost" size="icon" data-testid="button-back">
              <ArrowLeft className="h-5 w-5" />
            </Button>
          </Link>
          <h1 className="text-lg font-bold">Attending</h1>
        </div>
      </header>

      <main className="max-w-2xl mx-auto px-4 py-6 space-y-4">
        {isLoading ? (
          <div className="space-y-4">
            {Array.from({ length: 3 }).map((_, i) => (
              <AttendingCardSkeleton key={i} />
            ))}
          </div>
        ) : !parties || parties.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-20 text-center" data-testid="text-empty-state">
            <PartyPopper className="h-12 w-12 text-muted-foreground mb-4" />
            <h2 className="text-xl font-semibold mb-2">No parties yet</h2>
            <p className="text-muted-foreground mb-6">Browse parties and request to join!</p>
            <Link href="/browse">
              <Button data-testid="button-browse-parties">Browse Parties</Button>
            </Link>
          </div>
        ) : (
          parties.map((party) => (
            <Link key={party.id} href={`/party/${party.id}`} data-testid={`link-party-${party.id}`}>
              <Card className="overflow-visible hover-elevate cursor-pointer">
                <div className="flex gap-4 p-4">
                  <div className="w-24 h-24 rounded-md overflow-hidden shrink-0">
                    <img
                      src={party.imageUrl || "/images/party-house.png"}
                      alt={party.title}
                      className="w-full h-full object-cover"
                    />
                  </div>
                  <div className="flex-1 min-w-0 space-y-1">
                    <h3 className="font-semibold leading-tight line-clamp-1" data-testid={`text-party-title-${party.id}`}>
                      {party.title}
                    </h3>
                    <Badge variant="secondary" className="text-xs" data-testid={`badge-theme-${party.id}`}>
                      {party.theme}
                    </Badge>
                    <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                      <Calendar className="h-3.5 w-3.5 shrink-0" />
                      <span className="truncate">{formatPartyDate(party.date)}</span>
                    </div>
                    <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                      <MapPin className="h-3.5 w-3.5 shrink-0" />
                      <span className="truncate">{party.locationName}, {party.city}</span>
                    </div>
                    <div className="flex items-center gap-3 flex-wrap">
                      <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                        <Users className="h-3.5 w-3.5" />
                        <span>{party.attendeeCount ?? 0}/{party.maxGuests}</span>
                      </div>
                      <span className="text-sm font-medium" data-testid={`text-price-${party.id}`}>
                        {(party.price ?? 0) === 0 ? "FREE" : `$${party.price}`}
                      </span>
                    </div>
                    {party.hostName && (
                      <p className="text-xs text-muted-foreground">Hosted by {party.hostName}</p>
                    )}
                  </div>
                </div>
              </Card>
            </Link>
          ))
        )}
      </main>
    </div>
  );
}


========================================
FILE: client/src/pages/party-detail-page.tsx
========================================
import { useState, useRef, useEffect } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useParams, useLocation } from "wouter";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { Input } from "@/components/ui/input";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Skeleton } from "@/components/ui/skeleton";
import { ArrowLeft, MapPin, Calendar, Users, DollarSign, Wine, ShieldCheck, Star, Clock, Send, PartyPopper, CheckCircle2, Info, Loader2, Upload, Trash2, QrCode, MessageCircle, Sparkles, Pencil } from "lucide-react";
import { format } from "date-fns";
import QRCode from "qrcode";
import type { Party, PartyRequest, User } from "@shared/schema";

interface EnrichedParty extends Party {
  hostName: string;
  hostAvatar: string;
  hostVerified: boolean;
  attendeeCount: number;
  hostRating?: number;
}

interface AttendeeInfo {
  id: string;
  username: string;
  fullName: string;
  avatar: string;
}

function formatPartyDate(dateStr: string) {
  try {
    return format(new Date(dateStr), "EEEE, MMM d, yyyy 'at' h:mm a");
  } catch {
    return dateStr;
  }
}

function DetailSkeleton() {
  return (
    <div className="min-h-screen bg-background">
      <Skeleton className="w-full h-64" />
      <div className="max-w-3xl mx-auto px-4 py-6 space-y-6">
        <Skeleton className="h-8 w-2/3" />
        <Skeleton className="h-5 w-1/2" />
        <Skeleton className="h-20 w-full" />
        <Skeleton className="h-40 w-full" />
      </div>
    </div>
  );
}

export default function PartyDetailPage() {
  const params = useParams<{ id: string }>();
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const { user, isAuthenticated } = useAuth();
  const [message, setMessage] = useState("");
  const [pledgedItems, setPledgedItems] = useState("");
  const [verifying, setVerifying] = useState(false);
  const [verificationResult, setVerificationResult] = useState<string | null>(null);
  const [chatMessage, setChatMessage] = useState("");
  const [qrCodeUrl, setQrCodeUrl] = useState<string | null>(null);
  const [qrInput, setQrInput] = useState("");
  const [aiSuggestions, setAiSuggestions] = useState<string | null>(null);
  const [aiLoading, setAiLoading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const chatEndRef = useRef<HTMLDivElement>(null);

  const { data: party, isLoading: partyLoading } = useQuery<EnrichedParty>({
    queryKey: ["/api/parties", params.id],
  });

  const { data: attendees } = useQuery<AttendeeInfo[]>({
    queryKey: ["/api/parties", params.id, "attendees"],
    enabled: !!params.id,
  });

  const { data: myRequests } = useQuery<PartyRequest[]>({
    queryKey: ["/api/requests/mine"],
    enabled: isAuthenticated,
  });

  const { data: hostStats } = useQuery<{
    partiesAttended: number;
    partiesHosted: number;
    reviewCount: number;
    profileCompleteness: number;
  }>({
    queryKey: ["/api/users", party?.hostId, "stats"],
    enabled: !!party?.hostId,
  });

  const existingRequest = myRequests?.find((r) => r.partyId === params.id);
  const isHost = user?.id === party?.hostId;
  const isAttending = attendees?.some((a) => a.id === user?.id);

  const { data: messages = [] } = useQuery<any[]>({
    queryKey: ["/api/parties", params.id, "messages"],
    enabled: !!(isHost || isAttending) && !!params.id,
    refetchInterval: 5000,
  });

  const { data: qrData } = useQuery<{ qrToken: string }>({
    queryKey: ["/api/parties", params.id, "qr"],
    enabled: !!isHost && !!params.id,
  });

  const joinMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/parties/${params.id}/requests`, {
        message,
        pledgedItems,
      });
    },
    onSuccess: () => {
      toast({ title: "Request sent!", description: "The host will review your request." });
      setMessage("");
      setPledgedItems("");
      queryClient.invalidateQueries({ queryKey: ["/api/requests/mine"] });
    },
    onError: (error: Error) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  const sendMessageMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/parties/${params.id}/messages`, {
        message: chatMessage,
      });
    },
    onSuccess: () => {
      setChatMessage("");
      queryClient.invalidateQueries({ queryKey: ["/api/parties", params.id, "messages"] });
    },
    onError: (error: Error) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  const deleteMessageMutation = useMutation({
    mutationFn: async (messageId: string) => {
      await apiRequest("DELETE", `/api/messages/${messageId}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/parties", params.id, "messages"] });
    },
    onError: (error: Error) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  const checkinMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/parties/${params.id}/checkin`, {
        qrToken: qrInput,
      });
    },
    onSuccess: () => {
      toast({ title: "Checked in!", description: "You have been checked in successfully." });
      setQrInput("");
      queryClient.invalidateQueries({ queryKey: ["/api/parties", params.id, "attendees"] });
    },
    onError: (error: Error) => {
      toast({ title: "Check-in failed", description: error.message, variant: "destructive" });
    },
  });

  useEffect(() => {
    if (qrData?.qrToken) {
      QRCode.toDataURL(qrData.qrToken).then((url) => setQrCodeUrl(url));
    }
  }, [qrData?.qrToken]);

  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleVerifyAge = async (file: File) => {
    setVerifying(true);
    setVerificationResult(null);
    try {
      const base64 = await new Promise<string>((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result as string);
        reader.onerror = () => reject(new Error("Failed to read file"));
        reader.readAsDataURL(file);
      });
      const res = await apiRequest("POST", "/api/verify-age", { imageBase64: base64 });
      const data = await res.json();
      setVerificationResult(data.message || "Verification complete");
      toast({ title: "Verification complete", description: data.message });
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
    } catch (error: any) {
      toast({ title: "Verification failed", description: error.message, variant: "destructive" });
    } finally {
      setVerifying(false);
    }
  };

  if (partyLoading) {
    return <DetailSkeleton />;
  }

  if (!party) {
    return (
      <div className="min-h-screen bg-background flex flex-col items-center justify-center">
        <PartyPopper className="h-12 w-12 text-muted-foreground mb-4" />
        <h2 className="text-xl font-semibold mb-2">Party not found</h2>
        <Button variant="outline" onClick={() => setLocation("/browse")} data-testid="button-back-browse">
          Back to Browse
        </Button>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background pb-28">
      <div className="relative h-64 sm:h-80 overflow-hidden">
        <img
          src={party.imageUrl || "/images/party-house.png"}
          alt={party.title}
          className="w-full h-full object-cover"
        />
        <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-black/20" />
        <div className="absolute top-4 left-4 right-4 flex items-center justify-between gap-2">
          <Button
            variant="outline"
            size="icon"
            onClick={() => setLocation("/browse")}
            className="bg-black/30 backdrop-blur border-white/20 text-white"
            data-testid="button-back"
          >
            <ArrowLeft className="h-4 w-4" />
          </Button>
          {isHost && (
            <Button
              variant="outline"
              size="icon"
              onClick={() => setLocation(`/edit-party/${params.id}`)}
              className="bg-black/30 backdrop-blur border-white/20 text-white"
              data-testid="button-edit-party"
            >
              <Pencil className="h-4 w-4" />
            </Button>
          )}
        </div>
        <div className="absolute bottom-4 left-4 right-4">
          <Badge variant="secondary" className="mb-2" data-testid="badge-party-theme">
            {party.theme}
          </Badge>
          <h1 className="text-2xl sm:text-3xl font-bold text-white mb-1" data-testid="text-party-title">
            {party.title}
          </h1>
          <div className="flex items-center gap-2 text-white/80 text-sm">
            <Calendar className="h-4 w-4" />
            <span>{formatPartyDate(party.date)}</span>
          </div>
        </div>
      </div>

      <div className="max-w-3xl mx-auto px-4 py-6 space-y-6">
        <Card>
          <CardContent className="p-4 space-y-4">
            <div className="flex items-center gap-3">
              <Avatar>
                <AvatarImage src={party.hostAvatar} />
                <AvatarFallback>{party.hostName?.charAt(0)?.toUpperCase() || "H"}</AvatarFallback>
              </Avatar>
              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-1.5 flex-wrap">
                  <span className="font-semibold" data-testid="text-host-name">{party.hostName}</span>
                  {party.hostVerified && (
                    <ShieldCheck className="h-4 w-4 text-primary shrink-0" />
                  )}
                </div>
                {(party.hostRating ?? 0) > 0 && (
                  <div className="flex items-center gap-1 text-sm text-muted-foreground">
                    <Star className="h-3.5 w-3.5 text-primary" />
                    <span>{party.hostRating?.toFixed(1)}</span>
                  </div>
                )}
                {hostStats && (
                  <div className="flex items-center gap-2 flex-wrap mt-1">
                    <Badge variant="secondary" data-testid="badge-host-parties">
                      <PartyPopper className="h-3 w-3 mr-1" />
                      {hostStats.partiesHosted} parties hosted
                    </Badge>
                    <Badge variant="secondary" data-testid="badge-host-reviews">
                      <Star className="h-3 w-3 mr-1" />
                      {hostStats.reviewCount} reviews
                    </Badge>
                    {party.hostVerified && (
                      <Badge variant="secondary" data-testid="badge-host-verified">
                        <ShieldCheck className="h-3 w-3 mr-1" />
                        Verified
                      </Badge>
                    )}
                  </div>
                )}
              </div>
            </div>

            <div className="grid grid-cols-2 gap-3">
              <div className="flex items-center gap-2 text-sm">
                <MapPin className="h-4 w-4 text-muted-foreground shrink-0" />
                <span className="truncate" data-testid="text-location">{party.locationName}, {party.city}</span>
              </div>
              <div className="flex items-center gap-2 text-sm">
                <DollarSign className="h-4 w-4 text-muted-foreground shrink-0" />
                <span className="font-semibold" data-testid="text-price">
                  {(party.price ?? 0) === 0 ? "FREE" : `$${party.price}`}
                </span>
              </div>
              <div className="flex items-center gap-2 text-sm">
                <Users className="h-4 w-4 text-muted-foreground shrink-0" />
                <span data-testid="text-guests">{party.attendeeCount}/{party.maxGuests} guests</span>
              </div>
              {party.includesAlcohol && (
                <div className="flex items-center gap-2 text-sm">
                  <Wine className="h-4 w-4 text-muted-foreground shrink-0" />
                  <span>Includes alcohol</span>
                </div>
              )}
            </div>
          </CardContent>
        </Card>

        {party.description && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-2">About this party</h2>
              <p className="text-sm text-muted-foreground whitespace-pre-wrap" data-testid="text-description">
                {party.description}
              </p>
            </CardContent>
          </Card>
        )}

        {party.houseRules && party.houseRules.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-2">House Rules</h2>
              <p className="text-sm text-muted-foreground whitespace-pre-wrap" data-testid="text-house-rules">
                {party.houseRules}
              </p>
            </CardContent>
          </Card>
        )}

        {party.vibe && party.vibe.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-2">Vibe</h2>
              <p className="text-sm text-muted-foreground" data-testid="text-vibe">
                {party.vibe}
              </p>
            </CardContent>
          </Card>
        )}

        {party.targetGuests && party.targetGuests.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-2">Who Should Come</h2>
              <p className="text-sm text-muted-foreground" data-testid="text-target-guests">
                {party.targetGuests}
              </p>
            </CardContent>
          </Card>
        )}

        {party.whatToBring && party.whatToBring.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-2">What to bring</h2>
              <div className="flex flex-wrap gap-2">
                {party.whatToBring.map((item, i) => (
                  <Badge key={i} variant="secondary" data-testid={`badge-bring-${i}`}>
                    {item}
                  </Badge>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {isAuthenticated && (isHost || isAttending) && (
          <Card>
            <CardContent className="p-4 space-y-3">
              <div className="flex items-center justify-between gap-2 flex-wrap">
                <h2 className="font-semibold flex items-center gap-2">
                  <Sparkles className="h-4 w-4" />
                  AI Party Assistant
                </h2>
                <Button
                  variant="outline"
                  size="sm"
                  disabled={aiLoading}
                  data-testid="button-ai-suggestions"
                  onClick={async () => {
                    setAiLoading(true);
                    setAiSuggestions(null);
                    try {
                      const res = await apiRequest("POST", "/api/ai/party-suggestions", { partyId: params.id });
                      const data = await res.json();
                      setAiSuggestions(data.suggestions);
                    } catch (err: any) {
                      toast({ title: "AI unavailable", description: err.message, variant: "destructive" });
                    } finally {
                      setAiLoading(false);
                    }
                  }}
                >
                  {aiLoading ? <Loader2 className="h-4 w-4 animate-spin mr-1" /> : <Sparkles className="h-4 w-4 mr-1" />}
                  {aiLoading ? "Thinking..." : "Get Suggestions"}
                </Button>
              </div>
              {aiSuggestions && (
                <p className="text-sm text-muted-foreground whitespace-pre-wrap" data-testid="text-ai-suggestions">
                  {aiSuggestions}
                </p>
              )}
            </CardContent>
          </Card>
        )}

        {party.galleryUrls && party.galleryUrls.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-3">Gallery</h2>
              <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                {party.galleryUrls.map((url, i) => (
                  <div key={i} className="aspect-square overflow-hidden rounded-md">
                    <img
                      src={url}
                      alt={`Gallery ${i + 1}`}
                      className="w-full h-full object-cover"
                      data-testid={`img-gallery-${i}`}
                    />
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {attendees && attendees.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-3">Attendees ({attendees.length})</h2>
              <div className="flex flex-wrap gap-3">
                {attendees.map((attendee) => (
                  <div key={attendee.id} className="flex items-center gap-2" data-testid={`attendee-${attendee.id}`}>
                    <Avatar className="h-8 w-8">
                      <AvatarImage src={attendee.avatar} />
                      <AvatarFallback>{attendee.fullName?.charAt(0)?.toUpperCase() || "?"}</AvatarFallback>
                    </Avatar>
                    <span className="text-sm">{attendee.fullName}</span>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {(isHost || isAttending) && (
          <Card data-testid="section-chat">
            <CardContent className="p-4">
              <div className="flex items-center gap-2 mb-3">
                <MessageCircle className="h-5 w-5 text-muted-foreground" />
                <h2 className="font-semibold">Party Chat</h2>
              </div>
              <div className="max-h-80 overflow-y-auto space-y-3 mb-3">
                {messages.length === 0 && (
                  <p className="text-sm text-muted-foreground text-center py-4">No messages yet. Start the conversation!</p>
                )}
                {messages.map((msg: any) => {
                  const isOwn = msg.senderId === user?.id;
                  return (
                    <div
                      key={msg.id}
                      className={`flex items-start gap-2 ${isOwn ? "flex-row-reverse" : ""}`}
                      data-testid={`message-${msg.id}`}
                    >
                      <Avatar className="h-7 w-7 shrink-0">
                        <AvatarImage src={msg.sender?.avatar} />
                        <AvatarFallback>{msg.sender?.fullName?.charAt(0)?.toUpperCase() || "?"}</AvatarFallback>
                      </Avatar>
                      <div className={`flex-1 min-w-0 ${isOwn ? "text-right" : ""}`}>
                        <div className={`flex items-center gap-1.5 flex-wrap ${isOwn ? "justify-end" : ""}`}>
                          <span className="text-xs font-medium">{msg.sender?.fullName || msg.sender?.nickname || "Unknown"}</span>
                          <span className="text-xs text-muted-foreground">
                            {msg.createdAt ? format(new Date(msg.createdAt), "h:mm a") : ""}
                          </span>
                          {isHost && !isOwn && (
                            <Button
                              size="icon"
                              variant="ghost"
                              onClick={() => deleteMessageMutation.mutate(msg.id)}
                              data-testid={`button-delete-message-${msg.id}`}
                            >
                              <Trash2 className="h-3 w-3" />
                            </Button>
                          )}
                        </div>
                        <p className={`text-sm mt-0.5 inline-block rounded-md px-2.5 py-1.5 ${isOwn ? "bg-primary text-primary-foreground" : "bg-muted"}`}>
                          {msg.message}
                        </p>
                      </div>
                    </div>
                  );
                })}
                <div ref={chatEndRef} />
              </div>
              <div className="flex items-center gap-2">
                <Input
                  placeholder="Type a message..."
                  value={chatMessage}
                  onChange={(e) => setChatMessage(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === "Enter" && !e.shiftKey && chatMessage.trim()) {
                      e.preventDefault();
                      sendMessageMutation.mutate();
                    }
                  }}
                  data-testid="input-chat-message"
                />
                <Button
                  size="icon"
                  onClick={() => sendMessageMutation.mutate()}
                  disabled={!chatMessage.trim() || sendMessageMutation.isPending}
                  data-testid="button-send-message"
                >
                  <Send className="h-4 w-4" />
                </Button>
              </div>
            </CardContent>
          </Card>
        )}

        {(isHost || isAttending) && (
          <Card data-testid="section-qr-checkin">
            <CardContent className="p-4">
              <div className="flex items-center gap-2 mb-3">
                <QrCode className="h-5 w-5 text-muted-foreground" />
                <h2 className="font-semibold">QR Check-in</h2>
              </div>
              {isHost ? (
                <div className="flex flex-col items-center gap-3">
                  {qrCodeUrl ? (
                    <img
                      src={qrCodeUrl}
                      alt="QR Code for check-in"
                      className="w-48 h-48"
                      data-testid="img-qr-code"
                    />
                  ) : (
                    <Skeleton className="w-48 h-48" />
                  )}
                  <p className="text-sm text-muted-foreground text-center">
                    Show this QR code to attendees for check-in
                  </p>
                </div>
              ) : (
                <div>
                  {attendees?.find((a) => a.id === user?.id && (a as any).checkedIn) ? (
                    <div className="flex items-center gap-2 justify-center py-3">
                      <CheckCircle2 className="h-5 w-5 text-green-500" />
                      <span className="font-medium text-green-500">Checked In</span>
                    </div>
                  ) : (
                    <div className="space-y-3">
                      <p className="text-sm text-muted-foreground">
                        Enter the QR code token from the host to check in.
                      </p>
                      <div className="flex items-center gap-2">
                        <Input
                          placeholder="Enter QR token..."
                          value={qrInput}
                          onChange={(e) => setQrInput(e.target.value)}
                          data-testid="input-qr-token"
                        />
                        <Button
                          onClick={() => checkinMutation.mutate()}
                          disabled={!qrInput.trim() || checkinMutation.isPending}
                          data-testid="button-checkin"
                        >
                          {checkinMutation.isPending ? "Checking in..." : "Check In"}
                        </Button>
                      </div>
                    </div>
                  )}
                </div>
              )}
            </CardContent>
          </Card>
        )}

        {isAuthenticated && !isHost && party.includesAlcohol && (
          <Card>
            <CardContent className="p-4">
              {user?.isAgeVerified ? (
                <div className="flex items-center gap-2" data-testid="badge-age-verified">
                  <ShieldCheck className="h-5 w-5 text-green-500" />
                  <span className="font-medium text-green-500">Age Verified</span>
                </div>
              ) : (
                <div className="space-y-3">
                  <div className="flex items-start gap-2">
                    <ShieldCheck className="h-5 w-5 text-muted-foreground shrink-0 mt-0.5" />
                    <p className="text-sm text-muted-foreground" data-testid="text-verification-required">
                      This party includes alcohol. Age verification (18+) is required to join.
                    </p>
                  </div>
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept="image/*"
                    capture="environment"
                    className="hidden"
                    data-testid="input-id-upload"
                    onChange={(e) => {
                      const file = e.target.files?.[0];
                      if (file) handleVerifyAge(file);
                    }}
                  />
                  <Button
                    variant="outline"
                    className="w-full"
                    onClick={() => fileInputRef.current?.click()}
                    disabled={verifying}
                    data-testid="button-verify-age"
                  >
                    {verifying ? (
                      <Loader2 className="h-4 w-4 animate-spin mr-2" />
                    ) : (
                      <Upload className="h-4 w-4 mr-2" />
                    )}
                    {verifying ? "Verifying..." : "Upload ID to Verify Age"}
                  </Button>
                  {verificationResult && (
                    <p className="text-sm text-muted-foreground" data-testid="text-verification-result">
                      {verificationResult}
                    </p>
                  )}
                </div>
              )}
            </CardContent>
          </Card>
        )}

        {isAuthenticated && !isHost && !isAttending && !existingRequest && (
          <Card>
            <CardContent className="p-4">
              <div className="flex items-start gap-2 mb-3">
                <Info className="h-4 w-4 text-muted-foreground shrink-0 mt-0.5" />
                <div>
                  <p className="text-sm font-medium text-muted-foreground">Tips for a great experience:</p>
                  <ul className="text-xs text-muted-foreground mt-1 space-y-0.5 list-disc list-inside">
                    <li>Arrive on time</li>
                    <li>Bring what you promised</li>
                    <li>Respect the host's space</li>
                    <li>Let the host know if plans change</li>
                  </ul>
                </div>
              </div>
            </CardContent>
          </Card>
        )}

        {isAuthenticated && !isHost && (
          <Card>
            <CardContent className="p-4">
              {isAttending ? (
                <div className="flex items-center gap-2 text-center justify-center py-4" data-testid="text-attending">
                  <CheckCircle2 className="h-5 w-5 text-green-500" />
                  <span className="font-semibold text-green-500">You're Going!</span>
                </div>
              ) : existingRequest ? (
                <div className="flex items-center gap-2 text-center justify-center py-4" data-testid="text-pending">
                  <Clock className="h-5 w-5 text-muted-foreground" />
                  <span className="text-muted-foreground">
                    Request {existingRequest.status === "pending" ? "pending" : existingRequest.status}
                  </span>
                </div>
              ) : (
                <div className="space-y-3">
                  <h2 className="font-semibold">Request to Join</h2>
                  <Textarea
                    placeholder="Say hi to the host! Why would you be a great guest?"
                    value={message}
                    onChange={(e) => setMessage(e.target.value)}
                    data-testid="input-request-message"
                  />
                  <Input
                    placeholder="What will you bring? (optional)"
                    value={pledgedItems}
                    onChange={(e) => setPledgedItems(e.target.value)}
                    data-testid="input-pledged-items"
                  />
                  {party.includesAlcohol && !user?.isAgeVerified && (
                    <p className="text-sm text-muted-foreground" data-testid="text-verification-needed">
                      Age verification is required to join this party.
                    </p>
                  )}
                  <Button
                    onClick={() => joinMutation.mutate()}
                    disabled={joinMutation.isPending || (!!party.includesAlcohol && !(user?.isAgeVerified ?? false))}
                    className="w-full"
                    data-testid="button-request-join"
                  >
                    <Send className="h-4 w-4 mr-2" />
                    {joinMutation.isPending ? "Sending..." : "Request to Join"}
                  </Button>
                </div>
              )}
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  );
}


========================================
FILE: client/src/pages/profile-page.tsx
========================================
import { useState, useEffect, useRef } from "react";
import { useQuery } from "@tanstack/react-query";
import { useLocation, Link } from "wouter";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Skeleton } from "@/components/ui/skeleton";
import { Separator } from "@/components/ui/separator";
import { Star, ShieldCheck, Settings, LogOut, Award, UserCheck, Calendar, PartyPopper, Camera, Brain, ArrowRight, Upload, Loader2 } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import type { Review } from "@shared/schema";

function RatingStars({ rating }: { rating: number }) {
  return (
    <div className="flex items-center gap-0.5">
      {[...Array(5)].map((_, i) => (
        <Star
          key={i}
          size={14}
          className={i < Math.floor(rating) ? "fill-yellow-500 text-yellow-500" : "text-muted-foreground"}
        />
      ))}
      <span className="text-sm text-muted-foreground ml-1">{rating.toFixed(1)}</span>
    </div>
  );
}

function getInitials(name: string) {
  return name
    .split(" ")
    .map((n) => n[0])
    .join("")
    .toUpperCase()
    .slice(0, 2);
}

function PersonalityTraitBar({
  traitName,
  score,
  color,
  testId,
}: {
  traitName: string;
  score: number;
  color: string;
  testId: string;
}) {
  return (
    <div className="space-y-1.5">
      <div className="flex items-center justify-between gap-2">
        <span className="text-sm text-muted-foreground" data-testid={`text-trait-${testId}`}>
          {traitName}
        </span>
        <span className="text-sm font-semibold" data-testid={`text-score-${testId}`}>
          {Math.round(score)}
        </span>
      </div>
      <div className="h-2 rounded-full bg-muted overflow-hidden">
        <div
          className={`h-full rounded-full transition-all ${color}`}
          style={{ width: `${score}%` }}
          data-testid={`bar-${testId}`}
        />
      </div>
    </div>
  );
}

export default function ProfilePage() {
  const [, setLocation] = useLocation();
  const { user, isLoading, logout } = useAuth();
  const { toast } = useToast();
  const [reviewTab, setReviewTab] = useState("host");
  const [avatarUploading, setAvatarUploading] = useState(false);
  const [verifying, setVerifying] = useState(false);
  const [verificationResult, setVerificationResult] = useState<string | null>(null);
  const avatarInputRef = useRef<HTMLInputElement>(null);
  const idFileInputRef = useRef<HTMLInputElement>(null);

  async function handleAvatarUpload(file: File) {
    if (!user) return;
    setAvatarUploading(true);
    try {
      const formData = new FormData();
      formData.append("image", file);
      const res = await fetch("/api/upload/avatar", {
        method: "POST",
        body: formData,
        credentials: "include",
      });
      if (!res.ok) throw new Error("Upload failed");
      const data = await res.json();
      await apiRequest("PATCH", `/api/users/${user.id}`, { avatar: data.url });
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      toast({ title: "Avatar updated", description: "Your profile photo has been changed." });
    } catch {
      toast({ title: "Upload failed", description: "Could not update avatar. Please try again.", variant: "destructive" });
    } finally {
      setAvatarUploading(false);
    }
  }

  async function handleVerifyAge(file: File) {
    setVerifying(true);
    setVerificationResult(null);
    try {
      const base64 = await new Promise<string>((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result as string);
        reader.onerror = () => reject(new Error("Failed to read file"));
        reader.readAsDataURL(file);
      });
      const res = await apiRequest("POST", "/api/verify-age", { imageBase64: base64 });
      const data = await res.json();
      setVerificationResult(data.message || "Verification complete");
      toast({ title: "Verification complete", description: data.message });
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
    } catch (error: any) {
      toast({ title: "Verification failed", description: error.message, variant: "destructive" });
    } finally {
      setVerifying(false);
    }
  }

  const { data: reviews = [], isLoading: reviewsLoading } = useQuery<Review[]>({
    queryKey: ["/api/users", user?.id, "reviews"],
    enabled: !!user?.id,
  });

  const { data: stats } = useQuery<{
    partiesAttended: number;
    partiesHosted: number;
    reviewCount: number;
    profileCompleteness: number;
  }>({
    queryKey: ["/api/users", user?.id, "stats"],
    enabled: !!user?.id,
  });

  const hostReviews = reviews.filter((r) => r.type === "host");
  const guestReviews = reviews.filter((r) => r.type === "guest");

  if (isLoading || !user) {
    return (
      <div className="min-h-screen bg-background p-4">
        <div className="max-w-lg mx-auto space-y-4">
          <Skeleton className="h-32 w-full rounded-md" />
          <Skeleton className="h-24 w-full rounded-md" />
          <Skeleton className="h-48 w-full rounded-md" />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background text-foreground p-4 pb-28">
      <div className="max-w-lg mx-auto space-y-4">
        <Card>
          <CardContent className="p-6">
            <div className="flex flex-col items-center text-center gap-3">
              <input
                ref={avatarInputRef}
                type="file"
                accept="image/*"
                capture="environment"
                className="hidden"
                data-testid="input-avatar-file"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) handleAvatarUpload(file);
                }}
              />
              <button
                type="button"
                className="relative cursor-pointer group"
                onClick={() => avatarInputRef.current?.click()}
                disabled={avatarUploading}
                data-testid="button-change-avatar"
              >
                <Avatar className="h-24 w-24" data-testid="img-avatar">
                  <AvatarImage src={user.avatar || undefined} alt={user.fullName} />
                  <AvatarFallback className="text-2xl">{getInitials(user.fullName)}</AvatarFallback>
                </Avatar>
                <div className="absolute bottom-0 right-0 bg-primary text-primary-foreground rounded-full p-1.5">
                  {avatarUploading ? (
                    <div className="h-4 w-4 border-2 border-primary-foreground border-t-transparent rounded-full animate-spin" />
                  ) : (
                    <Camera className="h-4 w-4" />
                  )}
                </div>
              </button>
              <div className="space-y-1">
                <div className="flex items-center justify-center gap-2 flex-wrap">
                  <h1 className="text-xl font-semibold" data-testid="text-fullname">{user.fullName}</h1>
                  {user.isIdVerified && (
                    <Badge variant="secondary" className="gap-1" data-testid="badge-verified">
                      <ShieldCheck size={12} />
                      Verified
                    </Badge>
                  )}
                </div>
                <p className="text-sm text-muted-foreground" data-testid="text-username">@{user.username}</p>
              </div>
              {user.bio && (
                <p className="text-sm text-muted-foreground max-w-sm" data-testid="text-bio">{user.bio}</p>
              )}
            </div>
          </CardContent>
        </Card>

        <Card data-testid="card-trust-signals">
          <CardHeader className="pb-2">
            <CardTitle className="text-base">Trust & Activity</CardTitle>
          </CardHeader>
          <CardContent className="p-4 pt-0 space-y-4">
            <div className="space-y-1.5">
              <div className="flex items-center justify-between gap-2 flex-wrap">
                <span className="text-sm text-muted-foreground">Profile Completeness</span>
                <span className="text-sm font-semibold" data-testid="text-completeness">{stats?.profileCompleteness ?? 0}%</span>
              </div>
              <div className="h-2 rounded-full bg-muted overflow-hidden">
                <div
                  className="h-full rounded-full bg-primary transition-all"
                  style={{ width: `${stats?.profileCompleteness ?? 0}%` }}
                />
              </div>
            </div>
            <div className="grid grid-cols-2 gap-3">
              <div className="flex items-center gap-2">
                <Calendar size={16} className="text-muted-foreground shrink-0" />
                <div>
                  <span className="font-semibold" data-testid="text-parties-attended">{stats?.partiesAttended ?? 0}</span>
                  <p className="text-xs text-muted-foreground">Parties Attended</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <PartyPopper size={16} className="text-muted-foreground shrink-0" />
                <div>
                  <span className="font-semibold" data-testid="text-parties-hosted">{stats?.partiesHosted ?? 0}</span>
                  <p className="text-xs text-muted-foreground">Parties Hosted</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <Star size={16} className="text-muted-foreground shrink-0" />
                <div>
                  <span className="font-semibold" data-testid="text-review-count">{stats?.reviewCount ?? 0}</span>
                  <p className="text-xs text-muted-foreground">Reviews</p>
                </div>
              </div>
              {(stats?.profileCompleteness ?? 0) < 100 && (
                <div className="flex items-center gap-2">
                  <ShieldCheck size={16} className="text-muted-foreground shrink-0" />
                  <div>
                    <p className="text-xs text-muted-foreground">Complete your profile to build trust</p>
                  </div>
                </div>
              )}
              {user.isIdVerified && (
                <div className="flex items-center gap-2">
                  <ShieldCheck size={16} className="text-primary shrink-0" />
                  <div>
                    <p className="text-xs font-semibold">ID Verified</p>
                  </div>
                </div>
              )}
              {user.isAgeVerified && (
                <div className="flex items-center gap-2">
                  <ShieldCheck size={16} className="text-primary shrink-0" />
                  <div>
                    <p className="text-xs font-semibold" data-testid="text-age-verified">Age Verified</p>
                  </div>
                </div>
              )}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="grid grid-cols-3 gap-4 text-center">
              <div className="space-y-1">
                <div className="flex items-center justify-center gap-1">
                  <Star size={16} className="fill-yellow-500 text-yellow-500" />
                  <span className="font-semibold" data-testid="text-host-rating">
                    {(user.hostRating ?? 0).toFixed(1)}
                  </span>
                </div>
                <p className="text-xs text-muted-foreground">Host Rating</p>
              </div>
              <div className="space-y-1">
                <div className="flex items-center justify-center gap-1">
                  <Star size={16} className="fill-yellow-500 text-yellow-500" />
                  <span className="font-semibold" data-testid="text-guest-rating">
                    {(user.guestRating ?? 0).toFixed(1)}
                  </span>
                </div>
                <p className="text-xs text-muted-foreground">Guest Rating</p>
              </div>
              <div className="space-y-1">
                <span className="font-semibold" data-testid="text-review-count">{reviews.length}</span>
                <p className="text-xs text-muted-foreground">Reviews</p>
              </div>
            </div>
          </CardContent>
        </Card>

        {user.oceanOpenness !== null ? (
          <Card data-testid="section-personality">
            <CardHeader className="pb-2">
              <CardTitle className="text-base">Personality Profile</CardTitle>
            </CardHeader>
            <CardContent className="p-4 pt-0 space-y-4">
              <PersonalityTraitBar
                traitName="Openness"
                score={user.oceanOpenness ?? 0}
                color="bg-purple-500"
                testId="openness"
              />
              <PersonalityTraitBar
                traitName="Conscientiousness"
                score={user.oceanConscientiousness ?? 0}
                color="bg-blue-500"
                testId="conscientiousness"
              />
              <PersonalityTraitBar
                traitName="Extraversion"
                score={user.oceanExtraversion ?? 0}
                color="bg-amber-400"
                testId="extraversion"
              />
              <PersonalityTraitBar
                traitName="Agreeableness"
                score={user.oceanAgreeableness ?? 0}
                color="bg-green-500"
                testId="agreeableness"
              />
              <PersonalityTraitBar
                traitName="Neuroticism"
                score={user.oceanNeuroticism ?? 0}
                color="bg-orange-500"
                testId="neuroticism"
              />
              {user.oceanLastTaken && (
                <div className="pt-2">
                  <p className="text-xs text-muted-foreground" data-testid="text-ocean-last-taken">
                    Last taken: {new Date(user.oceanLastTaken).toLocaleDateString()}
                  </p>
                </div>
              )}
              {user.oceanLastTaken &&
                (() => {
                  const lastTaken = new Date(user.oceanLastTaken);
                  const ninetyDaysAgo = new Date();
                  ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
                  return lastTaken < ninetyDaysAgo ? (
                    <Link href="/personality-test">
                      <Button variant="outline" className="w-full" data-testid="button-retake-test">
                        <ArrowRight size={16} className="mr-2" />
                        Retake Test
                      </Button>
                    </Link>
                  ) : null;
                })()}
            </CardContent>
          </Card>
        ) : (
          <Card data-testid="section-personality">
            <CardContent className="p-6">
              <div className="flex flex-col items-center text-center gap-3">
                <Brain size={32} className="text-muted-foreground" />
                <div>
                  <h3 className="font-semibold text-base mb-1">Discover your party personality</h3>
                  <p className="text-sm text-muted-foreground mb-3">
                    Take the OCEAN personality test to find parties that match your vibe.
                  </p>
                </div>
                <Link href="/personality-test">
                  <Button className="w-full" data-testid="button-take-test">
                    <Brain size={16} className="mr-2" />
                    Take the Test
                  </Button>
                </Link>
              </div>
            </CardContent>
          </Card>
        )}

        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-base">Reviews</CardTitle>
          </CardHeader>
          <CardContent className="p-4 pt-0">
            <Tabs value={reviewTab} onValueChange={setReviewTab}>
              <TabsList className="w-full" data-testid="tabs-reviews">
                <TabsTrigger value="host" className="flex-1" data-testid="tab-as-host">As Host</TabsTrigger>
                <TabsTrigger value="guest" className="flex-1" data-testid="tab-as-guest">As Guest</TabsTrigger>
              </TabsList>

              <TabsContent value="host" className="mt-3 space-y-3">
                {reviewsLoading ? (
                  <div className="space-y-3">
                    <Skeleton className="h-20 w-full" />
                    <Skeleton className="h-20 w-full" />
                  </div>
                ) : hostReviews.length === 0 ? (
                  <div className="text-center py-6">
                    <Award size={32} className="mx-auto text-muted-foreground mb-2" />
                    <p className="text-sm text-muted-foreground" data-testid="text-no-host-reviews">No host reviews yet</p>
                  </div>
                ) : (
                  hostReviews.map((review) => (
                    <ReviewCard key={review.id} review={review} />
                  ))
                )}
              </TabsContent>

              <TabsContent value="guest" className="mt-3 space-y-3">
                {reviewsLoading ? (
                  <div className="space-y-3">
                    <Skeleton className="h-20 w-full" />
                    <Skeleton className="h-20 w-full" />
                  </div>
                ) : guestReviews.length === 0 ? (
                  <div className="text-center py-6">
                    <UserCheck size={32} className="mx-auto text-muted-foreground mb-2" />
                    <p className="text-sm text-muted-foreground" data-testid="text-no-guest-reviews">No guest reviews yet</p>
                  </div>
                ) : (
                  guestReviews.map((review) => (
                    <ReviewCard key={review.id} review={review} />
                  ))
                )}
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>

        <div className="space-y-2">
          <Button
            className="w-full"
            onClick={() => setLocation("/settings")}
            data-testid="button-edit-profile"
          >
            <Settings size={16} className="mr-2" />
            Edit Profile
          </Button>

          {user.isIdVerified ? (
            <div className="flex items-center justify-center gap-2 p-2">
              <ShieldCheck size={16} className="text-primary" />
              <span className="text-sm font-medium" data-testid="text-id-verified">ID Verified</span>
            </div>
          ) : (
            <>
              <input
                ref={idFileInputRef}
                type="file"
                accept="image/*"
                capture="environment"
                className="hidden"
                data-testid="input-id-file"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) handleVerifyAge(file);
                }}
              />
              <Button
                variant="outline"
                className="w-full"
                onClick={() => idFileInputRef.current?.click()}
                disabled={verifying}
                data-testid="button-verify-id"
              >
                {verifying ? (
                  <Loader2 size={16} className="mr-2 animate-spin" />
                ) : (
                  <Upload size={16} className="mr-2" />
                )}
                {verifying ? "Verifying..." : "Upload ID to Verify"}
              </Button>
              {verificationResult && (
                <p className="text-sm text-muted-foreground text-center" data-testid="text-verification-result">
                  {verificationResult}
                </p>
              )}
            </>
          )}

          <Button
            variant="outline"
            className="w-full"
            onClick={() => logout()}
            data-testid="button-logout"
          >
            <LogOut size={16} className="mr-2" />
            Log Out
          </Button>
        </div>
      </div>
    </div>
  );
}

function ReviewCard({ review }: { review: Review }) {
  return (
    <Card data-testid={`card-review-${review.id}`}>
      <CardContent className="p-4">
        <div className="flex items-start gap-3">
          <Avatar className="h-8 w-8 shrink-0">
            <AvatarFallback className="text-xs">
              {review.authorId.slice(0, 2).toUpperCase()}
            </AvatarFallback>
          </Avatar>
          <div className="flex-1 min-w-0 space-y-1">
            <div className="flex items-center justify-between gap-2 flex-wrap">
              <RatingStars rating={review.rating} />
              {review.createdAt && (
                <span className="text-xs text-muted-foreground" data-testid={`text-review-date-${review.id}`}>
                  {new Date(review.createdAt).toLocaleDateString()}
                </span>
              )}
            </div>
            <p className="text-sm" data-testid={`text-review-content-${review.id}`}>{review.content}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}


========================================
FILE: client/src/pages/settings-page.tsx
========================================
import { useState, useEffect } from "react";
import { useMutation } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { Slider } from "@/components/ui/slider";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Separator } from "@/components/ui/separator";
import { Skeleton } from "@/components/ui/skeleton";
import { ArrowLeft, Save, LogOut, Navigation } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useTheme } from "@/components/theme-provider";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";

const COUNTRY_DATA: Record<string, string[]> = {
  "USA": ["New York", "Los Angeles", "Chicago", "Miami", "Austin", "San Francisco", "Seattle", "Denver"],
  "United Kingdom": ["London", "Manchester", "Birmingham", "Edinburgh", "Bristol", "Glasgow", "Liverpool"],
  "Germany": ["Berlin", "Munich", "Hamburg", "Cologne", "Frankfurt", "Stuttgart", "Dsseldorf"],
  "Romania": ["Bucharest", "Cluj-Napoca", "Timioara", "Iai", "Constana", "Braov", "Sibiu", "Vama Veche"],
};

export default function SettingsPage() {
  const [, setLocation] = useLocation();
  const { user, isLoading, logout } = useAuth();
  const { theme, setTheme } = useTheme();
  const { toast } = useToast();

  const [fullName, setFullName] = useState("");
  const [nickname, setNickname] = useState("");
  const [email, setEmail] = useState("");
  const [phone, setPhone] = useState("");
  const [bio, setBio] = useState("");

  const [country, setCountry] = useState("");
  const [city, setCity] = useState("");
  const [address, setAddress] = useState("");

  const [notifications, setNotifications] = useState(true);
  const [darkMode, setDarkMode] = useState(false);
  const [searchRadius, setSearchRadius] = useState(50);

  useEffect(() => {
    if (user) {
      setFullName(user.fullName || "");
      setNickname(user.nickname || "");
      setEmail(user.email || "");
      setPhone(user.phone || "");
      setBio(user.bio || "");
      setCountry(user.country || "");
      setCity(user.city || "");
      setAddress(user.address || "");
      setNotifications(user.notificationsEnabled ?? true);
      setDarkMode(user.darkMode ?? false);
      setSearchRadius(user.searchRadius ?? 50);
    }
  }, [user]);

  const updateMutation = useMutation({
    mutationFn: async (data: Record<string, unknown>) => {
      const res = await apiRequest("PATCH", `/api/users/${user!.id}`, data);
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      toast({ title: "Saved", description: "Your changes have been saved." });
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to save changes.", variant: "destructive" });
    },
  });

  const cities = country ? COUNTRY_DATA[country] || [] : [];

  if (isLoading) {
    return (
      <div className="min-h-screen bg-background p-4">
        <div className="max-w-lg mx-auto space-y-4">
          <Skeleton className="h-8 w-32" />
          <Skeleton className="h-48 w-full rounded-md" />
          <Skeleton className="h-48 w-full rounded-md" />
        </div>
      </div>
    );
  }

  if (!user) {
    return null;
  }

  return (
    <div className="min-h-screen bg-background text-foreground p-4 pb-28">
      <div className="max-w-lg mx-auto space-y-4">
        <Button
          variant="ghost"
          onClick={() => setLocation("/profile")}
          data-testid="button-back"
        >
          <ArrowLeft size={16} className="mr-2" />
          Back to Profile
        </Button>

        <h1 className="text-xl font-semibold" data-testid="text-settings-title">Settings</h1>

        <Card>
          <CardHeader>
            <CardTitle className="text-base">Personal Info</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="fullName">Full Name</Label>
              <Input
                id="fullName"
                value={fullName}
                onChange={(e) => setFullName(e.target.value)}
                data-testid="input-fullname"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="nickname">Nickname</Label>
              <Input
                id="nickname"
                value={nickname}
                onChange={(e) => setNickname(e.target.value)}
                data-testid="input-nickname"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                data-testid="input-email"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="phone">Phone</Label>
              <Input
                id="phone"
                value={phone}
                onChange={(e) => setPhone(e.target.value)}
                data-testid="input-phone"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="bio">Bio</Label>
              <Textarea
                id="bio"
                value={bio}
                onChange={(e) => setBio(e.target.value)}
                rows={3}
                data-testid="input-bio"
              />
            </div>
            <Button
              onClick={() =>
                updateMutation.mutate({ fullName, nickname, email, phone, bio })
              }
              disabled={updateMutation.isPending}
              data-testid="button-save-personal"
            >
              <Save size={16} className="mr-2" />
              {updateMutation.isPending ? "Saving..." : "Save Personal Info"}
            </Button>
          </CardContent>
        </Card>

        <Separator />

        <Card>
          <CardHeader>
            <CardTitle className="text-base">Location</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label>Country</Label>
              <Select
                value={country}
                onValueChange={(val) => {
                  setCountry(val);
                  setCity("");
                }}
              >
                <SelectTrigger data-testid="select-country">
                  <SelectValue placeholder="Select country" />
                </SelectTrigger>
                <SelectContent>
                  {Object.keys(COUNTRY_DATA).map((c) => (
                    <SelectItem key={c} value={c} data-testid={`option-country-${c}`}>
                      {c}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>City</Label>
              <Select value={city} onValueChange={setCity} disabled={!country}>
                <SelectTrigger data-testid="select-city">
                  <SelectValue placeholder="Select city" />
                </SelectTrigger>
                <SelectContent>
                  {cities.map((c) => (
                    <SelectItem key={c} value={c} data-testid={`option-city-${c}`}>
                      {c}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label htmlFor="address">Address</Label>
              <Input
                id="address"
                value={address}
                onChange={(e) => setAddress(e.target.value)}
                data-testid="input-address"
              />
            </div>
            {user.latitude && user.longitude && (
              <div className="rounded-md bg-muted p-3 space-y-1">
                <p className="text-xs text-muted-foreground">Current GPS Location</p>
                <p className="text-sm font-mono" data-testid="text-gps-coords">
                  {Number(user.latitude).toFixed(6)}, {Number(user.longitude).toFixed(6)}
                </p>
              </div>
            )}
            <Button
              variant="outline"
              className="w-full"
              onClick={() => {
                if (!navigator.geolocation) {
                  toast({ title: "Not supported", description: "Geolocation is not supported by your browser.", variant: "destructive" });
                  return;
                }
                toast({ title: "Detecting location...", description: "Please allow location access when prompted." });
                navigator.geolocation.getCurrentPosition(
                  (position) => {
                    const { latitude, longitude } = position.coords;
                    updateMutation.mutate({ latitude, longitude });
                  },
                  (error) => {
                    toast({ title: "Location error", description: error.message || "Could not detect your location.", variant: "destructive" });
                  },
                  { enableHighAccuracy: true, timeout: 10000 }
                );
              }}
              disabled={updateMutation.isPending}
              data-testid="button-detect-location"
            >
              <Navigation size={16} className="mr-2" />
              Detect My Location
            </Button>
            <Button
              onClick={() => updateMutation.mutate({ country, city, address })}
              disabled={updateMutation.isPending}
              data-testid="button-save-location"
            >
              <Save size={16} className="mr-2" />
              {updateMutation.isPending ? "Saving..." : "Save Location"}
            </Button>
          </CardContent>
        </Card>

        <Separator />

        <Card>
          <CardHeader>
            <CardTitle className="text-base">Preferences</CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="flex items-center justify-between gap-4">
              <div>
                <Label>Notifications</Label>
                <p className="text-xs text-muted-foreground">Receive push notifications</p>
              </div>
              <Switch
                checked={notifications}
                onCheckedChange={setNotifications}
                data-testid="switch-notifications"
              />
            </div>
            <div className="flex items-center justify-between gap-4">
              <div>
                <Label>Dark Mode</Label>
                <p className="text-xs text-muted-foreground">Toggle dark theme</p>
              </div>
              <Switch
                checked={theme === "dark"}
                onCheckedChange={(checked) => {
                  setTheme(checked ? "dark" : "light");
                  setDarkMode(checked);
                }}
                data-testid="switch-dark-mode"
              />
            </div>
            <div className="space-y-3">
              <div className="flex items-center justify-between gap-4">
                <Label>Search Radius</Label>
                <span className="text-sm text-muted-foreground" data-testid="text-search-radius">
                  {searchRadius} km
                </span>
              </div>
              <Slider
                value={[searchRadius]}
                onValueChange={(val) => setSearchRadius(val[0])}
                min={5}
                max={200}
                step={5}
                data-testid="slider-search-radius"
              />
            </div>
            <Button
              onClick={() =>
                updateMutation.mutate({
                  notificationsEnabled: notifications,
                  darkMode,
                  searchRadius,
                })
              }
              disabled={updateMutation.isPending}
              data-testid="button-save-preferences"
            >
              <Save size={16} className="mr-2" />
              {updateMutation.isPending ? "Saving..." : "Save Preferences"}
            </Button>
          </CardContent>
        </Card>

        <Separator />

        <Card>
          <CardHeader>
            <CardTitle className="text-base">Account</CardTitle>
          </CardHeader>
          <CardContent>
            <Button
              variant="outline"
              className="w-full"
              onClick={() => logout()}
              data-testid="button-logout"
            >
              <LogOut size={16} className="mr-2" />
              Log Out
            </Button>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}


========================================
FILE: client/src/pages/onboarding-page.tsx
========================================
import { useState } from "react";
import { useLocation } from "wouter";
import { useMutation } from "@tanstack/react-query";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  PartyPopper,
  ChevronRight,
  ChevronLeft,
  Check,
  Loader2,
  Music,
  Users,
  Flame,
  Utensils,
  TreePine,
  Sparkles,
  Navigation,
} from "lucide-react";

const COUNTRIES = [
  { value: "USA", label: "USA" },
  { value: "United Kingdom", label: "United Kingdom" },
  { value: "Germany", label: "Germany" },
  { value: "Romania", label: "Romania" },
] as const;

const CITIES_BY_COUNTRY: Record<string, string[]> = {
  USA: ["New York", "Los Angeles", "Chicago", "Miami", "Austin", "San Francisco", "Seattle", "Denver"],
  "United Kingdom": ["London", "Manchester", "Birmingham", "Edinburgh", "Bristol", "Glasgow", "Liverpool"],
  Germany: ["Berlin", "Munich", "Hamburg", "Cologne", "Frankfurt", "Stuttgart", "Dsseldorf"],
  Romania: ["Bucharest", "Cluj-Napoca", "Timioara", "Iai", "Constana", "Braov", "Sibiu", "Vama Veche"],
};

const personalInfoSchema = z.object({
  nickname: z.string().optional(),
  dob: z.string().optional(),
  phone: z.string().optional(),
  bio: z.string().optional(),
});

const vibeSchema = z.object({
  preferredVibe: z.string().optional(),
  gatheringSizePref: z.string().optional(),
  hostOrGuest: z.string().optional(),
});

const locationSchema = z.object({
  country: z.string().min(1, "Please select a country"),
  city: z.string().min(1, "Please select a city"),
  address: z.string().optional(),
});

type PersonalInfoValues = z.infer<typeof personalInfoSchema>;
type VibeValues = z.infer<typeof vibeSchema>;
type LocationValues = z.infer<typeof locationSchema>;

const VIBE_OPTIONS = [
  { value: "chill", label: "Chill & Intimate", icon: Sparkles },
  { value: "dance", label: "Dance & Energy", icon: Flame },
  { value: "food", label: "Food & Drinks", icon: Utensils },
  { value: "music", label: "Music & Live", icon: Music },
  { value: "outdoor", label: "Outdoor & Adventure", icon: TreePine },
  { value: "mix", label: "Mix of Everything", icon: Users },
];

const SIZE_OPTIONS = [
  { value: "small", label: "Small", subtitle: "1-15 people" },
  { value: "medium", label: "Medium", subtitle: "16-40 people" },
  { value: "large", label: "Large", subtitle: "41+ people" },
];

const ROLE_OPTIONS = [
  { value: "host", label: "Host", subtitle: "I love organizing events" },
  { value: "guest", label: "Guest", subtitle: "I love attending events" },
  { value: "both", label: "Both", subtitle: "I do both!" },
];

export default function OnboardingPage() {
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const { user, isLoading } = useAuth();
  const [currentStep, setCurrentStep] = useState(1);
  const [detectingLocation, setDetectingLocation] = useState(false);

  const personalForm = useForm<PersonalInfoValues>({
    resolver: zodResolver(personalInfoSchema),
    defaultValues: { nickname: "", dob: "", phone: "", bio: "" },
  });

  const vibeForm = useForm<VibeValues>({
    resolver: zodResolver(vibeSchema),
    defaultValues: { preferredVibe: "", gatheringSizePref: "", hostOrGuest: "" },
  });

  const locationForm = useForm<LocationValues>({
    resolver: zodResolver(locationSchema),
    defaultValues: { country: "", city: "", address: "" },
  });

  const selectedCountry = locationForm.watch("country");

  const updateMutation = useMutation({
    mutationFn: async (data: Record<string, unknown>) => {
      if (!user) throw new Error("Not authenticated");
      const res = await apiRequest("PATCH", `/api/users/${user.id}`, data);
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
    },
    onError: (error: Error) => {
      toast({
        title: "Update failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  if (isLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (!user) {
    return null;
  }

  const handleStep1Next = async (values: PersonalInfoValues) => {
    await updateMutation.mutateAsync({
      nickname: values.nickname || undefined,
      dob: values.dob || undefined,
      phone: values.phone || undefined,
      bio: values.bio || undefined,
    });
    setCurrentStep(2);
  };

  const handleStep2Next = async (values: VibeValues) => {
    await updateMutation.mutateAsync({
      preferredVibe: values.preferredVibe || undefined,
      gatheringSizePref: values.gatheringSizePref || undefined,
      hostOrGuest: values.hostOrGuest || undefined,
    });
    setCurrentStep(3);
  };

  const handleDetectLocation = () => {
    if (!navigator.geolocation) {
      toast({ title: "Geolocation not supported", description: "Your browser does not support GPS detection.", variant: "destructive" });
      return;
    }
    setDetectingLocation(true);
    navigator.geolocation.getCurrentPosition(
      async (position) => {
        try {
          await updateMutation.mutateAsync({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
          });
          toast({ title: "Location detected", description: "Your GPS coordinates have been saved." });
        } catch {
        } finally {
          setDetectingLocation(false);
        }
      },
      (error) => {
        setDetectingLocation(false);
        toast({ title: "Location detection failed", description: error.message, variant: "destructive" });
      },
    );
  };

  const handleStep3Next = async (values: LocationValues) => {
    await updateMutation.mutateAsync({
      country: values.country,
      city: values.city,
      address: values.address || undefined,
      onboardingComplete: true,
    });
    toast({ title: "Welcome to CambuApp!", description: "Your profile is all set. Start exploring parties!" });
    setLocation("/");
  };

  const handleSkip = () => {
    toast({ title: "Welcome to CambuApp!", description: "You can update your profile anytime." });
    setLocation("/");
  };

  const steps = [
    { number: 1, label: "Personal" },
    { number: 2, label: "Your Vibe" },
    { number: 3, label: "Location" },
  ];

  return (
    <div className="min-h-screen bg-background flex flex-col">
      <div
        className="relative overflow-hidden py-10 px-4 flex flex-col items-center"
        style={{
          background: "linear-gradient(135deg, hsl(280 85% 15%) 0%, hsl(280 85% 8%) 50%, hsl(300 60% 10%) 100%)",
        }}
      >
        <div
          className="absolute inset-0 opacity-20"
          style={{
            background: "radial-gradient(circle at 30% 50%, hsl(280 85% 55% / 0.4) 0%, transparent 50%)",
          }}
        />
        <div className="relative z-10 text-center">
          <div className="flex items-center justify-center gap-2 mb-2">
            <PartyPopper className="w-7 h-7 text-primary-foreground" />
            <h1 className="text-2xl font-bold text-primary-foreground" data-testid="text-onboarding-title">
              Set Up Your Profile
            </h1>
          </div>
          <p className="text-primary-foreground/70 text-sm" data-testid="text-onboarding-subtitle">
            Step {currentStep} of 3
          </p>
        </div>
      </div>

      <div className="flex items-center justify-center gap-2 px-4 -mt-4 relative z-10 mb-6">
        {steps.map((step) => (
          <div key={step.number} className="flex items-center gap-2">
            <div
              className={`w-9 h-9 rounded-full flex items-center justify-center text-sm font-medium transition-colors ${
                currentStep > step.number
                  ? "bg-primary text-primary-foreground"
                  : currentStep === step.number
                    ? "bg-primary text-primary-foreground"
                    : "bg-muted text-muted-foreground"
              }`}
              data-testid={`step-indicator-${step.number}`}
            >
              {currentStep > step.number ? <Check className="w-4 h-4" /> : step.number}
            </div>
            {step.number < 3 && (
              <div
                className={`w-12 h-0.5 ${
                  currentStep > step.number ? "bg-primary" : "bg-muted"
                }`}
              />
            )}
          </div>
        ))}
      </div>

      <div className="flex-1 flex items-start justify-center px-4 pb-12">
        <Card className="w-full max-w-md">
          {currentStep === 1 && (
            <>
              <CardHeader>
                <CardTitle data-testid="text-step1-title">Personal Info</CardTitle>
              </CardHeader>
              <CardContent>
                <Form {...personalForm}>
                  <form
                    onSubmit={personalForm.handleSubmit(handleStep1Next)}
                    className="space-y-4"
                    data-testid="form-personal-info"
                  >
                    <FormField
                      control={personalForm.control}
                      name="nickname"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Nickname (optional)</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="What should people call you?"
                              data-testid="input-nickname"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={personalForm.control}
                      name="dob"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Date of Birth</FormLabel>
                          <FormControl>
                            <Input
                              type="date"
                              data-testid="input-dob"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={personalForm.control}
                      name="phone"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Phone Number</FormLabel>
                          <FormControl>
                            <Input
                              type="tel"
                              placeholder="+1 555-0123"
                              data-testid="input-phone"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={personalForm.control}
                      name="bio"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Bio</FormLabel>
                          <FormControl>
                            <Textarea
                              placeholder="Tell people about yourself and what kind of parties you like..."
                              className="resize-none"
                              rows={3}
                              data-testid="input-bio"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <div className="flex items-center gap-3 justify-between pt-2">
                      <Button
                        type="button"
                        variant="ghost"
                        onClick={handleSkip}
                        data-testid="button-skip-onboarding"
                      >
                        Skip for now
                      </Button>
                      <Button
                        type="submit"
                        disabled={updateMutation.isPending}
                        data-testid="button-step1-next"
                      >
                        {updateMutation.isPending ? (
                          <Loader2 className="w-4 h-4 animate-spin mr-2" />
                        ) : null}
                        Next
                        <ChevronRight className="w-4 h-4 ml-1" />
                      </Button>
                    </div>
                  </form>
                </Form>
              </CardContent>
            </>
          )}

          {currentStep === 2 && (
            <>
              <CardHeader>
                <CardTitle data-testid="text-step2-title">Your Vibe</CardTitle>
              </CardHeader>
              <CardContent>
                <Form {...vibeForm}>
                  <form
                    onSubmit={vibeForm.handleSubmit(handleStep2Next)}
                    className="space-y-6"
                    data-testid="form-vibe"
                  >
                    <FormField
                      control={vibeForm.control}
                      name="preferredVibe"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Preferred Vibe</FormLabel>
                          <FormControl>
                            <div className="grid grid-cols-2 gap-2">
                              {VIBE_OPTIONS.map((option) => {
                                const Icon = option.icon;
                                const isSelected = field.value === option.value;
                                return (
                                  <div
                                    key={option.value}
                                    className={`cursor-pointer rounded-md border p-3 text-center transition-colors ${
                                      isSelected
                                        ? "border-primary bg-primary/10"
                                        : ""
                                    }`}
                                    onClick={() => field.onChange(option.value)}
                                    data-testid={`option-vibe-${option.value}`}
                                  >
                                    <Icon className="w-5 h-5 mx-auto mb-1 text-muted-foreground" />
                                    <span className="text-sm font-medium">{option.label}</span>
                                  </div>
                                );
                              })}
                            </div>
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={vibeForm.control}
                      name="gatheringSizePref"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Gathering Size Preference</FormLabel>
                          <FormControl>
                            <div className="grid grid-cols-3 gap-2">
                              {SIZE_OPTIONS.map((option) => {
                                const isSelected = field.value === option.value;
                                return (
                                  <div
                                    key={option.value}
                                    className={`cursor-pointer rounded-md border p-3 text-center transition-colors ${
                                      isSelected
                                        ? "border-primary bg-primary/10"
                                        : ""
                                    }`}
                                    onClick={() => field.onChange(option.value)}
                                    data-testid={`option-size-${option.value}`}
                                  >
                                    <span className="text-sm font-medium block">{option.label}</span>
                                    <span className="text-xs text-muted-foreground">{option.subtitle}</span>
                                  </div>
                                );
                              })}
                            </div>
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={vibeForm.control}
                      name="hostOrGuest"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Are you mainly a...</FormLabel>
                          <FormControl>
                            <div className="grid grid-cols-3 gap-2">
                              {ROLE_OPTIONS.map((option) => {
                                const isSelected = field.value === option.value;
                                return (
                                  <div
                                    key={option.value}
                                    className={`cursor-pointer rounded-md border p-3 text-center transition-colors ${
                                      isSelected
                                        ? "border-primary bg-primary/10"
                                        : ""
                                    }`}
                                    onClick={() => field.onChange(option.value)}
                                    data-testid={`option-role-${option.value}`}
                                  >
                                    <span className="text-sm font-medium block">{option.label}</span>
                                    <span className="text-xs text-muted-foreground">{option.subtitle}</span>
                                  </div>
                                );
                              })}
                            </div>
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <div className="flex items-center gap-3 justify-between pt-2">
                      <Button
                        type="button"
                        variant="ghost"
                        onClick={() => setCurrentStep(1)}
                        data-testid="button-step2-back"
                      >
                        <ChevronLeft className="w-4 h-4 mr-1" />
                        Back
                      </Button>
                      <Button
                        type="submit"
                        disabled={updateMutation.isPending}
                        data-testid="button-step2-next"
                      >
                        {updateMutation.isPending ? (
                          <Loader2 className="w-4 h-4 animate-spin mr-2" />
                        ) : null}
                        Next
                        <ChevronRight className="w-4 h-4 ml-1" />
                      </Button>
                    </div>
                  </form>
                </Form>
              </CardContent>
            </>
          )}

          {currentStep === 3 && (
            <>
              <CardHeader>
                <CardTitle data-testid="text-step3-title">Your Location</CardTitle>
              </CardHeader>
              <CardContent>
                <Form {...locationForm}>
                  <form
                    onSubmit={locationForm.handleSubmit(handleStep3Next)}
                    className="space-y-4"
                    data-testid="form-location"
                  >
                    <Button
                      type="button"
                      variant="outline"
                      className="w-full"
                      onClick={handleDetectLocation}
                      disabled={detectingLocation}
                      data-testid="button-detect-location"
                    >
                      {detectingLocation ? (
                        <Loader2 className="w-4 h-4 animate-spin mr-2" />
                      ) : (
                        <Navigation className="w-4 h-4 mr-2" />
                      )}
                      {detectingLocation ? "Detecting..." : "Detect My Location"}
                    </Button>
                    <FormField
                      control={locationForm.control}
                      name="country"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Country</FormLabel>
                          <Select
                            onValueChange={(val) => {
                              field.onChange(val);
                              locationForm.setValue("city", "");
                            }}
                            value={field.value}
                          >
                            <FormControl>
                              <SelectTrigger data-testid="select-country">
                                <SelectValue placeholder="Select your country" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              {COUNTRIES.map((c) => (
                                <SelectItem key={c.value} value={c.value} data-testid={`option-country-${c.value}`}>
                                  {c.label}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={locationForm.control}
                      name="city"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>City</FormLabel>
                          <Select
                            onValueChange={field.onChange}
                            value={field.value}
                            disabled={!selectedCountry}
                          >
                            <FormControl>
                              <SelectTrigger data-testid="select-city">
                                <SelectValue placeholder={selectedCountry ? "Select your city" : "Select a country first"} />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              {(CITIES_BY_COUNTRY[selectedCountry] || []).map((city) => (
                                <SelectItem key={city} value={city} data-testid={`option-city-${city}`}>
                                  {city}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={locationForm.control}
                      name="address"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Address (optional)</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="Street address"
                              data-testid="input-address"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <div className="flex items-center gap-3 justify-between pt-2">
                      <Button
                        type="button"
                        variant="ghost"
                        onClick={() => setCurrentStep(2)}
                        data-testid="button-step3-back"
                      >
                        <ChevronLeft className="w-4 h-4 mr-1" />
                        Back
                      </Button>
                      <Button
                        type="submit"
                        disabled={updateMutation.isPending}
                        data-testid="button-complete-setup"
                      >
                        {updateMutation.isPending ? (
                          <Loader2 className="w-4 h-4 animate-spin mr-2" />
                        ) : null}
                        <Check className="w-4 h-4 mr-1" />
                        Complete Setup
                      </Button>
                    </div>
                  </form>
                </Form>
              </CardContent>
            </>
          )}
        </Card>
      </div>
    </div>
  );
}


========================================
FILE: client/src/pages/personality-test-page.tsx
========================================
import { useState, useEffect } from "react";
import { useMutation } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { ArrowLeft, Brain, Loader2 } from "lucide-react";

interface OceanScores {
  openness: number;
  conscientiousness: number;
  extraversion: number;
  agreeableness: number;
  neuroticism: number;
}

const TRAITS = [
  {
    id: "openness",
    label: "Openness",
    description: "Creativity, curiosity, and openness to new experiences",
    key: "openness" as const,
  },
  {
    id: "conscientiousness",
    label: "Conscientiousness",
    description: "Organization, dependability, and self-discipline",
    key: "conscientiousness" as const,
  },
  {
    id: "extraversion",
    label: "Extraversion",
    description: "Sociability, assertiveness, and positive emotions",
    key: "extraversion" as const,
  },
  {
    id: "agreeableness",
    label: "Agreeableness",
    description: "Cooperation, trust, and consideration for others",
    key: "agreeableness" as const,
  },
  {
    id: "neuroticism",
    label: "Neuroticism",
    description: "Emotional sensitivity and tendency to experience stress",
    key: "neuroticism" as const,
  },
];

function calculateDaysRemaining(lastTaken: string | null): number | null {
  if (!lastTaken) return null;
  const lastDate = new Date(lastTaken);
  const now = new Date();
  const daysPassed = Math.floor((now.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24));
  const daysRemaining = 90 - daysPassed;
  return daysRemaining > 0 ? daysRemaining : null;
}

export default function PersonalityTestPage() {
  const [, setLocation] = useLocation();
  const { user, isLoading: authLoading } = useAuth();
  const { toast } = useToast();
  const [scores, setScores] = useState<OceanScores>({
    openness: 50,
    conscientiousness: 50,
    extraversion: 50,
    agreeableness: 50,
    neuroticism: 50,
  });

  useEffect(() => {
    if (user) {
      setScores({
        openness: user.oceanOpenness ?? 50,
        conscientiousness: user.oceanConscientiousness ?? 50,
        extraversion: user.oceanExtraversion ?? 50,
        agreeableness: user.oceanAgreeableness ?? 50,
        neuroticism: user.oceanNeuroticism ?? 50,
      });
    }
  }, [user]);

  const daysRemaining = user?.oceanLastTaken ? calculateDaysRemaining(user.oceanLastTaken) : null;
  const canRetakeTTest = daysRemaining === null;

  const testMutation = useMutation({
    mutationFn: async (testScores: OceanScores) => {
      const res = await apiRequest("POST", "/api/personality/test", testScores);
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      toast({
        title: "Test Completed",
        description: "Your OCEAN personality results have been saved.",
      });
      setLocation("/profile");
    },
    onError: (error) => {
      toast({
        title: "Test Failed",
        description: error instanceof Error ? error.message : "Failed to submit test results",
        variant: "destructive",
      });
    },
  });

  if (authLoading || !user) {
    return (
      <div className="min-h-screen bg-background p-4">
        <div className="max-w-lg mx-auto space-y-4">
          <Skeleton className="h-12 w-24 rounded-md" />
          <Skeleton className="h-32 w-full rounded-md" />
          <Skeleton className="h-40 w-full rounded-md" />
        </div>
      </div>
    );
  }

  const handleScoreChange = (trait: keyof OceanScores, value: number) => {
    setScores((prev) => ({
      ...prev,
      [trait]: value,
    }));
  };

  const handleSubmit = () => {
    testMutation.mutate(scores);
  };

  return (
    <div className="min-h-screen bg-background text-foreground p-4 pb-28">
      <div className="max-w-lg mx-auto space-y-4">
        {/* Header */}
        <div className="flex items-center gap-3">
          <Button
            variant="ghost"
            size="icon"
            onClick={() => setLocation("/profile")}
            data-testid="button-back"
          >
            <ArrowLeft className="h-5 w-5" />
          </Button>
          <div className="flex-1">
            <div className="flex items-center gap-2">
              <Brain className="h-5 w-5 text-primary" />
              <h1 className="text-xl font-semibold">Personality Test</h1>
            </div>
            <p className="text-sm text-muted-foreground">OCEAN Model Assessment</p>
          </div>
        </div>

        {/* Cooldown Notice */}
        {!canRetakeTTest && daysRemaining !== null && (
          <Card className="bg-muted/50">
            <CardContent className="p-4">
              <p className="text-sm text-muted-foreground">
                You can retake this test in <span className="font-semibold">{daysRemaining} days</span>.
              </p>
              <p className="text-xs text-muted-foreground mt-1">
                Last taken: {new Date(user.oceanLastTaken!).toLocaleDateString()}
              </p>
            </CardContent>
          </Card>
        )}

        {/* Traits */}
        <div className="space-y-3">
          {TRAITS.map((trait) => (
            <Card key={trait.id}>
              <CardContent className="p-4">
                <div className="space-y-3">
                  <div>
                    <div className="flex items-center justify-between mb-1">
                      <label className="text-sm font-semibold">{trait.label}</label>
                      <span
                        className="text-sm font-semibold text-primary"
                        data-testid={`text-${trait.id}-score`}
                      >
                        {scores[trait.key]}
                      </span>
                    </div>
                    <p className="text-xs text-muted-foreground">{trait.description}</p>
                  </div>

                  <input
                    type="range"
                    min="0"
                    max="100"
                    value={scores[trait.key]}
                    onChange={(e) => handleScoreChange(trait.key, parseInt(e.target.value))}
                    disabled={!canRetakeTTest}
                    className="w-full accent-primary cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed"
                    data-testid={`slider-${trait.id}`}
                  />

                  <div className="flex justify-between text-xs text-muted-foreground">
                    <span>Low</span>
                    <span>High</span>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>

        {/* Summary */}
        <Card className="bg-muted/50">
          <CardContent className="p-4">
            <h3 className="text-sm font-semibold mb-2">Your Scores</h3>
            <div className="grid grid-cols-2 gap-2 text-sm">
              {TRAITS.map((trait) => (
                <div key={trait.id} className="flex justify-between">
                  <span className="text-muted-foreground">{trait.label}:</span>
                  <span className="font-semibold">{scores[trait.key]}</span>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>

        {/* Action Button */}
        <Button
          onClick={handleSubmit}
          disabled={testMutation.isPending || !canRetakeTTest}
          className="w-full"
          data-testid="button-submit-personality"
        >
          {testMutation.isPending ? (
            <>
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              Submitting...
            </>
          ) : !canRetakeTTest ? (
            "Test Already Taken"
          ) : (
            "Submit Test Results"
          )}
        </Button>
      </div>
    </div>
  );
}


========================================
FILE: client/src/pages/map-page.tsx
========================================
import "leaflet/dist/leaflet.css";
import { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { MapContainer, TileLayer, Marker, Popup } from "react-leaflet";
import L from "leaflet";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { ArrowLeft, MapPin, Loader2 } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import type { Party, Business } from "@shared/schema";
import { format } from "date-fns";

interface MapData {
  parties: Party[];
  businesses: Business[];
}

const DEFAULT_CENTER: [number, number] = [40.7128, -74.0060];

function createPartyMarkerIcon() {
  return L.divIcon({
    html: `
      <svg width="32" height="40" viewBox="0 0 32 40" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M16 0C7.16 0 0 7.16 0 16c0 5.25 3.07 9.8 7.52 11.98C8.34 33.5 11.87 40 16 40c4.13 0 7.66 6.5 8.48 12.02C28.93 25.8 32 21.25 32 16c0-8.84-7.16-16-16-16z" 
              fill="hsl(var(--primary))" />
        <circle cx="16" cy="14" r="5" fill="white" />
      </svg>
    `,
    className: "party-marker",
    iconSize: [32, 40],
    iconAnchor: [16, 40],
    popupAnchor: [0, -40],
  });
}

function createBusinessMarkerIcon() {
  return L.divIcon({
    html: `
      <svg width="32" height="40" viewBox="0 0 32 40" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M16 0C7.16 0 0 7.16 0 16c0 5.25 3.07 9.8 7.52 11.98C8.34 33.5 11.87 40 16 40c4.13 0 7.66 6.5 8.48 12.02C28.93 25.8 32 21.25 32 16c0-8.84-7.16-16-16-16z" 
              fill="hsl(180, 70%, 50%)" />
        <rect x="10" y="10" width="12" height="12" fill="white" rx="1" />
      </svg>
    `,
    className: "business-marker",
    iconSize: [32, 40],
    iconAnchor: [16, 40],
    popupAnchor: [0, -40],
  });
}

function formatPartyDate(dateStr: string) {
  try {
    return format(new Date(dateStr), "MMM d, h:mm a");
  } catch {
    return dateStr;
  }
}

function MapLoadingSkeleton() {
  return (
    <div className="w-full h-[calc(100vh-60px)] flex flex-col">
      <div className="p-3 bg-background border-b flex items-center gap-2">
        <Skeleton className="h-9 w-9 rounded" />
        <Skeleton className="h-5 w-32" />
      </div>
      <Skeleton className="flex-1" />
    </div>
  );
}

interface PartyPopupProps {
  party: Party;
  onViewParty: (id: string) => void;
}

function PartyPopupContent({ party, onViewParty }: PartyPopupProps) {
  return (
    <div className="space-y-2 w-64">
      <h3 className="font-semibold text-sm" data-testid={`popup-title-${party.id}`}>
        {party.title}
      </h3>
      <div className="text-xs text-muted-foreground space-y-1">
        <div>
          <span className="font-medium">Theme:</span> {party.theme}
        </div>
        <div>
          <span className="font-medium">When:</span> {formatPartyDate(party.date)}
        </div>
        <div>
          <span className="font-medium">Status:</span> {party.status}
        </div>
        <div>
          <span className="font-medium">Location:</span> {party.city}
        </div>
      </div>
      <Button
        size="sm"
        className="w-full"
        onClick={() => onViewParty(party.id)}
        data-testid={`button-view-party-${party.id}`}
      >
        View Party
      </Button>
    </div>
  );
}

interface BusinessPopupProps {
  business: Business;
}

function BusinessPopupContent({ business }: BusinessPopupProps) {
  return (
    <div className="space-y-1 w-48">
      <h3 className="font-semibold text-sm" data-testid={`popup-business-${business.id}`}>
        {business.name}
      </h3>
      <div className="text-xs text-muted-foreground">
        <div>
          <span className="font-medium">Category:</span> {business.category}
        </div>
        <div>
          <span className="font-medium">Location:</span> {business.city}
        </div>
      </div>
    </div>
  );
}

export default function MapPage() {
  const { user } = useAuth();
  const [, setLocation] = useLocation();
  const [center, setCenter] = useState<[number, number]>(DEFAULT_CENTER);
  const [geolocating, setGeolocating] = useState(true);
  const [mapReady, setMapReady] = useState(false);

  useEffect(() => {
    if (!navigator.geolocation) {
      setGeolocating(false);
      setMapReady(true);
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const { latitude, longitude } = pos.coords;
        setCenter([latitude, longitude]);
        setGeolocating(false);
        setMapReady(true);
      },
      () => {
        setGeolocating(false);
        setMapReady(true);
      },
      { enableHighAccuracy: false, timeout: 5000 }
    );
  }, []);

  const { data: mapData, isLoading } = useQuery<MapData>({
    queryKey: ["/api/map", center[0], center[1]],
    queryFn: async () => {
      const res = await fetch(
        `/api/map?lat=${center[0]}&lng=${center[1]}&radius=50`,
        { credentials: "include" }
      );
      if (!res.ok) throw new Error("Failed to fetch map data");
      return res.json();
    },
    enabled: mapReady,
  });

  const handleViewParty = (id: string) => {
    setLocation(`/party/${id}`);
  };

  const handleBack = () => {
    setLocation("/browse");
  };

  if (geolocating || !mapReady || isLoading) {
    return <MapLoadingSkeleton />;
  }

  return (
    <div className="w-full h-[calc(100vh-60px)] flex flex-col bg-background" data-testid="map-page">
      <div className="p-3 bg-background border-b flex items-center gap-2">
        <Button
          variant="outline"
          size="icon"
          onClick={handleBack}
          data-testid="button-back-map"
        >
          <ArrowLeft className="h-4 w-4" />
        </Button>
        <div className="flex items-center gap-1.5 text-sm font-medium">
          <MapPin className="h-4 w-4" />
          <span>Nearby Parties & Venues</span>
        </div>
      </div>

      <MapContainer
        center={center}
        zoom={13}
        style={{ height: "100%", width: "100%" }}
        data-testid="map-container"
      >
        <TileLayer
          url="https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png"
          attribution="&copy; OpenStreetMap contributors"
        />

        {mapData?.parties.map((party) => (
          <Marker
            key={`party-${party.id}`}
            position={[party.latitude, party.longitude]}
            icon={createPartyMarkerIcon()}
            data-testid={`marker-party-${party.id}`}
          >
            <Popup data-testid={`popup-party-${party.id}`}>
              <PartyPopupContent party={party} onViewParty={handleViewParty} />
            </Popup>
          </Marker>
        ))}

        {mapData?.businesses.map((business) => (
          <Marker
            key={`business-${business.id}`}
            position={[business.latitude, business.longitude]}
            icon={createBusinessMarkerIcon()}
            data-testid={`marker-business-${business.id}`}
          >
            <Popup data-testid={`popup-business-${business.id}`}>
              <BusinessPopupContent business={business} />
            </Popup>
          </Marker>
        ))}
      </MapContainer>
    </div>
  );
}


========================================
FILE: client/src/pages/legal-page.tsx
========================================
import { useQuery } from "@tanstack/react-query";
import { useRoute } from "wouter";
import { Link } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { ArrowLeft } from "lucide-react";

const TITLES: Record<string, string> = {
  terms: "Terms of Service",
  privacy: "Privacy Policy",
  eula: "End User License Agreement",
};

export default function LegalPage() {
  const [, params] = useRoute("/legal/:type");
  const type = params?.type ?? "terms";

  const { data, isLoading, isError } = useQuery<{ content: string }>({
    queryKey: ["/api/legal", type],
  });

  return (
    <div className="min-h-screen bg-background pb-12">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-3xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/auth">
            <Button variant="ghost" size="icon" data-testid="button-back">
              <ArrowLeft className="h-4 w-4" />
            </Button>
          </Link>
          <h1 className="text-lg font-semibold" data-testid="text-legal-title">
            {TITLES[type] || "Legal"}
          </h1>
        </div>
      </header>

      <main className="max-w-3xl mx-auto px-4 py-6">
        {isLoading ? (
          <Card>
            <CardContent className="p-6 space-y-4">
              <Skeleton className="h-6 w-1/3" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-5/6" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-2/3" />
            </CardContent>
          </Card>
        ) : isError ? (
          <Card>
            <CardContent className="p-6 text-center">
              <p className="text-muted-foreground" data-testid="text-legal-error">
                Failed to load content. Please try again later.
              </p>
            </CardContent>
          </Card>
        ) : (
          <Card>
            <CardContent className="p-6">
              <div
                className="prose prose-sm dark:prose-invert max-w-none whitespace-pre-wrap"
                data-testid="text-legal-content"
              >
                {data?.content}
              </div>
            </CardContent>
          </Card>
        )}
      </main>
    </div>
  );
}


========================================
FILE: client/src/pages/not-found.tsx
========================================
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}

