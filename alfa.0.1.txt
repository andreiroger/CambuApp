=== CambuApp alfa 0.1 - Source Code Export ===
Generated: Mon Feb  9 09:25:28 PM UTC 2026

========================================
FILE: shared/schema.ts
========================================
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, integer, boolean, real, uniqueIndex, index } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  fullName: text("full_name").notNull(),
  nickname: text("nickname"),
  avatar: text("avatar").default(""),
  bio: text("bio").default(""),
  isIdVerified: boolean("is_id_verified").default(false),
  isAgeVerified: boolean("is_age_verified").default(false),
  idDocumentUrl: text("id_document_url").default(""),
  dob: text("dob"),
  email: text("email").notNull(),
  phone: text("phone").default(""),
  country: text("country").default(""),
  city: text("city").default(""),
  address: text("address").default(""),
  latitude: real("latitude"),
  longitude: real("longitude"),
  hostRating: real("host_rating").default(0),
  guestRating: real("guest_rating").default(0),
  notificationsEnabled: boolean("notifications_enabled").default(true),
  darkMode: boolean("dark_mode").default(false),
  searchRadius: integer("search_radius").default(50),
  preferredVibe: text("preferred_vibe").default(""),
  gatheringSizePref: text("gathering_size_pref").default(""),
  hostOrGuest: text("host_or_guest").default(""),
  agreedToTerms: boolean("agreed_to_terms").default(false),
  isBanned: boolean("is_banned").default(false),
  isAdmin: boolean("is_admin").default(false),
  onboardingComplete: boolean("onboarding_complete").default(false),
}, (table) => [
  index("users_city_idx").on(table.city),
  index("users_country_idx").on(table.country),
]);

export const parties = pgTable("parties", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  hostId: varchar("host_id").notNull().references(() => users.id),
  title: text("title").notNull(),
  theme: text("theme").notNull(),
  description: text("description").notNull(),
  date: text("date").notNull(),
  locationName: text("location_name").notNull(),
  city: text("city").notNull(),
  country: text("country").notNull(),
  exactAddress: text("exact_address"),
  latitude: real("latitude").notNull(),
  longitude: real("longitude").notNull(),
  maxGuests: integer("max_guests").notNull(),
  price: integer("price").default(0),
  whatToBring: text("what_to_bring").array().default(sql`'{}'::text[]`),
  imageUrl: text("image_url").default(""),
  galleryUrls: text("gallery_urls").array().default(sql`'{}'::text[]`),
  includesAlcohol: boolean("includes_alcohol").default(false),
  createdAt: text("created_at").default(sql`now()`),
  status: text("status").notNull().default("upcoming"),
  houseRules: text("house_rules").default(""),
  targetGuests: text("target_guests").default(""),
  vibe: text("vibe").default(""),
}, (table) => [
  index("parties_host_id_idx").on(table.hostId),
  index("parties_city_idx").on(table.city),
  index("parties_status_idx").on(table.status),
  index("parties_date_idx").on(table.date),
]);

export const partyAttendees = pgTable("party_attendees", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  partyId: varchar("party_id").notNull().references(() => parties.id),
  userId: varchar("user_id").notNull().references(() => users.id),
}, (table) => [
  uniqueIndex("party_user_unique").on(table.partyId, table.userId),
  index("attendees_party_id_idx").on(table.partyId),
  index("attendees_user_id_idx").on(table.userId),
]);

export const partyRequests = pgTable("party_requests", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  partyId: varchar("party_id").notNull().references(() => parties.id),
  userId: varchar("user_id").notNull().references(() => users.id),
  message: text("message").default(""),
  pledgedItems: text("pledged_items").default(""),
  status: text("status").notNull().default("pending"),
}, (table) => [
  index("requests_party_id_idx").on(table.partyId),
  index("requests_user_id_idx").on(table.userId),
  index("requests_status_idx").on(table.status),
]);

export const reviews = pgTable("reviews", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  authorId: varchar("author_id").notNull().references(() => users.id),
  targetId: varchar("target_id").notNull().references(() => users.id),
  partyId: varchar("party_id").references(() => parties.id),
  content: text("content").notNull(),
  rating: integer("rating").notNull(),
  type: text("type").notNull(),
  createdAt: text("created_at").default(sql`now()`),
}, (table) => [
  index("reviews_target_id_idx").on(table.targetId),
  index("reviews_author_id_idx").on(table.authorId),
]);

export const insertUserSchema = createInsertSchema(users).omit({ id: true });
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

export const insertPartySchema = createInsertSchema(parties).omit({ id: true, createdAt: true });
export type InsertParty = z.infer<typeof insertPartySchema>;
export type Party = typeof parties.$inferSelect;

export const insertPartyAttendeeSchema = createInsertSchema(partyAttendees).omit({ id: true });
export type InsertPartyAttendee = z.infer<typeof insertPartyAttendeeSchema>;
export type PartyAttendee = typeof partyAttendees.$inferSelect;

export const insertPartyRequestSchema = createInsertSchema(partyRequests).omit({ id: true });
export type InsertPartyRequest = z.infer<typeof insertPartyRequestSchema>;
export type PartyRequest = typeof partyRequests.$inferSelect;

export const insertReviewSchema = createInsertSchema(reviews).omit({ id: true, createdAt: true });
export type InsertReview = z.infer<typeof insertReviewSchema>;
export type Review = typeof reviews.$inferSelect;

export const updateUserSchema = createInsertSchema(users).omit({ id: true }).partial();
export type UpdateUser = z.infer<typeof updateUserSchema>;

export const updatePartySchema = createInsertSchema(parties).omit({ id: true, createdAt: true }).partial();
export type UpdateParty = z.infer<typeof updatePartySchema>;

export const updateRequestStatusSchema = z.object({
  status: z.enum(["accepted", "declined"]),
});

========================================
FILE: server/routes.ts
========================================
import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import session from "express-session";
import MemoryStore from "memorystore";
import { insertUserSchema, insertPartySchema, updateUserSchema, updatePartySchema, updateRequestStatusSchema } from "@shared/schema";
import bcrypt from "bcrypt";
import multer from "multer";
import rateLimit from "express-rate-limit";
const PROFANITY_LIST = [
  "ass", "asshole", "bastard", "bitch", "bullshit", "cock", "crap", "cunt",
  "damn", "dick", "fuck", "fucking", "goddamn", "hell", "motherfucker",
  "nigger", "nigga", "piss", "prick", "pussy", "shit", "slut", "whore",
  "wanker", "twat", "bollocks", "arse", "arsehole", "bellend", "bloody",
  "bugger", "chink", "fag", "faggot", "retard", "retarded", "spic", "kike"
];

class ProfanityFilter {
  private words: Set<string>;
  constructor() {
    this.words = new Set(PROFANITY_LIST.map(w => w.toLowerCase()));
  }
  clean(text: string): string {
    if (!text) return text;
    return text.replace(/\b\w+\b/g, (word) => {
      if (this.words.has(word.toLowerCase())) {
        return "*".repeat(word.length);
      }
      return word;
    });
  }
}

const profanityFilter = new ProfanityFilter();
import express from "express";
import path from "path";
import fs from "fs";

declare module "express-session" {
  interface SessionData {
    userId: string;
  }
}

const SessionStore = MemoryStore(session);

function cleanText(text: string | undefined | null): string {
  if (!text) return text as string;
  try {
    return profanityFilter.clean(text);
  } catch {
    return text;
  }
}

function haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

async function updatePartyStatuses() {
  try {
    const allParties = await storage.getAllParties();
    const now = new Date();
    const twoHoursFromNow = new Date(now.getTime() + 2 * 60 * 60 * 1000);

    for (const party of allParties) {
      const partyDate = new Date(party.date);

      if (party.status !== "finished" && partyDate < now) {
        await storage.updateParty(party.id, { status: "finished" });
        const requests = await storage.getPartyRequests(party.id);
        for (const req of requests) {
          if (req.status === "pending") {
            await storage.updateRequestStatus(req.id, "cancelled");
          }
        }
        console.log(`[LIFECYCLE] Party "${party.title}" (${party.id}) marked as finished`);
      } else if (party.status === "upcoming" && partyDate <= twoHoursFromNow && partyDate >= now) {
        await storage.updateParty(party.id, { status: "ongoing" });
        console.log(`[LIFECYCLE] Party "${party.title}" (${party.id}) marked as ongoing`);
      }
    }
  } catch (error) {
    console.error("[LIFECYCLE] Error updating party statuses:", error);
  }
}

const partyImageStorage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    const dir = "uploads/parties";
    fs.mkdirSync(dir, { recursive: true });
    cb(null, dir);
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const avatarStorage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    const dir = "uploads/avatars";
    fs.mkdirSync(dir, { recursive: true });
    cb(null, dir);
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const idDocStorage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    const dir = "uploads/ids";
    fs.mkdirSync(dir, { recursive: true });
    cb(null, dir);
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const imageFileFilter = (_req: any, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ["image/jpeg", "image/png", "image/webp"];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error("Only JPG, PNG, and WebP images are allowed"));
  }
};

const uploadPartyImage = multer({
  storage: partyImageStorage,
  limits: { fileSize: 5 * 1024 * 1024 },
  fileFilter: imageFileFilter,
});

const uploadAvatar = multer({
  storage: avatarStorage,
  limits: { fileSize: 5 * 1024 * 1024 },
  fileFilter: imageFileFilter,
});

const uploadIdDoc = multer({
  storage: idDocStorage,
  limits: { fileSize: 10 * 1024 * 1024 },
  fileFilter: imageFileFilter,
});

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: { message: "Too many authentication attempts, please try again later" },
  standardHeaders: true,
  legacyHeaders: false,
});

const requestCreationLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 10,
  message: { message: "Too many party requests, please try again later" },
  standardHeaders: true,
  legacyHeaders: false,
});

const generalApiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: { message: "Too many requests, please try again later" },
  standardHeaders: true,
  legacyHeaders: false,
});

const TERMS_OF_SERVICE = `CambuApp - Terms of Service

Last Updated: February 2026

Welcome to CambuApp. By accessing or using our platform, you agree to be bound by these Terms of Service ("Terms"). Please read them carefully before using the application.

1. ACCEPTANCE OF TERMS

By creating an account, accessing, or using CambuApp ("the Platform," "the Service"), you acknowledge that you have read, understood, and agree to be bound by these Terms of Service. If you do not agree to these Terms, you must not use the Platform.

2. ELIGIBILITY AND AGE VERIFICATION

2.1. You must be at least 18 years of age to create an account and use CambuApp.
2.2. CambuApp reserves the right to require age verification through government-issued identification documents at any time.
2.3. By using the Platform, you represent and warrant that you are at least 18 years old and have the legal capacity to enter into these Terms.
2.4. CambuApp may use automated or manual verification processes to confirm your age and identity. Providing false identification information is strictly prohibited and will result in immediate account termination.

3. USER ACCOUNTS

3.1. You are responsible for maintaining the confidentiality of your account credentials.
3.2. You agree to provide accurate, current, and complete information during registration and to update such information to keep it accurate and complete.
3.3. You are solely responsible for all activities that occur under your account.
3.4. CambuApp reserves the right to suspend or terminate accounts that violate these Terms or engage in suspicious activity.
3.5. You may not create multiple accounts or transfer your account to another person.

4. PARTY HOSTING RULES

4.1. Hosts are solely responsible for ensuring their events comply with all applicable local, state, and federal laws and regulations, including but not limited to noise ordinances, occupancy limits, alcohol licensing requirements, and fire safety codes.
4.2. Hosts must accurately describe their events, including location, date, time, expected attendance, and any costs or requirements.
4.3. Hosts are responsible for the safety and well-being of their guests during the event.
4.4. Hosts must not discriminate against guests based on race, color, religion, sex, national origin, disability, sexual orientation, gender identity, or any other protected characteristic.
4.5. Hosts are responsible for obtaining any necessary permits or permissions for their events.
4.6. Events involving alcohol must comply with all applicable alcohol laws. Hosts must ensure that no alcoholic beverages are served to individuals under the legal drinking age.

5. CODE OF CONDUCT

5.1. Users must treat all other users with respect and courtesy.
5.2. The following behaviors are strictly prohibited:
   a. Harassment, bullying, intimidation, or threatening behavior
   b. Discrimination or hate speech of any kind
   c. Sharing explicit, obscene, or offensive content
   d. Engaging in or promoting illegal activities
   e. Spamming, phishing, or other deceptive practices
   f. Impersonating another person or entity
   g. Posting false or misleading information about events
   h. Engaging in any form of fraud or deception
5.3. Users who violate the Code of Conduct may have their accounts suspended or permanently banned at CambuApp's sole discretion.

6. CONTENT AND INTELLECTUAL PROPERTY

6.1. Users retain ownership of content they create and share on the Platform.
6.2. By posting content on CambuApp, you grant the Platform a non-exclusive, worldwide, royalty-free license to use, display, reproduce, and distribute such content in connection with the Service.
6.3. You represent and warrant that you have all necessary rights to post any content you share on the Platform.
6.4. CambuApp reserves the right to remove any content that violates these Terms or is deemed inappropriate at its sole discretion.

7. LIABILITY AND DISCLAIMERS

7.1. CambuApp is a platform that facilitates connections between party hosts and guests. CambuApp is not responsible for the actions, conduct, or behavior of any user at any event.
7.2. CambuApp does not guarantee the safety, quality, legality, or suitability of any event listed on the Platform.
7.3. Users attend events at their own risk. CambuApp shall not be liable for any injuries, damages, losses, or claims arising from attendance at any event.
7.4. THE PLATFORM IS PROVIDED "AS IS" AND "AS AVAILABLE" WITHOUT WARRANTIES OF ANY KIND, EXPRESS OR IMPLIED.
7.5. IN NO EVENT SHALL CAMBUAPP BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES ARISING OUT OF OR RELATED TO YOUR USE OF THE PLATFORM.
7.6. CambuApp's total liability for any claims arising from or related to the Service shall not exceed the amount paid by you to CambuApp in the twelve (12) months preceding the claim.

8. PAYMENTS AND FEES

8.1. Some events may require payment. CambuApp may facilitate payment processing but is not responsible for refunds or disputes between hosts and guests.
8.2. CambuApp reserves the right to charge service fees for the use of certain features.
8.3. All fees are non-refundable unless otherwise stated.

9. TERMINATION

9.1. You may terminate your account at any time by contacting CambuApp support.
9.2. CambuApp reserves the right to suspend or terminate your account at any time, with or without cause, and with or without notice.
9.3. Upon termination, your right to use the Platform will immediately cease. Sections of these Terms that by their nature should survive termination shall survive.

10. GOVERNING LAW

10.1. These Terms shall be governed by and construed in accordance with applicable law, without regard to conflict of law principles.
10.2. Any disputes arising from these Terms or the use of the Platform shall be resolved through binding arbitration.

11. CHANGES TO TERMS

CambuApp reserves the right to modify these Terms at any time. We will notify users of material changes through the Platform. Your continued use of the Service after such modifications constitutes your acceptance of the updated Terms.

12. CONTACT

For questions about these Terms, please contact us through the CambuApp support channels within the application.`;

const PRIVACY_POLICY = `CambuApp - Privacy Policy

Last Updated: February 2026

CambuApp ("we," "our," or "us") is committed to protecting your privacy. This Privacy Policy explains how we collect, use, disclose, and safeguard your information when you use our mobile application and related services (collectively, the "Service").

1. INFORMATION WE COLLECT

1.1. Personal Information You Provide:
   - Account registration information (name, email address, phone number, date of birth)
   - Profile information (bio, profile photo, preferences, city, country)
   - Event-related information (party details, descriptions, locations)
   - Communications (messages between users, party requests, reviews)
   - Payment information (if applicable, processed through secure third-party payment processors)

1.2. Information Collected Automatically:
   - Device information (device type, operating system, unique device identifiers)
   - Log data (IP address, browser type, pages visited, time spent)
   - Usage data (features used, interactions, preferences)

2. LOCATION DATA

2.1. CambuApp collects and processes location data to provide location-based party discovery and filtering.
2.2. We collect:
   - Location coordinates you provide when creating events
   - Your general location for discovering nearby events (when you grant permission)
   - City and country information from your profile
2.3. Location data is used to:
   - Show you events near your location
   - Enable location-based search and filtering
   - Provide distance calculations to event venues
2.4. You can control location sharing through your device settings. Disabling location access may limit certain features of the Service.

3. IDENTITY DOCUMENTS AND AGE VERIFICATION

3.1. CambuApp may collect identity documents (government-issued ID, passport, or driver's license) for the purpose of age verification and identity confirmation.
3.2. Identity documents are:
   - Stored securely using industry-standard encryption
   - Used solely for verification purposes
   - Not shared with other users or third parties except as required by law
   - Retained only for as long as necessary to complete the verification process and maintain compliance records
3.3. By submitting identity documents, you consent to our processing of this sensitive information for verification purposes.

4. HOW WE USE YOUR INFORMATION

4.1. We use the information we collect to:
   - Provide, maintain, and improve the Service
   - Create and manage your account
   - Facilitate party discovery, hosting, and attendance
   - Process and manage party requests
   - Enable communication between hosts and guests
   - Verify your identity and age
   - Send notifications about events, requests, and account activity
   - Enforce our Terms of Service and Community Guidelines
   - Detect and prevent fraud, abuse, and security incidents
   - Analyze usage patterns to improve the user experience
   - Comply with legal obligations

5. INFORMATION SHARING AND DISCLOSURE

5.1. We may share your information in the following circumstances:
   - With other users as necessary for the Service (e.g., your profile information visible to party hosts)
   - With service providers who perform services on our behalf
   - In response to legal process or government requests
   - To protect the rights, property, or safety of CambuApp, our users, or others
   - In connection with a merger, acquisition, or sale of assets
5.2. We do not sell your personal information to third parties.

6. COOKIES AND TRACKING TECHNOLOGIES

6.1. CambuApp uses session cookies to maintain your login state and provide a seamless experience.
6.2. We may use analytics tools to understand how users interact with the Service.
6.3. You can control cookie preferences through your browser or device settings.

7. DATA SECURITY

7.1. We implement appropriate technical and organizational measures to protect your personal information against unauthorized access, alteration, disclosure, or destruction.
7.2. These measures include:
   - Encryption of sensitive data in transit and at rest
   - Secure password hashing using industry-standard algorithms
   - Regular security assessments and updates
   - Access controls limiting data access to authorized personnel
7.3. No method of transmission over the Internet or electronic storage is 100% secure. While we strive to protect your information, we cannot guarantee absolute security.

8. DATA RETENTION

8.1. We retain your personal information for as long as your account is active or as needed to provide the Service.
8.2. We may retain certain information after account deletion for legitimate business purposes, including legal compliance, dispute resolution, and enforcement of our agreements.
8.3. Identity verification documents are retained for the minimum period required by applicable law.

9. YOUR RIGHTS AND CHOICES

9.1. Depending on your jurisdiction, you may have the right to:
   - Access your personal information
   - Correct inaccurate information
   - Delete your account and personal information
   - Object to or restrict certain processing of your information
   - Data portability (receive your data in a structured, commonly used format)
   - Withdraw consent where processing is based on consent
9.2. To exercise these rights, please contact us through the CambuApp support channels.

10. CHILDREN'S PRIVACY

10.1. CambuApp is not intended for individuals under 18 years of age.
10.2. We do not knowingly collect personal information from children under 18.
10.3. If we learn that we have collected personal information from a child under 18, we will take steps to delete such information promptly.

11. INTERNATIONAL DATA TRANSFERS

11.1. Your information may be transferred to and processed in countries other than your country of residence.
11.2. We ensure appropriate safeguards are in place for international data transfers in compliance with applicable data protection laws.

12. CHANGES TO THIS PRIVACY POLICY

We may update this Privacy Policy from time to time. We will notify you of material changes through the Service or by other means. Your continued use of the Service after changes are posted constitutes your acceptance of the updated Privacy Policy.

13. CONTACT US

For questions or concerns about this Privacy Policy or our data practices, please contact us through the CambuApp support channels within the application.`;

const EULA_TEXT = `CambuApp - End User License Agreement (EULA)

Last Updated: February 2026

IMPORTANT: PLEASE READ THIS END USER LICENSE AGREEMENT ("AGREEMENT") CAREFULLY BEFORE USING CAMBUAPP. BY INSTALLING, ACCESSING, OR USING THE APPLICATION, YOU AGREE TO BE BOUND BY THE TERMS OF THIS AGREEMENT.

1. LICENSE GRANT

1.1. Subject to your compliance with this Agreement, CambuApp grants you a limited, non-exclusive, non-transferable, revocable license to:
   a. Download, install, and use the CambuApp application on your personal device(s)
   b. Access and use the CambuApp platform and its features for personal, non-commercial purposes
1.2. This license does not include the right to:
   a. Modify, adapt, translate, reverse engineer, decompile, or disassemble the application
   b. Create derivative works based on the application
   c. Copy, distribute, or publicly display the application or its content
   d. Use the application for any commercial purpose without prior written consent from CambuApp
   e. Remove, alter, or obscure any proprietary notices in the application

2. ACCOUNT AND ACCESS

2.1. To use CambuApp, you must create an account and provide accurate, complete information.
2.2. You are responsible for safeguarding your account credentials and for all activities that occur under your account.
2.3. You must notify CambuApp immediately of any unauthorized use of your account.
2.4. CambuApp reserves the right to disable any account at any time for any reason, including violation of this Agreement.

3. USER CONTENT

3.1. You are solely responsible for any content you create, upload, or share through the application, including but not limited to party descriptions, photos, reviews, and messages.
3.2. You warrant that any content you post does not infringe upon the intellectual property rights, privacy rights, or other rights of any third party.
3.3. CambuApp reserves the right to review, moderate, and remove any user content at its sole discretion.

4. RESTRICTIONS

4.1. You agree not to:
   a. Use the application for any unlawful purpose or in violation of any applicable laws
   b. Interfere with or disrupt the application's servers, networks, or infrastructure
   c. Attempt to gain unauthorized access to any portion of the application or its systems
   d. Use automated scripts, bots, or other means to interact with the application
   e. Harvest, collect, or store personal information of other users without their consent
   f. Use the application to transmit any malicious code, viruses, or harmful content
   g. Engage in any activity that could damage, disable, overburden, or impair the application
   h. Use the application to send unsolicited communications or spam
   i. Circumvent or attempt to circumvent any security features of the application
   j. Use the application in any manner that could interfere with other users' enjoyment of the Service

5. INTELLECTUAL PROPERTY

5.1. CambuApp and its entire contents, features, and functionality (including but not limited to software, text, graphics, logos, icons, images, audio, and video) are owned by CambuApp and are protected by copyright, trademark, patent, and other intellectual property laws.
5.2. The CambuApp name, logo, and all related names, logos, product and service names, designs, and slogans are trademarks of CambuApp. You may not use such marks without the prior written permission of CambuApp.

6. THIRD-PARTY SERVICES

6.1. The application may contain links to or integrate with third-party services, websites, or applications.
6.2. CambuApp is not responsible for the content, accuracy, or practices of any third-party services.
6.3. Your use of third-party services is governed by their respective terms and privacy policies.

7. DISCLAIMER OF WARRANTIES

7.1. THE APPLICATION IS PROVIDED "AS IS" AND "AS AVAILABLE" WITHOUT ANY WARRANTIES OF ANY KIND, WHETHER EXPRESS, IMPLIED, OR STATUTORY.
7.2. CAMBUAPP DISCLAIMS ALL WARRANTIES, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND THOSE ARISING FROM COURSE OF DEALING OR USAGE OF TRADE.
7.3. CAMBUAPP DOES NOT WARRANT THAT THE APPLICATION WILL BE UNINTERRUPTED, ERROR-FREE, SECURE, OR FREE OF VIRUSES OR OTHER HARMFUL COMPONENTS.

8. LIMITATION OF LIABILITY

8.1. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL CAMBUAPP BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS, DATA, USE, OR GOODWILL, ARISING OUT OF OR RELATED TO YOUR USE OF THE APPLICATION.
8.2. CAMBUAPP'S TOTAL LIABILITY FOR ALL CLAIMS ARISING FROM OR RELATED TO THIS AGREEMENT SHALL NOT EXCEED THE AMOUNT YOU PAID TO CAMBUAPP IN THE TWELVE (12) MONTHS PRECEDING THE CLAIM.

9. INDEMNIFICATION

9.1. You agree to indemnify, defend, and hold harmless CambuApp and its officers, directors, employees, agents, and affiliates from and against any claims, damages, losses, costs, and expenses (including reasonable attorneys' fees) arising from:
   a. Your use of the application
   b. Your violation of this Agreement
   c. Your violation of any rights of another party
   d. Any content you create or share through the application

10. TERMINATION

10.1. This Agreement is effective until terminated.
10.2. CambuApp may terminate this Agreement and your access to the application at any time, with or without cause, with or without notice.
10.3. You may terminate this Agreement by deleting your account and ceasing all use of the application.
10.4. Upon termination:
   a. All rights and licenses granted to you under this Agreement shall immediately cease
   b. You must immediately cease all use of the application
   c. CambuApp may delete your account and all associated data
10.5. Sections 5, 7, 8, 9, and 11 shall survive any termination of this Agreement.

11. GENERAL PROVISIONS

11.1. Governing Law: This Agreement shall be governed by applicable law without regard to its conflict of law provisions.
11.2. Severability: If any provision of this Agreement is found to be unenforceable, the remaining provisions shall continue in full force and effect.
11.3. Entire Agreement: This Agreement constitutes the entire agreement between you and CambuApp regarding the use of the application and supersedes all prior agreements and understandings.
11.4. Waiver: No waiver of any term of this Agreement shall be deemed a further or continuing waiver of such term or any other term.
11.5. Assignment: You may not assign or transfer this Agreement without CambuApp's prior written consent. CambuApp may assign this Agreement without restriction.
11.6. Updates: CambuApp may update the application and this Agreement from time to time. Continued use of the application after updates constitutes acceptance of the modified Agreement.

12. CONTACT INFORMATION

For questions about this Agreement, please contact us through the CambuApp support channels within the application.`;

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  app.use(session({
    secret: process.env.SESSION_SECRET || "cambuapp-secret",
    resave: false,
    saveUninitialized: false,
    store: new SessionStore({ checkPeriod: 86400000 }),
    cookie: { maxAge: 24 * 60 * 60 * 1000 }
  }));

  app.use("/uploads", express.static("uploads"));

  app.use("/api", generalApiLimiter);

  app.use((req, res, next) => {
    const start = Date.now();
    const originalSend = res.send;
    res.send = function (body) {
      const duration = Date.now() - start;
      console.log(`[REQUEST] ${req.method} ${req.path} ${res.statusCode} ${duration}ms`);
      return originalSend.call(this, body);
    };
    next();
  });

  app.use((err: any, _req: any, res: any, next: any) => {
    if (err) {
      console.error(`[ERROR] ${err.message}`);
      console.error(err.stack);
      if (!res.headersSent) {
        return res.status(500).json({ message: "Internal server error" });
      }
    }
    next(err);
  });

  // Auth Routes
  app.post("/api/auth/register", authLimiter, async (req, res) => {
    try {
      const parsed = insertUserSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid input", errors: parsed.error.errors });
      }
      if (parsed.data.bio && parsed.data.bio.length > 500) {
        return res.status(400).json({ message: "Bio must be 500 characters or less" });
      }
      const existing = await storage.getUserByUsername(parsed.data.username);
      if (existing) {
        return res.status(409).json({ message: "Username already taken" });
      }
      const hashedPassword = await bcrypt.hash(parsed.data.password, 10);
      const cleanedData = {
        ...parsed.data,
        password: hashedPassword,
        bio: cleanText(parsed.data.bio),
      };
      const user = await storage.createUser(cleanedData);
      req.session.userId = user.id;
      const { password, ...userWithoutPassword } = user;
      return res.status(201).json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Registration failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/auth/login", authLimiter, async (req, res) => {
    try {
      const { username, password } = req.body;
      if (!username || !password) {
        return res.status(400).json({ message: "Username and password required" });
      }
      const user = await storage.getUserByUsername(username);
      if (!user) {
        console.log(`[SECURITY] Failed login attempt - IP: ${req.ip} - Username: ${username} (user not found)`);
        return res.status(401).json({ message: "Invalid credentials" });
      }
      if (user.isBanned) {
        console.log(`[SECURITY] Banned user login attempt - IP: ${req.ip} - Username: ${username}`);
        return res.status(403).json({ message: "Account has been suspended" });
      }
      const isValidPassword = await bcrypt.compare(password, user.password);
      if (!isValidPassword) {
        console.log(`[SECURITY] Failed login attempt - IP: ${req.ip} - Username: ${username} (wrong password)`);
        return res.status(401).json({ message: "Invalid credentials" });
      }
      req.session.userId = user.id;
      const { password: _, ...userWithoutPassword } = user;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Login failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/auth/me", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = user;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Auth check failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/auth/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ message: "Failed to logout" });
      }
      return res.json({ message: "Logged out" });
    });
  });

  // User Routes
  app.get("/api/users/:id/stats", async (req, res) => {
    try {
      const userId = req.params.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const attendeeParties = await storage.getAttendeeParties(userId);
      const hostedParties = await storage.getPartiesByHost(userId);
      const reviews = await storage.getReviewsByTarget(userId);

      const filledFields = [
        user.fullName, user.nickname, user.bio, user.avatar,
        user.dob, user.phone, user.city, user.country,
        user.preferredVibe, user.gatheringSizePref
      ].filter(f => f && f.length > 0).length;
      const profileCompleteness = Math.round((filledFields / 10) * 100);

      return res.json({
        partiesAttended: attendeeParties.length,
        partiesHosted: hostedParties.length,
        reviewCount: reviews.length,
        profileCompleteness,
      });
    } catch (error: any) {
      console.error("[ERROR] User stats failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/users/:id", async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = user;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Get user failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/users/:id", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      if (req.session.userId !== req.params.id) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const { password, ...bodyWithoutPassword } = req.body;
      const parsed = updateUserSchema.safeParse(bodyWithoutPassword);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid input", errors: parsed.error.errors });
      }
      if (parsed.data.bio && parsed.data.bio.length > 500) {
        return res.status(400).json({ message: "Bio must be 500 characters or less" });
      }
      if (parsed.data.latitude != null && (parsed.data.latitude < -90 || parsed.data.latitude > 90)) {
        return res.status(400).json({ message: "Latitude must be between -90 and 90" });
      }
      if (parsed.data.longitude != null && (parsed.data.longitude < -180 || parsed.data.longitude > 180)) {
        return res.status(400).json({ message: "Longitude must be between -180 and 180" });
      }
      const cleanedData = {
        ...parsed.data,
        bio: parsed.data.bio ? cleanText(parsed.data.bio) : parsed.data.bio,
      };
      const updated = await storage.updateUser(req.params.id, cleanedData);
      if (!updated) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password: _, ...userWithoutPassword } = updated;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Update user failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/users/:id/reviews", async (req, res) => {
    try {
      const reviews = await storage.getReviewsByTarget(req.params.id);
      return res.json(reviews);
    } catch (error: any) {
      console.error("[ERROR] Get reviews failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Party Routes - specific routes before parameterized routes
  app.get("/api/parties/host/mine", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const myParties = await storage.getPartiesByHost(req.session.userId);
      const enriched = await Promise.all(myParties.map(async (party) => {
        const host = await storage.getUser(party.hostId);
        const attendeeCount = await storage.getAttendeeCount(party.id);
        return {
          ...party,
          hostName: host?.fullName || "Unknown",
          hostAvatar: host?.avatar || "",
          hostVerified: host?.isIdVerified || false,
          attendeeCount,
        };
      }));
      return res.json(enriched);
    } catch (error: any) {
      console.error("[ERROR] Get host parties failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties/attending/mine", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const attendingParties = await storage.getAttendeeParties(req.session.userId);
      const enriched = await Promise.all(attendingParties.map(async (party) => {
        const host = await storage.getUser(party.hostId);
        const attendeeCount = await storage.getAttendeeCount(party.id);
        return {
          ...party,
          hostName: host?.fullName || "Unknown",
          hostAvatar: host?.avatar || "",
          hostVerified: host?.isIdVerified || false,
          attendeeCount,
        };
      }));
      return res.json(enriched);
    } catch (error: any) {
      console.error("[ERROR] Get attending parties failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties", async (req, res) => {
    try {
      const city = req.query.city as string | undefined;
      const lat = req.query.lat ? parseFloat(req.query.lat as string) : undefined;
      const lng = req.query.lng ? parseFloat(req.query.lng as string) : undefined;
      const radius = req.query.radius ? parseFloat(req.query.radius as string) : undefined;
      const limitParam = req.query.limit ? parseInt(req.query.limit as string, 10) : 20;
      const offsetParam = req.query.offset ? parseInt(req.query.offset as string, 10) : 0;
      const limit = Math.min(Math.max(1, limitParam), 100);
      const offset = Math.max(0, offsetParam);

      let allParties = city ? await storage.getPartiesByCity(city) : await storage.getParties();

      if (lat !== undefined && lng !== undefined && radius !== undefined) {
        if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
          return res.status(400).json({ message: "Invalid coordinates" });
        }
        allParties = allParties.filter(party => {
          if (party.latitude === null || party.longitude === null) return false;
          const distance = haversineDistance(lat, lng, party.latitude, party.longitude);
          return distance <= radius;
        });
      }

      const enriched = await Promise.all(allParties.map(async (party) => {
        const host = await storage.getUser(party.hostId);
        const attendeeCount = await storage.getAttendeeCount(party.id);
        return {
          ...party,
          hostName: host?.fullName || "Unknown",
          hostAvatar: host?.avatar || "",
          hostVerified: host?.isIdVerified || false,
          attendeeCount,
        };
      }));

      const sort = req.query.sort as string | undefined;
      if (sort === "popular") {
        enriched.sort((a, b) => b.attendeeCount - a.attendeeCount);
      } else if (sort === "price_low") {
        enriched.sort((a, b) => (a.price ?? 0) - (b.price ?? 0));
      } else if (sort === "price_high") {
        enriched.sort((a, b) => (b.price ?? 0) - (a.price ?? 0));
      } else if (sort === "date") {
        enriched.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
      } else {
        enriched.sort((a, b) => new Date(b.createdAt ?? "").getTime() - new Date(a.createdAt ?? "").getTime());
      }

      const total = enriched.length;
      const paginatedParties = enriched.slice(offset, offset + limit);
      const hasMore = offset + limit < total;

      return res.json({ parties: paginatedParties, total, hasMore });
    } catch (error: any) {
      console.error("[ERROR] Get parties failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties/:id", async (req, res) => {
    try {
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      const host = await storage.getUser(party.hostId);
      const attendeeCount = await storage.getAttendeeCount(party.id);
      return res.json({
        ...party,
        hostName: host?.fullName || "Unknown",
        hostAvatar: host?.avatar || "",
        hostVerified: host?.isIdVerified || false,
        attendeeCount,
      });
    } catch (error: any) {
      console.error("[ERROR] Get party failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/parties", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const parsed = insertPartySchema.safeParse({ ...req.body, hostId: req.session.userId });
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid input", errors: parsed.error.errors });
      }
      if (parsed.data.title.length > 100) {
        return res.status(400).json({ message: "Title must be 100 characters or less" });
      }
      if (parsed.data.description.length > 2000) {
        return res.status(400).json({ message: "Description must be 2000 characters or less" });
      }
      if (parsed.data.houseRules && parsed.data.houseRules.length > 1000) {
        return res.status(400).json({ message: "House rules must be 1000 characters or less" });
      }
      if (parsed.data.latitude < -90 || parsed.data.latitude > 90) {
        return res.status(400).json({ message: "Latitude must be between -90 and 90" });
      }
      if (parsed.data.longitude < -180 || parsed.data.longitude > 180) {
        return res.status(400).json({ message: "Longitude must be between -180 and 180" });
      }
      const cleanedData = {
        ...parsed.data,
        title: cleanText(parsed.data.title),
        description: cleanText(parsed.data.description),
        houseRules: parsed.data.houseRules ? cleanText(parsed.data.houseRules) : parsed.data.houseRules,
      };
      const party = await storage.createParty(cleanedData);
      return res.status(201).json(party);
    } catch (error: any) {
      console.error("[ERROR] Create party failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/parties/:id", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const parsed = updatePartySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid input", errors: parsed.error.errors });
      }
      if (parsed.data.title && parsed.data.title.length > 100) {
        return res.status(400).json({ message: "Title must be 100 characters or less" });
      }
      if (parsed.data.description && parsed.data.description.length > 2000) {
        return res.status(400).json({ message: "Description must be 2000 characters or less" });
      }
      if (parsed.data.houseRules && parsed.data.houseRules.length > 1000) {
        return res.status(400).json({ message: "House rules must be 1000 characters or less" });
      }
      if (parsed.data.latitude != null && (parsed.data.latitude < -90 || parsed.data.latitude > 90)) {
        return res.status(400).json({ message: "Latitude must be between -90 and 90" });
      }
      if (parsed.data.longitude != null && (parsed.data.longitude < -180 || parsed.data.longitude > 180)) {
        return res.status(400).json({ message: "Longitude must be between -180 and 180" });
      }
      const cleanedData = {
        ...parsed.data,
        title: parsed.data.title ? cleanText(parsed.data.title) : parsed.data.title,
        description: parsed.data.description ? cleanText(parsed.data.description) : parsed.data.description,
        houseRules: parsed.data.houseRules ? cleanText(parsed.data.houseRules) : parsed.data.houseRules,
      };
      const updated = await storage.updateParty(req.params.id, cleanedData);
      return res.json(updated);
    } catch (error: any) {
      console.error("[ERROR] Update party failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/parties/:id", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.deleteParty(req.params.id);
      return res.json({ message: "Party deleted" });
    } catch (error: any) {
      console.error("[ERROR] Delete party failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties/:id/attendees", async (req, res) => {
    try {
      const attendees = await storage.getPartyAttendees(req.params.id);
      const attendeesWithInfo = await Promise.all(
        attendees.map(async (a) => {
          const user = await storage.getUser(a.userId);
          return {
            ...a,
            username: user?.username || "",
            fullName: user?.fullName || "",
            avatar: user?.avatar || "",
            isIdVerified: user?.isIdVerified || false,
          };
        })
      );
      return res.json(attendeesWithInfo);
    } catch (error: any) {
      console.error("[ERROR] Get attendees failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Party Request Routes
  app.get("/api/requests/mine", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const requests = await storage.getUserRequests(req.session.userId);
      return res.json(requests);
    } catch (error: any) {
      console.error("[ERROR] Get user requests failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/parties/:id/requests", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const requests = await storage.getPartyRequests(req.params.id);
      const requestsWithInfo = await Promise.all(
        requests.map(async (r) => {
          const user = await storage.getUser(r.userId);
          return {
            ...r,
            username: user?.username || "",
            fullName: user?.fullName || "",
            avatar: user?.avatar || "",
            isIdVerified: user?.isIdVerified || false,
          };
        })
      );
      return res.json(requestsWithInfo);
    } catch (error: any) {
      console.error("[ERROR] Get party requests failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/parties/:id/requests", requestCreationLimiter, async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId === req.session.userId) {
        return res.status(400).json({ message: "You cannot request to join your own party" });
      }
      if (party.includesAlcohol) {
        const user = await storage.getUser(req.session.userId);
        if (!user?.isAgeVerified) {
          return res.status(403).json({ message: "Age verification required for parties that include alcohol" });
        }
      }
      const existingRequest = await storage.getPartyRequestByUserAndParty(req.session.userId, req.params.id);
      if (existingRequest) {
        return res.status(409).json({ message: "You already have a pending or accepted request for this party" });
      }
      const message = req.body.message || "";
      if (message.length > 500) {
        return res.status(400).json({ message: "Message must be 500 characters or less" });
      }
      const request = await storage.createPartyRequest({
        partyId: req.params.id,
        userId: req.session.userId,
        message: cleanText(message),
        pledgedItems: req.body.pledgedItems || "",
        status: "pending",
      });
      return res.status(201).json(request);
    } catch (error: any) {
      console.error("[ERROR] Create party request failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/requests/:id/status", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const parsed = updateRequestStatusSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Status must be 'accepted' or 'declined'" });
      }
      const { status } = parsed.data;
      const request = await storage.getRequest(req.params.id);
      if (!request) {
        return res.status(404).json({ message: "Request not found" });
      }
      const party = await storage.getParty(request.partyId);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      if (party.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const updatedRequest = await storage.updateRequestStatus(req.params.id, status);
      if (!updatedRequest) {
        return res.status(404).json({ message: "Request not found" });
      }
      if (status === "accepted") {
        await storage.addAttendee(updatedRequest.partyId, updatedRequest.userId);
      }
      return res.json(updatedRequest);
    } catch (error: any) {
      console.error("[ERROR] Update request status failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Review Routes
  app.post("/api/reviews", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const review = await storage.createReview({
        ...req.body,
        authorId: req.session.userId,
      });
      return res.status(201).json(review);
    } catch (error: any) {
      console.error("[ERROR] Create review failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Image Upload Routes
  app.post("/api/upload/party-image", (req, res, next) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    next();
  }, uploadPartyImage.single("image"), (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: "No image file provided" });
    }
    const url = `/uploads/parties/${req.file.filename}`;
    return res.json({ url });
  });

  app.post("/api/upload/avatar", (req, res, next) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    next();
  }, uploadAvatar.single("image"), (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: "No image file provided" });
    }
    const url = `/uploads/avatars/${req.file.filename}`;
    return res.json({ url });
  });

  app.post("/api/upload/id-document", (req, res, next) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    next();
  }, uploadIdDoc.single("image"), (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: "No image file provided" });
    }
    const url = `/uploads/ids/${req.file.filename}`;
    return res.json({ url });
  });

  app.post("/api/verify-age", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      const { imageBase64 } = req.body;
      if (!imageBase64) {
        return res.status(400).json({ message: "Image data is required" });
      }
      const dir = "uploads/ids";
      fs.mkdirSync(dir, { recursive: true });
      const mimeMatch = imageBase64.match(/^data:(image\/\w+);base64,/);
      const detectedMime = mimeMatch ? mimeMatch[1] : "image/png";
      const ext = detectedMime.split("/")[1] || "png";
      const filename = `verify-${req.session.userId}-${Date.now()}.${ext}`;
      const filepath = path.join(dir, filename);
      const base64Data = imageBase64.replace(/^data:image\/\w+;base64,/, "");
      fs.writeFileSync(filepath, Buffer.from(base64Data, "base64"));
      const idDocumentUrl = `/uploads/ids/${filename}`;

      let isVerified = false;
      let aiMessage = "Verification pending";
      try {
        const { GoogleGenAI } = await import("@google/genai");
        const ai = new GoogleGenAI({
          apiKey: process.env.AI_INTEGRATIONS_GEMINI_API_KEY!,
          httpOptions: {
            apiVersion: "",
            baseUrl: process.env.AI_INTEGRATIONS_GEMINI_BASE_URL!,
          },
        });
        const response = await ai.models.generateContent({
          model: "gemini-2.5-flash",
          contents: [
            {
              role: "user",
              parts: [
                {
                  text: "This is an ID document image. Extract the date of birth from this ID. Determine if the person is 18 years old or older as of today. Respond ONLY with a JSON object in this exact format: {\"dob\": \"YYYY-MM-DD\", \"age\": NUMBER, \"is18Plus\": true/false, \"documentType\": \"passport/license/id_card/unknown\"}. If you cannot read the document or extract the date of birth, respond with: {\"dob\": null, \"age\": null, \"is18Plus\": false, \"documentType\": \"unreadable\"}",
                },
                {
                  inlineData: {
                    mimeType: detectedMime,
                    data: base64Data,
                  },
                },
              ],
            },
          ],
        });
        const responseText = response.text || "";
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          const parsed = JSON.parse(jsonMatch[0]);
          isVerified = parsed.is18Plus === true;
          aiMessage = isVerified
            ? `Age verified: ${parsed.age} years old (${parsed.documentType})`
            : parsed.documentType === "unreadable"
              ? "Could not read the document. Please try again with a clearer photo."
              : `Verification failed: Must be 18+ (detected age: ${parsed.age})`;
        }
      } catch (aiError: any) {
        console.error("[WARN] Gemini AI verification failed, falling back:", aiError.message);
        aiMessage = "AI verification unavailable. Document saved for manual review.";
      }

      await storage.updateUser(req.session.userId, {
        isAgeVerified: isVerified,
        idDocumentUrl,
      });

      return res.json({
        message: aiMessage,
        status: isVerified ? "verified" : "failed",
        isVerified,
        idDocumentUrl,
      });
    } catch (error: any) {
      console.error("[ERROR] Age verification failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin Routes
  const requireAdmin = async (req: any, res: any, next: any) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    const user = await storage.getUser(req.session.userId);
    if (!user || !user.isAdmin) {
      return res.status(403).json({ message: "Admin access required" });
    }
    next();
  };

  app.get("/api/admin/stats", requireAdmin, async (_req, res) => {
    try {
      const allUsers = await storage.getAllUsers();
      const allParties = await storage.getAllParties();

      const totalUsers = allUsers.length;
      const totalParties = allParties.length;
      const activeParties = allParties.filter(p => p.status === "upcoming" || p.status === "ongoing").length;
      const finishedParties = allParties.filter(p => p.status === "finished").length;
      const bannedUsers = allUsers.filter(u => u.isBanned).length;
      const verifiedUsers = allUsers.filter(u => u.isIdVerified).length;

      return res.json({
        totalUsers,
        totalParties,
        activeParties,
        finishedParties,
        bannedUsers,
        verifiedUsers,
      });
    } catch (error: any) {
      console.error("[ERROR] Admin stats failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/parties/:id", requireAdmin, async (req, res) => {
    try {
      const party = await storage.getParty(req.params.id);
      if (!party) {
        return res.status(404).json({ message: "Party not found" });
      }
      await storage.deleteParty(req.params.id);
      console.log(`[ADMIN] Party ${req.params.id} deleted by admin ${req.session.userId}`);
      return res.json({ message: "Party deleted by admin" });
    } catch (error: any) {
      console.error("[ERROR] Admin delete party failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/users/:id/ban", requireAdmin, async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const newBanStatus = !user.isBanned;
      const updated = await storage.updateUser(req.params.id, { isBanned: newBanStatus });
      console.log(`[ADMIN] User ${req.params.id} ${newBanStatus ? "banned" : "unbanned"} by admin ${req.session.userId}`);
      if (!updated) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = updated;
      return res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("[ERROR] Admin ban user failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/reviews/:id", requireAdmin, async (req, res) => {
    try {
      await storage.deleteReview(req.params.id);
      console.log(`[ADMIN] Review ${req.params.id} deleted by admin ${req.session.userId}`);
      return res.json({ message: "Review deleted by admin" });
    } catch (error: any) {
      console.error("[ERROR] Admin delete review failed:", error.stack || error.message);
      return res.status(500).json({ message: "Internal server error" });
    }
  });

  // Legal Routes
  app.get("/api/legal/terms", (_req, res) => {
    return res.json({ content: TERMS_OF_SERVICE });
  });

  app.get("/api/legal/privacy", (_req, res) => {
    return res.json({ content: PRIVACY_POLICY });
  });

  app.get("/api/legal/eula", (_req, res) => {
    return res.json({ content: EULA_TEXT });
  });

  updatePartyStatuses().catch(console.error);
  setInterval(() => {
    updatePartyStatuses().catch(console.error);
  }, 60 * 60 * 1000);

  return httpServer;
}

========================================
FILE: server/storage.ts
========================================
import {
  type User, type InsertUser,
  type Party, type InsertParty,
  type PartyAttendee, type InsertPartyAttendee,
  type PartyRequest, type InsertPartyRequest,
  type Review, type InsertReview,
  users, parties, partyAttendees, partyRequests, reviews,
} from "@shared/schema";
import { eq, and, count, or } from "drizzle-orm";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
import * as schema from "@shared/schema";

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool, { schema });

export interface IStorage {
  getUser(id: string): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: string, data: Partial<InsertUser>): Promise<User | undefined>;
  getParties(): Promise<Party[]>;
  getPartiesByCity(city: string): Promise<Party[]>;
  getParty(id: string): Promise<Party | undefined>;
  getPartiesByHost(hostId: string): Promise<Party[]>;
  createParty(party: InsertParty): Promise<Party>;
  updateParty(id: string, data: Partial<InsertParty>): Promise<Party | undefined>;
  deleteParty(id: string): Promise<void>;
  getPartyAttendees(partyId: string): Promise<PartyAttendee[]>;
  getAttendeeParties(userId: string): Promise<Party[]>;
  addAttendee(partyId: string, userId: string): Promise<PartyAttendee>;
  removeAttendee(partyId: string, userId: string): Promise<void>;
  getAttendeeCount(partyId: string): Promise<number>;
  getPartyRequests(partyId: string): Promise<PartyRequest[]>;
  getUserRequests(userId: string): Promise<PartyRequest[]>;
  createPartyRequest(request: InsertPartyRequest): Promise<PartyRequest>;
  updateRequestStatus(id: string, status: string): Promise<PartyRequest | undefined>;
  getRequest(id: string): Promise<PartyRequest | undefined>;
  getReviewsByTarget(targetId: string): Promise<Review[]>;
  getReviewsByAuthor(authorId: string): Promise<Review[]>;
  createReview(review: InsertReview): Promise<Review>;
  getPartiesCount(): Promise<number>;
  getPartyRequestByUserAndParty(userId: string, partyId: string): Promise<PartyRequest | undefined>;
  getAllUsers(): Promise<User[]>;
  getAllParties(): Promise<Party[]>;
  deleteReview(id: string): Promise<void>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }

  async createUser(user: InsertUser): Promise<User> {
    const [created] = await db.insert(users).values(user).returning();
    return created;
  }

  async updateUser(id: string, data: Partial<InsertUser>): Promise<User | undefined> {
    const [updated] = await db.update(users).set(data).where(eq(users.id, id)).returning();
    return updated;
  }

  async getParties(): Promise<Party[]> {
    return db.select().from(parties);
  }

  async getPartiesByCity(city: string): Promise<Party[]> {
    return db.select().from(parties).where(eq(parties.city, city));
  }

  async getParty(id: string): Promise<Party | undefined> {
    const [party] = await db.select().from(parties).where(eq(parties.id, id));
    return party;
  }

  async getPartiesByHost(hostId: string): Promise<Party[]> {
    return db.select().from(parties).where(eq(parties.hostId, hostId));
  }

  async createParty(party: InsertParty): Promise<Party> {
    const [created] = await db.insert(parties).values(party).returning();
    return created;
  }

  async updateParty(id: string, data: Partial<InsertParty>): Promise<Party | undefined> {
    const [updated] = await db.update(parties).set(data).where(eq(parties.id, id)).returning();
    return updated;
  }

  async deleteParty(id: string): Promise<void> {
    await db.delete(parties).where(eq(parties.id, id));
  }

  async getPartyAttendees(partyId: string): Promise<PartyAttendee[]> {
    return db.select().from(partyAttendees).where(eq(partyAttendees.partyId, partyId));
  }

  async getAttendeeParties(userId: string): Promise<Party[]> {
    const result = await db
      .select({ party: parties })
      .from(partyAttendees)
      .innerJoin(parties, eq(partyAttendees.partyId, parties.id))
      .where(eq(partyAttendees.userId, userId));
    return result.map(r => r.party);
  }

  async addAttendee(partyId: string, userId: string): Promise<PartyAttendee> {
    const [created] = await db.insert(partyAttendees).values({ partyId, userId }).returning();
    return created;
  }

  async removeAttendee(partyId: string, userId: string): Promise<void> {
    await db.delete(partyAttendees).where(
      and(eq(partyAttendees.partyId, partyId), eq(partyAttendees.userId, userId))
    );
  }

  async getAttendeeCount(partyId: string): Promise<number> {
    const [result] = await db.select({ count: count() }).from(partyAttendees).where(eq(partyAttendees.partyId, partyId));
    return result?.count ?? 0;
  }

  async getPartyRequests(partyId: string): Promise<PartyRequest[]> {
    return db.select().from(partyRequests).where(eq(partyRequests.partyId, partyId));
  }

  async getUserRequests(userId: string): Promise<PartyRequest[]> {
    return db.select().from(partyRequests).where(eq(partyRequests.userId, userId));
  }

  async createPartyRequest(request: InsertPartyRequest): Promise<PartyRequest> {
    const [created] = await db.insert(partyRequests).values(request).returning();
    return created;
  }

  async updateRequestStatus(id: string, status: string): Promise<PartyRequest | undefined> {
    const [updated] = await db.update(partyRequests).set({ status }).where(eq(partyRequests.id, id)).returning();
    return updated;
  }

  async getRequest(id: string): Promise<PartyRequest | undefined> {
    const [request] = await db.select().from(partyRequests).where(eq(partyRequests.id, id));
    return request;
  }

  async getReviewsByTarget(targetId: string): Promise<Review[]> {
    return db.select().from(reviews).where(eq(reviews.targetId, targetId));
  }

  async getReviewsByAuthor(authorId: string): Promise<Review[]> {
    return db.select().from(reviews).where(eq(reviews.authorId, authorId));
  }

  async createReview(review: InsertReview): Promise<Review> {
    const [created] = await db.insert(reviews).values(review).returning();
    return created;
  }

  async getPartiesCount(): Promise<number> {
    const [result] = await db.select({ count: count() }).from(parties);
    return result?.count ?? 0;
  }

  async getPartyRequestByUserAndParty(userId: string, partyId: string): Promise<PartyRequest | undefined> {
    const [request] = await db.select().from(partyRequests).where(
      and(
        eq(partyRequests.userId, userId),
        eq(partyRequests.partyId, partyId),
        or(eq(partyRequests.status, "pending"), eq(partyRequests.status, "accepted"))
      )
    );
    return request;
  }

  async getAllUsers(): Promise<User[]> {
    return db.select().from(users);
  }

  async getAllParties(): Promise<Party[]> {
    return db.select().from(parties);
  }

  async deleteReview(id: string): Promise<void> {
    await db.delete(reviews).where(eq(reviews.id, id));
  }
}

export const storage = new DatabaseStorage();

========================================
FILE: server/index.ts
========================================
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { serveStatic } from "./static";
import { createServer } from "http";

const app = express();
const httpServer = createServer(app);

declare module "http" {
  interface IncomingMessage {
    rawBody: unknown;
  }
}

app.use(
  express.json({
    verify: (req, _res, buf) => {
      req.rawBody = buf;
    },
  }),
);

app.use(express.urlencoded({ extended: false }));

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  await registerRoutes(httpServer, app);

  app.use((err: any, _req: Request, res: Response, next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    console.error("Internal Server Error:", err);

    if (res.headersSent) {
      return next(err);
    }

    return res.status(status).json({ message });
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (process.env.NODE_ENV === "production") {
    serveStatic(app);
  } else {
    const { setupVite } = await import("./vite");
    await setupVite(httpServer, app);
  }

  // ALWAYS serve the app on the port specified in the environment variable PORT
  // Other ports are firewalled. Default to 5000 if not specified.
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = parseInt(process.env.PORT || "5000", 10);
  httpServer.listen(
    {
      port,
      host: "0.0.0.0",
      reusePort: true,
    },
    () => {
      log(`serving on port ${port}`);
    },
  );
})();

========================================
FILE: client/src/App.tsx
========================================
import { Switch, Route, useLocation, Redirect } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { ThemeProvider } from "@/components/theme-provider";
import { useAuth } from "@/hooks/use-auth";
import NotFound from "@/pages/not-found";
import AuthPage from "@/pages/auth-page";
import OnboardingPage from "@/pages/onboarding-page";
import BrowsePage from "@/pages/browse-page";
import PartyDetailPage from "@/pages/party-detail-page";
import ProfilePage from "@/pages/profile-page";
import SettingsPage from "@/pages/settings-page";
import CreatePartyPage from "@/pages/create-party-page";
import HostPage from "@/pages/host-page";
import AttendingPage from "@/pages/attending-page";
import LegalPage from "@/pages/legal-page";
import { MobileNav } from "@/components/mobile-nav";
import { Skeleton } from "@/components/ui/skeleton";

function AuthGuard({ children }: { children: React.ReactNode }) {
  const { user, isLoading, isAuthenticated } = useAuth();
  const [location] = useLocation();

  if (isLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="flex flex-col items-center gap-4">
          <Skeleton className="h-12 w-12 rounded-full" />
          <Skeleton className="h-4 w-32" />
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <Redirect to="/auth" />;
  }

  if (user && (!user.city || !user.country) && location !== "/onboarding") {
    return <Redirect to="/onboarding" />;
  }

  return <>{children}</>;
}

function Router() {
  return (
    <Switch>
      <Route path="/auth" component={AuthPage} />
      <Route path="/legal/:type" component={LegalPage} />
      <Route path="/">
        <AuthGuard>
          <BrowsePage />
        </AuthGuard>
      </Route>
      <Route path="/browse">
        <AuthGuard>
          <BrowsePage />
        </AuthGuard>
      </Route>
      <Route path="/onboarding">
        <AuthGuard>
          <OnboardingPage />
        </AuthGuard>
      </Route>
      <Route path="/party/:id">
        <AuthGuard>
          <PartyDetailPage />
        </AuthGuard>
      </Route>
      <Route path="/profile">
        <AuthGuard>
          <ProfilePage />
        </AuthGuard>
      </Route>
      <Route path="/settings">
        <AuthGuard>
          <SettingsPage />
        </AuthGuard>
      </Route>
      <Route path="/create-party">
        <AuthGuard>
          <CreatePartyPage />
        </AuthGuard>
      </Route>
      <Route path="/host">
        <AuthGuard>
          <HostPage />
        </AuthGuard>
      </Route>
      <Route path="/attending">
        <AuthGuard>
          <AttendingPage />
        </AuthGuard>
      </Route>
      <Route component={NotFound} />
    </Switch>
  );
}

function AppContent() {
  const { isAuthenticated } = useAuth();
  const [location] = useLocation();
  const hideNav = ["/auth", "/onboarding"].includes(location) || location.startsWith("/legal");

  return (
    <div className="min-h-screen bg-background">
      <Router />
      {isAuthenticated && !hideNav && <MobileNav />}
    </div>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>
        <TooltipProvider>
          <AppContent />
          <Toaster />
        </TooltipProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

export default App;

========================================
FILE: client/src/pages/auth-page.tsx
========================================
import { useState, useEffect } from "react";
import { useLocation, Link } from "wouter";
import { useMutation } from "@tanstack/react-query";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { PartyPopper, Sparkles, Loader2 } from "lucide-react";

const loginSchema = z.object({
  username: z.string().min(1, "Username is required"),
  password: z.string().min(1, "Password is required"),
});

const registerSchema = z.object({
  username: z.string().min(3, "Username must be at least 3 characters"),
  email: z.string().email("Please enter a valid email"),
  password: z.string().min(6, "Password must be at least 6 characters"),
  fullName: z.string().min(2, "Full name is required"),
  agreedToTerms: z.boolean().refine(v => v === true, "You must agree to the terms"),
});

type LoginValues = z.infer<typeof loginSchema>;
type RegisterValues = z.infer<typeof registerSchema>;

export default function AuthPage() {
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const { user, isLoading: authLoading } = useAuth();
  const [activeTab, setActiveTab] = useState("signin");

  const loginForm = useForm<LoginValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: { username: "", password: "" },
  });

  const registerForm = useForm<RegisterValues>({
    resolver: zodResolver(registerSchema),
    defaultValues: { username: "", email: "", password: "", fullName: "", agreedToTerms: false },
  });

  const loginMutation = useMutation({
    mutationFn: async (values: LoginValues) => {
      const res = await apiRequest("POST", "/api/auth/login", values);
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      toast({ title: "Welcome back!", description: "You've signed in successfully." });
      setLocation("/");
    },
    onError: (error: Error) => {
      toast({
        title: "Sign in failed",
        description: error.message.includes("401") ? "Invalid username or password" : error.message,
        variant: "destructive",
      });
    },
  });

  const registerMutation = useMutation({
    mutationFn: async (values: RegisterValues) => {
      const res = await apiRequest("POST", "/api/auth/register", { ...values, agreedToTerms: true });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      toast({ title: "Account created!", description: "Let's set up your profile." });
      setLocation("/onboarding");
    },
    onError: (error: Error) => {
      toast({
        title: "Registration failed",
        description: error.message.includes("409") ? "Username already taken" : error.message,
        variant: "destructive",
      });
    },
  });

  useEffect(() => {
    if (user && !authLoading) {
      setLocation("/");
    }
  }, [user, authLoading, setLocation]);

  if (authLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (user) return null;

  return (
    <div className="min-h-screen bg-background flex flex-col">
      <div className="relative overflow-hidden py-16 px-4 flex flex-col items-center justify-center"
        style={{
          background: "linear-gradient(135deg, hsl(280 85% 15%) 0%, hsl(280 85% 8%) 50%, hsl(300 60% 10%) 100%)",
        }}
      >
        <div
          className="absolute inset-0 opacity-20"
          style={{
            background: "radial-gradient(circle at 30% 50%, hsl(280 85% 55% / 0.4) 0%, transparent 50%), radial-gradient(circle at 70% 30%, hsl(320 65% 50% / 0.3) 0%, transparent 40%)",
          }}
        />
        <div className="relative z-10 text-center">
          <div className="flex items-center justify-center gap-3 mb-3">
            <PartyPopper className="w-10 h-10 text-primary-foreground" />
            <h1 className="text-4xl font-bold text-primary-foreground tracking-tight" data-testid="text-app-title">
              CambuApp
            </h1>
            <Sparkles className="w-8 h-8 text-primary-foreground opacity-80" />
          </div>
          <p className="text-primary-foreground/70 text-lg" data-testid="text-app-tagline">
            The Party Vibe Network
          </p>
        </div>
      </div>

      <div className="flex-1 flex items-start justify-center px-4 -mt-8 pb-12">
        <Card className="w-full max-w-md relative z-10">
          <CardContent className="pt-6">
            <Tabs value={activeTab} onValueChange={setActiveTab}>
              <TabsList className="w-full mb-6">
                <TabsTrigger value="signin" className="flex-1" data-testid="tab-signin">
                  Sign In
                </TabsTrigger>
                <TabsTrigger value="signup" className="flex-1" data-testid="tab-signup">
                  Sign Up
                </TabsTrigger>
              </TabsList>

              <TabsContent value="signin">
                <Form {...loginForm}>
                  <form
                    onSubmit={loginForm.handleSubmit((v) => loginMutation.mutate(v))}
                    className="space-y-4"
                    data-testid="form-signin"
                  >
                    <FormField
                      control={loginForm.control}
                      name="username"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Username</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="Enter your username"
                              data-testid="input-login-username"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={loginForm.control}
                      name="password"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Password</FormLabel>
                          <FormControl>
                            <Input
                              type="password"
                              placeholder="Enter your password"
                              data-testid="input-login-password"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <Button
                      type="submit"
                      className="w-full"
                      disabled={loginMutation.isPending}
                      data-testid="button-signin"
                    >
                      {loginMutation.isPending ? (
                        <Loader2 className="w-4 h-4 animate-spin mr-2" />
                      ) : null}
                      Sign In
                    </Button>
                  </form>
                </Form>
                <p className="text-center text-sm text-muted-foreground mt-4">
                  Don't have an account?{" "}
                  <button
                    type="button"
                    className="text-foreground underline underline-offset-2"
                    onClick={() => setActiveTab("signup")}
                    data-testid="link-goto-signup"
                  >
                    Sign up
                  </button>
                </p>
              </TabsContent>

              <TabsContent value="signup">
                <Form {...registerForm}>
                  <form
                    onSubmit={registerForm.handleSubmit((v) => registerMutation.mutate(v))}
                    className="space-y-4"
                    data-testid="form-signup"
                  >
                    <FormField
                      control={registerForm.control}
                      name="fullName"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Full Name</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="Your full name"
                              data-testid="input-register-fullname"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={registerForm.control}
                      name="username"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Username</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="Choose a username"
                              data-testid="input-register-username"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={registerForm.control}
                      name="email"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Email</FormLabel>
                          <FormControl>
                            <Input
                              type="email"
                              placeholder="you@example.com"
                              data-testid="input-register-email"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={registerForm.control}
                      name="password"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Password</FormLabel>
                          <FormControl>
                            <Input
                              type="password"
                              placeholder="At least 6 characters"
                              data-testid="input-register-password"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={registerForm.control}
                      name="agreedToTerms"
                      render={({ field }) => (
                        <FormItem>
                          <div className="flex items-start gap-3">
                            <FormControl>
                              <Checkbox
                                checked={field.value}
                                onCheckedChange={field.onChange}
                                data-testid="checkbox-agree-terms"
                              />
                            </FormControl>
                            <FormLabel className="text-sm font-normal leading-snug cursor-pointer">
                              I agree to the{" "}
                              <Link href="/legal/terms" className="underline underline-offset-2" data-testid="link-terms">
                                Terms of Service
                              </Link>
                              ,{" "}
                              <Link href="/legal/privacy" className="underline underline-offset-2" data-testid="link-privacy">
                                Privacy Policy
                              </Link>
                              , and{" "}
                              <Link href="/legal/eula" className="underline underline-offset-2" data-testid="link-eula">
                                EULA
                              </Link>
                            </FormLabel>
                          </div>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <Button
                      type="submit"
                      className="w-full"
                      disabled={registerMutation.isPending}
                      data-testid="button-signup"
                    >
                      {registerMutation.isPending ? (
                        <Loader2 className="w-4 h-4 animate-spin mr-2" />
                      ) : null}
                      Create Account
                    </Button>
                  </form>
                </Form>
                <p className="text-center text-sm text-muted-foreground mt-4">
                  Already have an account?{" "}
                  <button
                    type="button"
                    className="text-foreground underline underline-offset-2"
                    onClick={() => setActiveTab("signin")}
                    data-testid="link-goto-signin"
                  >
                    Sign in
                  </button>
                </p>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

========================================
FILE: client/src/pages/browse-page.tsx
========================================
import { useState, useMemo } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Link } from "wouter";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";
import { Search, SlidersHorizontal, MapPin, Calendar, Users, DollarSign, Wine, Star, ChevronDown, ChevronUp, PartyPopper, Loader2 } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { format, addDays, isAfter, isBefore, endOfWeek, endOfMonth, addMonths } from "date-fns";
import type { Party } from "@shared/schema";

interface EnrichedParty extends Party {
  hostName: string;
  hostAvatar: string;
  hostVerified: boolean;
  attendeeCount: number;
}

interface PartiesResponse {
  parties: EnrichedParty[];
  total: number;
  hasMore: boolean;
}

const THEMES = [
  "All",
  "Cyberpunk/Neon",
  "Cocktail/Lounge",
  "Pool Party",
  "Indie/Bohemian",
  "Festival/EDM",
  "House Party",
  "Dinner Party",
  "Outdoor/BBQ",
  "Game Night",
];

function formatPartyDate(dateStr: string) {
  try {
    return format(new Date(dateStr), "MMM d, yyyy 'at' h:mm a");
  } catch {
    return dateStr;
  }
}

function PartyCardSkeleton() {
  return (
    <Card className="overflow-visible">
      <Skeleton className="h-48 w-full rounded-t-md rounded-b-none" />
      <CardContent className="p-4 space-y-3">
        <Skeleton className="h-5 w-3/4" />
        <Skeleton className="h-4 w-1/2" />
        <Skeleton className="h-4 w-2/3" />
        <div className="flex items-center gap-2">
          <Skeleton className="h-4 w-16" />
          <Skeleton className="h-4 w-20" />
        </div>
      </CardContent>
    </Card>
  );
}

export default function BrowsePage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [search, setSearch] = useState("");
  const [filtersOpen, setFiltersOpen] = useState(false);
  const [sortBy, setSortBy] = useState("newest");
  const [maxPrice, setMaxPrice] = useState([200]);
  const [themeFilter, setThemeFilter] = useState("All");
  const [crowdSize, setCrowdSize] = useState("All");
  const [dateFilter, setDateFilter] = useState("All dates");
  const [freeOnly, setFreeOnly] = useState(false);
  const [offset, setOffset] = useState(0);
  const [allParties, setAllParties] = useState<EnrichedParty[]>([]);
  const [gpsLat, setGpsLat] = useState<number | null>(user?.latitude ?? null);
  const [gpsLng, setGpsLng] = useState<number | null>(user?.longitude ?? null);
  const [searchRadius, setSearchRadius] = useState([user?.searchRadius ?? 50]);
  const [locating, setLocating] = useState(false);

  const buildQueryUrl = () => {
    const params = new URLSearchParams();
    if (offset > 0) params.set("offset", String(offset));
    if (gpsLat !== null && gpsLng !== null) {
      params.set("lat", String(gpsLat));
      params.set("lng", String(gpsLng));
      params.set("radius", String(searchRadius[0]));
    }
    const qs = params.toString();
    return `/api/parties${qs ? `?${qs}` : ""}`;
  };

  const { data, isLoading } = useQuery<PartiesResponse>({
    queryKey: ["/api/parties", offset, gpsLat, gpsLng, searchRadius[0]],
    queryFn: async () => {
      const res = await fetch(buildQueryUrl(), { credentials: "include" });
      if (!res.ok) throw new Error("Failed to fetch parties");
      return res.json();
    },
  });

  const parties = useMemo(() => {
    if (!data?.parties) return allParties;
    if (offset === 0) return data.parties;
    const existingIds = new Set(allParties.map(p => p.id));
    const newParties = data.parties.filter(p => !existingIds.has(p.id));
    return [...allParties, ...newParties];
  }, [data, offset, allParties]);

  const hasMore = data?.hasMore ?? false;

  const handleLoadMore = () => {
    setAllParties(parties);
    setOffset(parties.length);
  };

  const locationMutation = useMutation({
    mutationFn: async ({ lat, lng }: { lat: number; lng: number }) => {
      if (!user) throw new Error("Not authenticated");
      const res = await apiRequest("PATCH", `/api/users/${user.id}`, {
        latitude: lat,
        longitude: lng,
      });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      queryClient.invalidateQueries({ queryKey: ["/api/parties"] });
      toast({ title: "Location updated", description: "Showing parties near you." });
    },
    onError: () => {
      toast({ title: "Failed to update location", variant: "destructive" });
    },
  });

  const handleUseLocation = () => {
    if (!navigator.geolocation) {
      toast({ title: "Geolocation not supported", description: "Your browser does not support location services.", variant: "destructive" });
      return;
    }
    setLocating(true);
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        setGpsLat(lat);
        setGpsLng(lng);
        setOffset(0);
        setAllParties([]);
        locationMutation.mutate({ lat, lng });
        setLocating(false);
      },
      (err) => {
        setLocating(false);
        toast({ title: "Location access denied", description: "Please enable location permissions.", variant: "destructive" });
      },
      { enableHighAccuracy: true, timeout: 10000 }
    );
  };

  const handleRadiusChange = (value: number[]) => {
    setSearchRadius(value);
    setOffset(0);
    setAllParties([]);
  };

  const activeFilterCount = useMemo(() => {
    let count = 0;
    if (sortBy !== "newest") count++;
    if (themeFilter !== "All") count++;
    if (maxPrice[0] < 200) count++;
    if (crowdSize !== "All") count++;
    if (dateFilter !== "All dates") count++;
    if (freeOnly) count++;
    return count;
  }, [sortBy, themeFilter, maxPrice, crowdSize, dateFilter, freeOnly]);

  const filteredParties = useMemo(() => {
    if (!parties) return [];
    let result = [...parties];

    if (search.trim()) {
      const q = search.toLowerCase();
      result = result.filter(
        (p) =>
          p.title.toLowerCase().includes(q) ||
          p.theme.toLowerCase().includes(q)
      );
    }

    if (themeFilter !== "All") {
      result = result.filter((p) => p.theme === themeFilter);
    }

    result = result.filter((p) => (p.price ?? 0) <= maxPrice[0]);

    if (freeOnly) {
      result = result.filter((p) => (p.price ?? 0) === 0);
    }

    if (crowdSize === "Intimate (1-15)") {
      result = result.filter((p) => p.maxGuests <= 15);
    } else if (crowdSize === "Medium (16-40)") {
      result = result.filter((p) => p.maxGuests >= 16 && p.maxGuests <= 40);
    } else if (crowdSize === "Large (41+)") {
      result = result.filter((p) => p.maxGuests > 40);
    }

    if (dateFilter !== "All dates") {
      const now = new Date();
      if (dateFilter === "This week") {
        const weekEnd = endOfWeek(now, { weekStartsOn: 1 });
        result = result.filter((p) => {
          const partyDate = new Date(p.date);
          return isAfter(partyDate, now) && isBefore(partyDate, weekEnd);
        });
      } else if (dateFilter === "This month") {
        const monthEnd = endOfMonth(now);
        result = result.filter((p) => {
          const partyDate = new Date(p.date);
          return isAfter(partyDate, now) && isBefore(partyDate, monthEnd);
        });
      } else if (dateFilter === "Next 3 months") {
        const threeMonthsOut = addMonths(now, 3);
        result = result.filter((p) => {
          const partyDate = new Date(p.date);
          return isAfter(partyDate, now) && isBefore(partyDate, threeMonthsOut);
        });
      }
    }

    if (sortBy === "price_low") {
      result.sort((a, b) => (a.price ?? 0) - (b.price ?? 0));
    } else if (sortBy === "price_high") {
      result.sort((a, b) => (b.price ?? 0) - (a.price ?? 0));
    } else if (sortBy === "popular") {
      result.sort((a, b) => b.attendeeCount - a.attendeeCount);
    } else if (sortBy === "soonest") {
      result.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    } else {
      result.sort((a, b) => new Date(b.createdAt ?? "").getTime() - new Date(a.createdAt ?? "").getTime());
    }

    return result;
  }, [parties, search, sortBy, maxPrice, themeFilter, crowdSize, dateFilter, freeOnly]);

  return (
    <div className="min-h-screen bg-background pb-28">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-5xl mx-auto px-4 py-3">
          <div className="flex items-center gap-3 flex-wrap">
            <Link href="/" className="flex items-center gap-2 shrink-0">
              <PartyPopper className="h-6 w-6 text-primary" />
              <span className="text-lg font-bold" data-testid="text-app-name">CambuApp</span>
            </Link>
            <div className="flex-1 min-w-[180px] relative">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                type="search"
                placeholder="Search parties..."
                value={search}
                onChange={(e) => setSearch(e.target.value)}
                className="pl-9"
                data-testid="input-search"
              />
            </div>
            <Button
              variant="outline"
              onClick={handleUseLocation}
              disabled={locating}
              data-testid="button-use-location"
            >
              {locating ? (
                <Loader2 className="h-4 w-4 animate-spin mr-1" />
              ) : (
                <MapPin className="h-4 w-4 mr-1" />
              )}
              {gpsLat !== null ? "Update location" : "Use my location"}
            </Button>
            <div className="relative">
              <Button
                variant="outline"
                size="icon"
                onClick={() => setFiltersOpen(!filtersOpen)}
                data-testid="button-toggle-filters"
              >
                {filtersOpen ? <ChevronUp className="h-4 w-4" /> : <SlidersHorizontal className="h-4 w-4" />}
              </Button>
              {activeFilterCount > 0 && (
                <Badge
                  className="absolute -top-2 -right-2 h-5 min-w-[20px] flex items-center justify-center text-xs px-1"
                  data-testid="badge-filter-count"
                >
                  {activeFilterCount}
                </Badge>
              )}
            </div>
          </div>

          {gpsLat !== null && (
            <div className="mt-3 flex items-center gap-3 flex-wrap">
              <label className="text-sm text-muted-foreground whitespace-nowrap">
                Search radius: {searchRadius[0]} km
              </label>
              <div className="flex-1 min-w-[120px] max-w-[240px]">
                <Slider
                  value={searchRadius}
                  onValueChange={handleRadiusChange}
                  min={5}
                  max={200}
                  step={5}
                  data-testid="slider-search-radius"
                />
              </div>
            </div>
          )}

          {filtersOpen && (
            <div className="mt-3 pb-1 grid grid-cols-2 sm:grid-cols-3 gap-4">
              <div className="space-y-1.5">
                <label className="text-sm text-muted-foreground">Sort by</label>
                <Select value={sortBy} onValueChange={setSortBy}>
                  <SelectTrigger data-testid="select-sort">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="newest">Newest</SelectItem>
                    <SelectItem value="soonest">Soonest</SelectItem>
                    <SelectItem value="price_low">Price (low to high)</SelectItem>
                    <SelectItem value="price_high">Price (high to low)</SelectItem>
                    <SelectItem value="popular">Most popular</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-1.5">
                <label className="text-sm text-muted-foreground">Theme</label>
                <Select value={themeFilter} onValueChange={setThemeFilter}>
                  <SelectTrigger data-testid="select-theme">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {THEMES.map((t) => (
                      <SelectItem key={t} value={t}>
                        {t}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-1.5">
                <label className="text-sm text-muted-foreground">Max price: ${maxPrice[0]}</label>
                <Slider
                  value={maxPrice}
                  onValueChange={setMaxPrice}
                  max={500}
                  step={5}
                  data-testid="slider-max-price"
                />
              </div>

              <div className="space-y-1.5">
                <label className="text-sm text-muted-foreground">Crowd size</label>
                <Select value={crowdSize} onValueChange={setCrowdSize}>
                  <SelectTrigger data-testid="select-crowd-size">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="All">All</SelectItem>
                    <SelectItem value="Intimate (1-15)">Intimate (1-15)</SelectItem>
                    <SelectItem value="Medium (16-40)">Medium (16-40)</SelectItem>
                    <SelectItem value="Large (41+)">Large (41+)</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-1.5">
                <label className="text-sm text-muted-foreground">Date</label>
                <Select value={dateFilter} onValueChange={setDateFilter}>
                  <SelectTrigger data-testid="select-date-filter">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="All dates">All dates</SelectItem>
                    <SelectItem value="This week">This week</SelectItem>
                    <SelectItem value="This month">This month</SelectItem>
                    <SelectItem value="Next 3 months">Next 3 months</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-1.5 flex flex-col justify-end">
                <Button
                  variant={freeOnly ? "default" : "outline"}
                  className="w-full toggle-elevate"
                  onClick={() => setFreeOnly(!freeOnly)}
                  data-testid="button-free-only"
                >
                  <DollarSign className="h-4 w-4 mr-1" />
                  Free only
                </Button>
              </div>
            </div>
          )}
        </div>
      </header>

      <main className="max-w-5xl mx-auto px-4 py-6">
        {isLoading && offset === 0 ? (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            {Array.from({ length: 6 }).map((_, i) => (
              <PartyCardSkeleton key={i} />
            ))}
          </div>
        ) : filteredParties.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-20 text-center" data-testid="text-empty-state">
            <PartyPopper className="h-12 w-12 text-muted-foreground mb-4" />
            <h2 className="text-xl font-semibold mb-2">No parties found in your area</h2>
            <p className="text-muted-foreground">Try adjusting your filters or search terms</p>
          </div>
        ) : (
          <>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
              {filteredParties.map((party) => (
                <Link key={party.id} href={`/party/${party.id}`} data-testid={`link-party-${party.id}`}>
                  <Card className="overflow-visible hover-elevate cursor-pointer group">
                    <div className="relative h-48 overflow-hidden rounded-t-md">
                      <img
                        src={party.imageUrl || "/images/party-house.png"}
                        alt={party.title}
                        className="w-full h-full object-cover transition-transform duration-300 group-hover:scale-105"
                      />
                      <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent" />
                      <div className="absolute bottom-3 left-3 right-3 flex items-end justify-between gap-2">
                        <Badge variant="secondary" className="text-xs" data-testid={`badge-theme-${party.id}`}>
                          {party.theme}
                        </Badge>
                        {party.includesAlcohol && (
                          <Wine className="h-4 w-4 text-white/90" />
                        )}
                      </div>
                    </div>
                    <CardContent className="p-4 space-y-2">
                      <h3 className="font-semibold text-base leading-tight line-clamp-1" data-testid={`text-title-${party.id}`}>
                        {party.title}
                      </h3>
                      <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                        <Calendar className="h-3.5 w-3.5 shrink-0" />
                        <span className="truncate">{formatPartyDate(party.date)}</span>
                      </div>
                      <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                        <MapPin className="h-3.5 w-3.5 shrink-0" />
                        <span className="truncate">{party.locationName}, {party.city}</span>
                      </div>
                      <div className="flex items-center justify-between gap-2 pt-1 flex-wrap">
                        <span className="font-bold text-base" data-testid={`text-price-${party.id}`}>
                          {(party.price ?? 0) === 0 ? "FREE" : `$${party.price}`}
                        </span>
                        <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                          <Users className="h-3.5 w-3.5" />
                          <span>{party.attendeeCount ?? 0}/{party.maxGuests} guests</span>
                        </div>
                      </div>
                      <div className="flex items-center gap-2 pt-1 text-sm text-muted-foreground">
                        <Star className="h-3.5 w-3.5 text-primary" />
                        <span className="truncate">Hosted by {party.hostName || "Unknown Host"}</span>
                      </div>
                    </CardContent>
                  </Card>
                </Link>
              ))}
            </div>
            {hasMore && (
              <div className="flex justify-center mt-6">
                <Button
                  variant="outline"
                  onClick={handleLoadMore}
                  disabled={isLoading}
                  data-testid="button-load-more"
                >
                  {isLoading ? (
                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                  ) : null}
                  Load more
                </Button>
              </div>
            )}
          </>
        )}
      </main>
    </div>
  );
}

========================================
FILE: client/src/pages/party-detail-page.tsx
========================================
import { useState, useRef } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useParams, useLocation } from "wouter";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { Input } from "@/components/ui/input";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Skeleton } from "@/components/ui/skeleton";
import { ArrowLeft, MapPin, Calendar, Users, DollarSign, Wine, ShieldCheck, Star, Clock, Send, PartyPopper, CheckCircle2, Info, Loader2, Upload } from "lucide-react";
import { format } from "date-fns";
import type { Party, PartyRequest, User } from "@shared/schema";

interface EnrichedParty extends Party {
  hostName: string;
  hostAvatar: string;
  hostVerified: boolean;
  attendeeCount: number;
  hostRating?: number;
}

interface AttendeeInfo {
  id: string;
  username: string;
  fullName: string;
  avatar: string;
}

function formatPartyDate(dateStr: string) {
  try {
    return format(new Date(dateStr), "EEEE, MMM d, yyyy 'at' h:mm a");
  } catch {
    return dateStr;
  }
}

function DetailSkeleton() {
  return (
    <div className="min-h-screen bg-background">
      <Skeleton className="w-full h-64" />
      <div className="max-w-3xl mx-auto px-4 py-6 space-y-6">
        <Skeleton className="h-8 w-2/3" />
        <Skeleton className="h-5 w-1/2" />
        <Skeleton className="h-20 w-full" />
        <Skeleton className="h-40 w-full" />
      </div>
    </div>
  );
}

export default function PartyDetailPage() {
  const params = useParams<{ id: string }>();
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const { user, isAuthenticated } = useAuth();
  const [message, setMessage] = useState("");
  const [pledgedItems, setPledgedItems] = useState("");
  const [verifying, setVerifying] = useState(false);
  const [verificationResult, setVerificationResult] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const { data: party, isLoading: partyLoading } = useQuery<EnrichedParty>({
    queryKey: ["/api/parties", params.id],
  });

  const { data: attendees } = useQuery<AttendeeInfo[]>({
    queryKey: ["/api/parties", params.id, "attendees"],
    enabled: !!params.id,
  });

  const { data: myRequests } = useQuery<PartyRequest[]>({
    queryKey: ["/api/requests/mine"],
    enabled: isAuthenticated,
  });

  const { data: hostStats } = useQuery<{
    partiesAttended: number;
    partiesHosted: number;
    reviewCount: number;
    profileCompleteness: number;
  }>({
    queryKey: ["/api/users", party?.hostId, "stats"],
    enabled: !!party?.hostId,
  });

  const existingRequest = myRequests?.find((r) => r.partyId === params.id);
  const isHost = user?.id === party?.hostId;
  const isAttending = attendees?.some((a) => a.id === user?.id);

  const joinMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/parties/${params.id}/requests`, {
        message,
        pledgedItems,
      });
    },
    onSuccess: () => {
      toast({ title: "Request sent!", description: "The host will review your request." });
      setMessage("");
      setPledgedItems("");
      queryClient.invalidateQueries({ queryKey: ["/api/requests/mine"] });
    },
    onError: (error: Error) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  const handleVerifyAge = async (file: File) => {
    setVerifying(true);
    setVerificationResult(null);
    try {
      const base64 = await new Promise<string>((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result as string);
        reader.onerror = () => reject(new Error("Failed to read file"));
        reader.readAsDataURL(file);
      });
      const res = await apiRequest("POST", "/api/verify-age", { imageBase64: base64 });
      const data = await res.json();
      setVerificationResult(data.message || "Verification complete");
      toast({ title: "Verification complete", description: data.message });
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
    } catch (error: any) {
      toast({ title: "Verification failed", description: error.message, variant: "destructive" });
    } finally {
      setVerifying(false);
    }
  };

  if (partyLoading) {
    return <DetailSkeleton />;
  }

  if (!party) {
    return (
      <div className="min-h-screen bg-background flex flex-col items-center justify-center">
        <PartyPopper className="h-12 w-12 text-muted-foreground mb-4" />
        <h2 className="text-xl font-semibold mb-2">Party not found</h2>
        <Button variant="outline" onClick={() => setLocation("/browse")} data-testid="button-back-browse">
          Back to Browse
        </Button>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background pb-28">
      <div className="relative h-64 sm:h-80 overflow-hidden">
        <img
          src={party.imageUrl || "/images/party-house.png"}
          alt={party.title}
          className="w-full h-full object-cover"
        />
        <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-black/20" />
        <div className="absolute top-4 left-4">
          <Button
            variant="outline"
            size="icon"
            onClick={() => setLocation("/browse")}
            className="bg-black/30 backdrop-blur border-white/20 text-white"
            data-testid="button-back"
          >
            <ArrowLeft className="h-4 w-4" />
          </Button>
        </div>
        <div className="absolute bottom-4 left-4 right-4">
          <Badge variant="secondary" className="mb-2" data-testid="badge-party-theme">
            {party.theme}
          </Badge>
          <h1 className="text-2xl sm:text-3xl font-bold text-white mb-1" data-testid="text-party-title">
            {party.title}
          </h1>
          <div className="flex items-center gap-2 text-white/80 text-sm">
            <Calendar className="h-4 w-4" />
            <span>{formatPartyDate(party.date)}</span>
          </div>
        </div>
      </div>

      <div className="max-w-3xl mx-auto px-4 py-6 space-y-6">
        <Card>
          <CardContent className="p-4 space-y-4">
            <div className="flex items-center gap-3">
              <Avatar>
                <AvatarImage src={party.hostAvatar} />
                <AvatarFallback>{party.hostName?.charAt(0)?.toUpperCase() || "H"}</AvatarFallback>
              </Avatar>
              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-1.5 flex-wrap">
                  <span className="font-semibold" data-testid="text-host-name">{party.hostName}</span>
                  {party.hostVerified && (
                    <ShieldCheck className="h-4 w-4 text-primary shrink-0" />
                  )}
                </div>
                {(party.hostRating ?? 0) > 0 && (
                  <div className="flex items-center gap-1 text-sm text-muted-foreground">
                    <Star className="h-3.5 w-3.5 text-primary" />
                    <span>{party.hostRating?.toFixed(1)}</span>
                  </div>
                )}
                {hostStats && (
                  <div className="flex items-center gap-2 flex-wrap mt-1">
                    <Badge variant="secondary" data-testid="badge-host-parties">
                      <PartyPopper className="h-3 w-3 mr-1" />
                      {hostStats.partiesHosted} parties hosted
                    </Badge>
                    <Badge variant="secondary" data-testid="badge-host-reviews">
                      <Star className="h-3 w-3 mr-1" />
                      {hostStats.reviewCount} reviews
                    </Badge>
                    {party.hostVerified && (
                      <Badge variant="secondary" data-testid="badge-host-verified">
                        <ShieldCheck className="h-3 w-3 mr-1" />
                        Verified
                      </Badge>
                    )}
                  </div>
                )}
              </div>
            </div>

            <div className="grid grid-cols-2 gap-3">
              <div className="flex items-center gap-2 text-sm">
                <MapPin className="h-4 w-4 text-muted-foreground shrink-0" />
                <span className="truncate" data-testid="text-location">{party.locationName}, {party.city}</span>
              </div>
              <div className="flex items-center gap-2 text-sm">
                <DollarSign className="h-4 w-4 text-muted-foreground shrink-0" />
                <span className="font-semibold" data-testid="text-price">
                  {(party.price ?? 0) === 0 ? "FREE" : `$${party.price}`}
                </span>
              </div>
              <div className="flex items-center gap-2 text-sm">
                <Users className="h-4 w-4 text-muted-foreground shrink-0" />
                <span data-testid="text-guests">{party.attendeeCount}/{party.maxGuests} guests</span>
              </div>
              {party.includesAlcohol && (
                <div className="flex items-center gap-2 text-sm">
                  <Wine className="h-4 w-4 text-muted-foreground shrink-0" />
                  <span>Includes alcohol</span>
                </div>
              )}
            </div>
          </CardContent>
        </Card>

        {party.description && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-2">About this party</h2>
              <p className="text-sm text-muted-foreground whitespace-pre-wrap" data-testid="text-description">
                {party.description}
              </p>
            </CardContent>
          </Card>
        )}

        {party.houseRules && party.houseRules.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-2">House Rules</h2>
              <p className="text-sm text-muted-foreground whitespace-pre-wrap" data-testid="text-house-rules">
                {party.houseRules}
              </p>
            </CardContent>
          </Card>
        )}

        {party.vibe && party.vibe.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-2">Vibe</h2>
              <p className="text-sm text-muted-foreground" data-testid="text-vibe">
                {party.vibe}
              </p>
            </CardContent>
          </Card>
        )}

        {party.targetGuests && party.targetGuests.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-2">Who Should Come</h2>
              <p className="text-sm text-muted-foreground" data-testid="text-target-guests">
                {party.targetGuests}
              </p>
            </CardContent>
          </Card>
        )}

        {party.whatToBring && party.whatToBring.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-2">What to bring</h2>
              <div className="flex flex-wrap gap-2">
                {party.whatToBring.map((item, i) => (
                  <Badge key={i} variant="secondary" data-testid={`badge-bring-${i}`}>
                    {item}
                  </Badge>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {party.galleryUrls && party.galleryUrls.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-3">Gallery</h2>
              <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                {party.galleryUrls.map((url, i) => (
                  <div key={i} className="aspect-square overflow-hidden rounded-md">
                    <img
                      src={url}
                      alt={`Gallery ${i + 1}`}
                      className="w-full h-full object-cover"
                      data-testid={`img-gallery-${i}`}
                    />
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {attendees && attendees.length > 0 && (
          <Card>
            <CardContent className="p-4">
              <h2 className="font-semibold mb-3">Attendees ({attendees.length})</h2>
              <div className="flex flex-wrap gap-3">
                {attendees.map((attendee) => (
                  <div key={attendee.id} className="flex items-center gap-2" data-testid={`attendee-${attendee.id}`}>
                    <Avatar className="h-8 w-8">
                      <AvatarImage src={attendee.avatar} />
                      <AvatarFallback>{attendee.fullName?.charAt(0)?.toUpperCase() || "?"}</AvatarFallback>
                    </Avatar>
                    <span className="text-sm">{attendee.fullName}</span>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {isAuthenticated && !isHost && party.includesAlcohol && (
          <Card>
            <CardContent className="p-4">
              {user?.isAgeVerified ? (
                <div className="flex items-center gap-2" data-testid="badge-age-verified">
                  <ShieldCheck className="h-5 w-5 text-green-500" />
                  <span className="font-medium text-green-500">Age Verified</span>
                </div>
              ) : (
                <div className="space-y-3">
                  <div className="flex items-start gap-2">
                    <ShieldCheck className="h-5 w-5 text-muted-foreground shrink-0 mt-0.5" />
                    <p className="text-sm text-muted-foreground" data-testid="text-verification-required">
                      This party includes alcohol. Age verification (18+) is required to join.
                    </p>
                  </div>
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept="image/*"
                    capture="environment"
                    className="hidden"
                    data-testid="input-id-upload"
                    onChange={(e) => {
                      const file = e.target.files?.[0];
                      if (file) handleVerifyAge(file);
                    }}
                  />
                  <Button
                    variant="outline"
                    className="w-full"
                    onClick={() => fileInputRef.current?.click()}
                    disabled={verifying}
                    data-testid="button-verify-age"
                  >
                    {verifying ? (
                      <Loader2 className="h-4 w-4 animate-spin mr-2" />
                    ) : (
                      <Upload className="h-4 w-4 mr-2" />
                    )}
                    {verifying ? "Verifying..." : "Upload ID to Verify Age"}
                  </Button>
                  {verificationResult && (
                    <p className="text-sm text-muted-foreground" data-testid="text-verification-result">
                      {verificationResult}
                    </p>
                  )}
                </div>
              )}
            </CardContent>
          </Card>
        )}

        {isAuthenticated && !isHost && !isAttending && !existingRequest && (
          <Card>
            <CardContent className="p-4">
              <div className="flex items-start gap-2 mb-3">
                <Info className="h-4 w-4 text-muted-foreground shrink-0 mt-0.5" />
                <div>
                  <p className="text-sm font-medium text-muted-foreground">Tips for a great experience:</p>
                  <ul className="text-xs text-muted-foreground mt-1 space-y-0.5 list-disc list-inside">
                    <li>Arrive on time</li>
                    <li>Bring what you promised</li>
                    <li>Respect the host's space</li>
                    <li>Let the host know if plans change</li>
                  </ul>
                </div>
              </div>
            </CardContent>
          </Card>
        )}

        {isAuthenticated && !isHost && (
          <Card>
            <CardContent className="p-4">
              {isAttending ? (
                <div className="flex items-center gap-2 text-center justify-center py-4" data-testid="text-attending">
                  <CheckCircle2 className="h-5 w-5 text-green-500" />
                  <span className="font-semibold text-green-500">You're Going!</span>
                </div>
              ) : existingRequest ? (
                <div className="flex items-center gap-2 text-center justify-center py-4" data-testid="text-pending">
                  <Clock className="h-5 w-5 text-muted-foreground" />
                  <span className="text-muted-foreground">
                    Request {existingRequest.status === "pending" ? "pending" : existingRequest.status}
                  </span>
                </div>
              ) : (
                <div className="space-y-3">
                  <h2 className="font-semibold">Request to Join</h2>
                  <Textarea
                    placeholder="Say hi to the host! Why would you be a great guest?"
                    value={message}
                    onChange={(e) => setMessage(e.target.value)}
                    data-testid="input-request-message"
                  />
                  <Input
                    placeholder="What will you bring? (optional)"
                    value={pledgedItems}
                    onChange={(e) => setPledgedItems(e.target.value)}
                    data-testid="input-pledged-items"
                  />
                  {party.includesAlcohol && !user?.isAgeVerified && (
                    <p className="text-sm text-muted-foreground" data-testid="text-verification-needed">
                      Age verification is required to join this party.
                    </p>
                  )}
                  <Button
                    onClick={() => joinMutation.mutate()}
                    disabled={joinMutation.isPending || (party.includesAlcohol && !user?.isAgeVerified)}
                    className="w-full"
                    data-testid="button-request-join"
                  >
                    <Send className="h-4 w-4 mr-2" />
                    {joinMutation.isPending ? "Sending..." : "Request to Join"}
                  </Button>
                </div>
              )}
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  );
}

========================================
FILE: client/src/pages/create-party-page.tsx
========================================
import { useState, useRef } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation } from "@tanstack/react-query";
import { useLocation, Link } from "wouter";
import { z } from "zod";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { ArrowLeft, Plus, X, PartyPopper, Info, Camera, Upload } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";

const THEMES = [
  "Cyberpunk/Neon",
  "Cocktail/Lounge",
  "Pool Party",
  "Indie/Bohemian",
  "Festival/EDM",
  "House Party",
  "Dinner Party",
  "Outdoor/BBQ",
  "Game Night",
  "Karaoke",
  "Other",
];

const COUNTRY_DATA: Record<string, string[]> = {
  "USA": ["New York", "Los Angeles", "Chicago", "Miami", "Austin", "San Francisco", "Seattle", "Denver"],
  "United Kingdom": ["London", "Manchester", "Birmingham", "Edinburgh", "Bristol", "Glasgow", "Liverpool"],
  "Germany": ["Berlin", "Munich", "Hamburg", "Cologne", "Frankfurt", "Stuttgart", "Dsseldorf"],
  "Romania": ["Bucharest", "Cluj-Napoca", "Timioara", "Iai", "Constana", "Braov", "Sibiu", "Vama Veche"],
};

const createPartySchema = z.object({
  title: z.string().min(1, "Title is required"),
  theme: z.string().min(1, "Theme is required"),
  description: z.string().min(1, "Description is required"),
  date: z.string().min(1, "Date is required"),
  time: z.string().min(1, "Time is required"),
  locationName: z.string().min(1, "Location name is required"),
  country: z.string().min(1, "Country is required"),
  city: z.string().min(1, "City is required"),
  exactAddress: z.string().optional(),
  maxGuests: z.number().min(1, "Must allow at least 1 guest"),
  price: z.number().min(0, "Price cannot be negative"),
  imageUrl: z.string().optional(),
  includesAlcohol: z.boolean(),
  houseRules: z.string().optional(),
  targetGuests: z.string().optional(),
  vibe: z.string().optional(),
});

type CreatePartyForm = z.infer<typeof createPartySchema>;

export default function CreatePartyPage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [, setLocation] = useLocation();
  const [whatToBring, setWhatToBring] = useState<string[]>([]);
  const [bringItem, setBringItem] = useState("");
  const [imageUploading, setImageUploading] = useState(false);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const imageInputRef = useRef<HTMLInputElement>(null);

  async function handleImageUpload(file: File) {
    setImageUploading(true);
    try {
      const formData = new FormData();
      formData.append("image", file);
      const res = await fetch("/api/upload/party-image", {
        method: "POST",
        body: formData,
        credentials: "include",
      });
      if (!res.ok) throw new Error("Upload failed");
      const data = await res.json();
      form.setValue("imageUrl", data.url);
      setImagePreview(data.url);
      toast({ title: "Image uploaded", description: "Party image has been set." });
    } catch {
      toast({ title: "Upload failed", description: "Could not upload image. Please try again.", variant: "destructive" });
    } finally {
      setImageUploading(false);
    }
  }

  const form = useForm<CreatePartyForm>({
    resolver: zodResolver(createPartySchema),
    defaultValues: {
      title: "",
      theme: "",
      description: "",
      date: "",
      time: "",
      locationName: "",
      country: "",
      city: "",
      exactAddress: "",
      maxGuests: 20,
      price: 0,
      imageUrl: "",
      includesAlcohol: false,
      houseRules: "",
      targetGuests: "",
      vibe: "",
    },
  });

  const selectedCountry = form.watch("country");
  const cities = selectedCountry ? COUNTRY_DATA[selectedCountry] ?? [] : [];

  const createMutation = useMutation({
    mutationFn: async (values: CreatePartyForm) => {
      const dateTime = `${values.date} ${values.time}`;
      await apiRequest("POST", "/api/parties", {
        hostId: user?.id,
        title: values.title,
        theme: values.theme,
        description: values.description,
        date: dateTime,
        locationName: values.locationName,
        city: values.city,
        country: values.country,
        exactAddress: values.exactAddress || "",
        latitude: 40.7128,
        longitude: -73.9626,
        maxGuests: values.maxGuests,
        price: values.price,
        whatToBring,
        imageUrl: values.imageUrl || "/images/party-neon-techno.png",
        galleryUrls: [],
        includesAlcohol: values.includesAlcohol,
        houseRules: values.houseRules || "",
        targetGuests: values.targetGuests || "",
        vibe: values.vibe || "",
      });
    },
    onSuccess: () => {
      toast({ title: "Party created!", description: "Your party has been published." });
      setLocation("/host");
    },
    onError: (error: Error) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  function addBringItem() {
    const trimmed = bringItem.trim();
    if (trimmed && !whatToBring.includes(trimmed)) {
      setWhatToBring([...whatToBring, trimmed]);
      setBringItem("");
    }
  }

  function removeBringItem(item: string) {
    setWhatToBring(whatToBring.filter((i) => i !== item));
  }

  return (
    <div className="min-h-screen bg-background pb-28">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/browse">
            <Button variant="ghost" size="icon" data-testid="button-back">
              <ArrowLeft className="h-5 w-5" />
            </Button>
          </Link>
          <div className="flex items-center gap-2">
            <PartyPopper className="h-5 w-5 text-primary" />
            <h1 className="text-lg font-bold">Create a Party</h1>
          </div>
        </div>
      </header>

      <main className="max-w-2xl mx-auto px-4 py-6">
        <Form {...form}>
          <form onSubmit={form.handleSubmit((v) => createMutation.mutate(v))} className="space-y-6">
            <Card className="bg-primary/5 border-0" data-testid="card-host-tips">
              <CardContent className="p-4">
                <div className="flex items-start gap-2">
                  <Info className="h-4 w-4 text-muted-foreground shrink-0 mt-0.5" />
                  <div>
                    <p className="text-sm font-medium text-muted-foreground">Tips for hosting a great party:</p>
                    <ul className="text-xs text-muted-foreground mt-1 space-y-0.5 list-disc list-inside">
                      <li>Be specific about what guests should expect</li>
                      <li>Set clear house rules upfront</li>
                      <li>Respond to requests quickly</li>
                      <li>Welcome your guests warmly</li>
                    </ul>
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="text-base">Basic Info</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <FormField
                  control={form.control}
                  name="title"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Title</FormLabel>
                      <FormControl>
                        <Input placeholder="Give your party a catchy name that stands out" {...field} data-testid="input-title" />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="theme"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Theme</FormLabel>
                      <Select onValueChange={field.onChange} value={field.value}>
                        <FormControl>
                          <SelectTrigger data-testid="select-theme">
                            <SelectValue placeholder="Select a theme" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {THEMES.map((t) => (
                            <SelectItem key={t} value={t}>{t}</SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="description"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Description</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder="Paint a picture of your party. What will guests experience? What makes it special? Include the atmosphere, activities, and any highlights."
                          className="min-h-[100px]"
                          {...field}
                          data-testid="input-description"
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="text-base">Vibe & Guidelines</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <FormField
                  control={form.control}
                  name="vibe"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Vibe</FormLabel>
                      <FormControl>
                        <Input placeholder="What's the vibe? e.g., Chill, High-energy, Intimate, Wild..." {...field} data-testid="input-vibe" />
                      </FormControl>
                      <p className="text-sm text-muted-foreground">Help guests know what to expect</p>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="targetGuests"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Target Guests</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder="Who should come? e.g., Music lovers, ages 21-35, people who love dancing..."
                          {...field}
                          data-testid="input-target-guests"
                        />
                      </FormControl>
                      <p className="text-sm text-muted-foreground">Describe your ideal guest to attract the right crowd</p>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="houseRules"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>House Rules</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder="e.g., No shoes inside, BYOB, respect the neighbors, clean up after yourself..."
                          {...field}
                          data-testid="input-house-rules"
                        />
                      </FormControl>
                      <p className="text-sm text-muted-foreground">Set clear expectations so everyone has a great time</p>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="text-base">Date & Time</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="date"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Date</FormLabel>
                        <FormControl>
                          <Input type="date" {...field} data-testid="input-date" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <FormField
                    control={form.control}
                    name="time"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Time</FormLabel>
                        <FormControl>
                          <Input type="time" {...field} data-testid="input-time" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="text-base">Location</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <FormField
                  control={form.control}
                  name="locationName"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Location Name</FormLabel>
                      <FormControl>
                        <Input placeholder="e.g., My Rooftop, The Warehouse, Beach House" {...field} data-testid="input-location-name" />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="country"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Country</FormLabel>
                        <Select
                          onValueChange={(val) => {
                            field.onChange(val);
                            form.setValue("city", "");
                          }}
                          value={field.value}
                        >
                          <FormControl>
                            <SelectTrigger data-testid="select-country">
                              <SelectValue placeholder="Select country" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {Object.keys(COUNTRY_DATA).map((c) => (
                              <SelectItem key={c} value={c}>{c}</SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="city"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>City</FormLabel>
                        <Select onValueChange={field.onChange} value={field.value} disabled={!selectedCountry}>
                          <FormControl>
                            <SelectTrigger data-testid="select-city">
                              <SelectValue placeholder="Select city" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {cities.map((c) => (
                              <SelectItem key={c} value={c}>{c}</SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={form.control}
                  name="exactAddress"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Exact Address (optional)</FormLabel>
                      <FormControl>
                        <Input placeholder="Street address" {...field} data-testid="input-exact-address" />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className="text-base">Details</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <FormField
                    control={form.control}
                    name="maxGuests"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Max Guests</FormLabel>
                        <FormControl>
                          <Input
                            type="number"
                            min={1}
                            {...field}
                            onChange={(e) => field.onChange(parseInt(e.target.value) || 0)}
                            data-testid="input-max-guests"
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="price"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Price ($)</FormLabel>
                        <FormControl>
                          <Input
                            type="number"
                            min={0}
                            {...field}
                            onChange={(e) => field.onChange(parseInt(e.target.value) || 0)}
                            data-testid="input-price"
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <div className="space-y-2">
                  <FormLabel>What to Bring</FormLabel>
                  <div className="flex items-center gap-2">
                    <Input
                      placeholder="e.g. Drinks, Snacks"
                      value={bringItem}
                      onChange={(e) => setBringItem(e.target.value)}
                      onKeyDown={(e) => {
                        if (e.key === "Enter") {
                          e.preventDefault();
                          addBringItem();
                        }
                      }}
                      data-testid="input-what-to-bring"
                    />
                    <Button type="button" variant="outline" onClick={addBringItem} data-testid="button-add-bring-item">
                      <Plus className="h-4 w-4" />
                    </Button>
                  </div>
                  {whatToBring.length > 0 && (
                    <div className="flex flex-wrap gap-2 pt-1">
                      {whatToBring.map((item) => (
                        <Badge key={item} variant="secondary" className="gap-1" data-testid={`badge-bring-${item}`}>
                          {item}
                          <button
                            type="button"
                            onClick={() => removeBringItem(item)}
                            className="ml-1"
                            data-testid={`button-remove-bring-${item}`}
                          >
                            <X className="h-3 w-3" />
                          </button>
                        </Badge>
                      ))}
                    </div>
                  )}
                </div>

                <FormField
                  control={form.control}
                  name="includesAlcohol"
                  render={({ field }) => (
                    <FormItem className="flex items-center justify-between gap-2 rounded-md border p-3">
                      <FormLabel className="cursor-pointer">Includes Alcohol</FormLabel>
                      <FormControl>
                        <Switch
                          checked={field.value}
                          onCheckedChange={field.onChange}
                          data-testid="switch-includes-alcohol"
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <div className="space-y-2">
                  <FormLabel>Party Image (optional)</FormLabel>
                  <input
                    ref={imageInputRef}
                    type="file"
                    accept="image/*"
                    capture="environment"
                    className="hidden"
                    data-testid="input-party-image-file"
                    onChange={(e) => {
                      const file = e.target.files?.[0];
                      if (file) handleImageUpload(file);
                    }}
                  />
                  {imagePreview || form.getValues("imageUrl") ? (
                    <div className="relative rounded-md overflow-visible">
                      <img
                        src={imagePreview || form.getValues("imageUrl")}
                        alt="Party preview"
                        className="w-full h-48 object-cover rounded-md"
                        data-testid="img-party-preview"
                      />
                      <div className="flex items-center gap-2 mt-2">
                        <Button
                          type="button"
                          variant="outline"
                          onClick={() => imageInputRef.current?.click()}
                          disabled={imageUploading}
                          data-testid="button-change-party-image"
                        >
                          <Camera className="h-4 w-4 mr-2" />
                          {imageUploading ? "Uploading..." : "Change Image"}
                        </Button>
                        <Button
                          type="button"
                          variant="ghost"
                          onClick={() => {
                            form.setValue("imageUrl", "");
                            setImagePreview(null);
                          }}
                          data-testid="button-remove-party-image"
                        >
                          <X className="h-4 w-4 mr-2" />
                          Remove
                        </Button>
                      </div>
                    </div>
                  ) : (
                    <Button
                      type="button"
                      variant="outline"
                      className="w-full h-32 border-dashed flex flex-col gap-2"
                      onClick={() => imageInputRef.current?.click()}
                      disabled={imageUploading}
                      data-testid="button-upload-party-image"
                    >
                      {imageUploading ? (
                        <span className="text-sm text-muted-foreground">Uploading...</span>
                      ) : (
                        <>
                          <Upload className="h-6 w-6 text-muted-foreground" />
                          <span className="text-sm text-muted-foreground">Upload a photo or take one</span>
                        </>
                      )}
                    </Button>
                  )}
                </div>
              </CardContent>
            </Card>

            <Button
              type="submit"
              size="lg"
              className="w-full"
              disabled={createMutation.isPending}
              data-testid="button-publish-party"
            >
              {createMutation.isPending ? "Publishing..." : "Publish Party"}
            </Button>
          </form>
        </Form>
      </main>
    </div>
  );
}

========================================
FILE: client/src/pages/host-page.tsx
========================================
import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Link } from "wouter";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Skeleton } from "@/components/ui/skeleton";
import { Plus, Calendar, Users, MapPin, Check, X, MessageSquare, Gift, ChevronDown, ChevronUp, ArrowLeft, PartyPopper } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { format } from "date-fns";
import type { Party } from "@shared/schema";

function formatPartyDate(dateStr: string) {
  try {
    return format(new Date(dateStr), "MMM d, yyyy 'at' h:mm a");
  } catch {
    return dateStr;
  }
}

interface RequestWithUser {
  id: string;
  partyId: string;
  userId: string;
  message: string;
  pledgedItems: string;
  status: string;
  user?: {
    id: string;
    fullName: string;
    avatar: string;
    nickname: string;
  };
}

function PartyRequestsList({ partyId }: { partyId: string }) {
  const { toast } = useToast();

  const { data: requests, isLoading } = useQuery<RequestWithUser[]>({
    queryKey: ["/api/parties", partyId, "requests"],
  });

  const updateStatusMutation = useMutation({
    mutationFn: async ({ requestId, status }: { requestId: string; status: string }) => {
      await apiRequest("PATCH", `/api/requests/${requestId}/status`, { status });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/parties", partyId, "requests"] });
      queryClient.invalidateQueries({ queryKey: ["/api/parties/host/mine"] });
      toast({ title: "Request updated" });
    },
    onError: (error: Error) => {
      toast({ title: "Error", description: error.message, variant: "destructive" });
    },
  });

  const pendingRequests = requests?.filter((r) => r.status === "pending") ?? [];

  if (isLoading) {
    return (
      <div className="space-y-3 pt-3">
        {Array.from({ length: 2 }).map((_, i) => (
          <div key={i} className="flex items-center gap-3">
            <Skeleton className="h-10 w-10 rounded-full" />
            <div className="flex-1 space-y-1">
              <Skeleton className="h-4 w-24" />
              <Skeleton className="h-3 w-40" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  if (pendingRequests.length === 0) {
    return (
      <p className="text-sm text-muted-foreground pt-3" data-testid="text-no-pending-requests">
        No pending requests
      </p>
    );
  }

  return (
    <div className="space-y-3 pt-3">
      {pendingRequests.map((req) => (
        <div
          key={req.id}
          className="flex items-start gap-3 rounded-md border p-3"
          data-testid={`card-request-${req.id}`}
        >
          <Avatar>
            <AvatarImage src={req.user?.avatar} />
            <AvatarFallback>{(req.user?.fullName || "?")[0]}</AvatarFallback>
          </Avatar>
          <div className="flex-1 min-w-0 space-y-1">
            <p className="font-medium text-sm" data-testid={`text-requester-name-${req.id}`}>
              {req.user?.fullName || req.user?.nickname || "Unknown"}
            </p>
            {req.message && (
              <div className="flex items-start gap-1.5 text-sm text-muted-foreground">
                <MessageSquare className="h-3.5 w-3.5 shrink-0 mt-0.5" />
                <span className="line-clamp-2">{req.message}</span>
              </div>
            )}
            {req.pledgedItems && (
              <div className="flex items-start gap-1.5 text-sm text-muted-foreground">
                <Gift className="h-3.5 w-3.5 shrink-0 mt-0.5" />
                <span>{req.pledgedItems}</span>
              </div>
            )}
          </div>
          <div className="flex items-center gap-1 shrink-0">
            <Button
              size="icon"
              variant="ghost"
              onClick={() => updateStatusMutation.mutate({ requestId: req.id, status: "accepted" })}
              disabled={updateStatusMutation.isPending}
              data-testid={`button-accept-request-${req.id}`}
            >
              <Check className="h-4 w-4 text-green-500" />
            </Button>
            <Button
              size="icon"
              variant="ghost"
              onClick={() => updateStatusMutation.mutate({ requestId: req.id, status: "declined" })}
              disabled={updateStatusMutation.isPending}
              data-testid={`button-decline-request-${req.id}`}
            >
              <X className="h-4 w-4 text-red-500" />
            </Button>
          </div>
        </div>
      ))}
    </div>
  );
}

function HostedPartyCard({ party }: { party: Party & { attendeeCount?: number } }) {
  const [expanded, setExpanded] = useState(false);

  return (
    <Card className="overflow-visible" data-testid={`card-hosted-party-${party.id}`}>
      <div className="flex gap-4 p-4">
        <div className="w-24 h-24 rounded-md overflow-hidden shrink-0">
          <img
            src={party.imageUrl || "/images/party-house.png"}
            alt={party.title}
            className="w-full h-full object-cover"
          />
        </div>
        <div className="flex-1 min-w-0 space-y-1">
          <h3 className="font-semibold leading-tight line-clamp-1" data-testid={`text-party-title-${party.id}`}>
            {party.title}
          </h3>
          <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
            <Calendar className="h-3.5 w-3.5 shrink-0" />
            <span className="truncate">{formatPartyDate(party.date)}</span>
          </div>
          <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
            <MapPin className="h-3.5 w-3.5 shrink-0" />
            <span className="truncate">{party.locationName}, {party.city}</span>
          </div>
          <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
            <Users className="h-3.5 w-3.5 shrink-0" />
            <span>{party.attendeeCount ?? 0}/{party.maxGuests} guests</span>
          </div>
        </div>
      </div>
      <div className="border-t px-4 py-2">
        <Button
          variant="ghost"
          className="w-full justify-between"
          onClick={() => setExpanded(!expanded)}
          data-testid={`button-toggle-requests-${party.id}`}
        >
          <span className="text-sm">Join Requests</span>
          {expanded ? <ChevronUp className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />}
        </Button>
        {expanded && (
          <div className="pb-3">
            <PartyRequestsList partyId={party.id} />
          </div>
        )}
      </div>
    </Card>
  );
}

function HostPageSkeleton() {
  return (
    <div className="space-y-4">
      {Array.from({ length: 3 }).map((_, i) => (
        <Card key={i} className="overflow-visible">
          <div className="flex gap-4 p-4">
            <Skeleton className="w-24 h-24 rounded-md" />
            <div className="flex-1 space-y-2">
              <Skeleton className="h-5 w-3/4" />
              <Skeleton className="h-4 w-1/2" />
              <Skeleton className="h-4 w-2/3" />
            </div>
          </div>
        </Card>
      ))}
    </div>
  );
}

export default function HostPage() {
  const { user } = useAuth();

  const { data: parties, isLoading } = useQuery<(Party & { attendeeCount?: number })[]>({
    queryKey: ["/api/parties/host/mine"],
  });

  return (
    <div className="min-h-screen bg-background pb-28">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center justify-between gap-3 flex-wrap">
          <div className="flex items-center gap-3">
            <Link href="/browse">
              <Button variant="ghost" size="icon" data-testid="button-back">
                <ArrowLeft className="h-5 w-5" />
              </Button>
            </Link>
            <h1 className="text-lg font-bold">My Hosted Parties</h1>
          </div>
          <Link href="/create-party">
            <Button data-testid="button-create-party">
              <Plus className="h-4 w-4 mr-2" />
              Create Party
            </Button>
          </Link>
        </div>
      </header>

      <main className="max-w-2xl mx-auto px-4 py-6 space-y-4">
        {isLoading ? (
          <HostPageSkeleton />
        ) : !parties || parties.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-20 text-center" data-testid="text-empty-state">
            <PartyPopper className="h-12 w-12 text-muted-foreground mb-4" />
            <h2 className="text-xl font-semibold mb-2">No parties yet</h2>
            <p className="text-muted-foreground mb-6">Create your first party and start hosting!</p>
            <Link href="/create-party">
              <Button data-testid="button-create-party-empty">
                <Plus className="h-4 w-4 mr-2" />
                Create a Party
              </Button>
            </Link>
          </div>
        ) : (
          parties.map((party) => (
            <HostedPartyCard key={party.id} party={party} />
          ))
        )}
      </main>
    </div>
  );
}

========================================
FILE: client/src/pages/attending-page.tsx
========================================
import { useQuery } from "@tanstack/react-query";
import { Link } from "wouter";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Calendar, MapPin, Users, PartyPopper, DollarSign, ArrowLeft } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { format } from "date-fns";
import type { Party } from "@shared/schema";

interface AttendingParty extends Party {
  hostName?: string;
  attendeeCount?: number;
}

function formatPartyDate(dateStr: string) {
  try {
    return format(new Date(dateStr), "MMM d, yyyy 'at' h:mm a");
  } catch {
    return dateStr;
  }
}

function AttendingCardSkeleton() {
  return (
    <Card className="overflow-visible">
      <div className="flex gap-4 p-4">
        <Skeleton className="w-24 h-24 rounded-md" />
        <div className="flex-1 space-y-2">
          <Skeleton className="h-5 w-3/4" />
          <Skeleton className="h-4 w-1/2" />
          <Skeleton className="h-4 w-2/3" />
          <Skeleton className="h-4 w-1/3" />
        </div>
      </div>
    </Card>
  );
}

export default function AttendingPage() {
  const { user } = useAuth();

  const { data: parties, isLoading } = useQuery<AttendingParty[]>({
    queryKey: ["/api/parties/attending/mine"],
  });

  return (
    <div className="min-h-screen bg-background pb-28">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/browse">
            <Button variant="ghost" size="icon" data-testid="button-back">
              <ArrowLeft className="h-5 w-5" />
            </Button>
          </Link>
          <h1 className="text-lg font-bold">Attending</h1>
        </div>
      </header>

      <main className="max-w-2xl mx-auto px-4 py-6 space-y-4">
        {isLoading ? (
          <div className="space-y-4">
            {Array.from({ length: 3 }).map((_, i) => (
              <AttendingCardSkeleton key={i} />
            ))}
          </div>
        ) : !parties || parties.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-20 text-center" data-testid="text-empty-state">
            <PartyPopper className="h-12 w-12 text-muted-foreground mb-4" />
            <h2 className="text-xl font-semibold mb-2">No parties yet</h2>
            <p className="text-muted-foreground mb-6">Browse parties and request to join!</p>
            <Link href="/browse">
              <Button data-testid="button-browse-parties">Browse Parties</Button>
            </Link>
          </div>
        ) : (
          parties.map((party) => (
            <Link key={party.id} href={`/party/${party.id}`} data-testid={`link-party-${party.id}`}>
              <Card className="overflow-visible hover-elevate cursor-pointer">
                <div className="flex gap-4 p-4">
                  <div className="w-24 h-24 rounded-md overflow-hidden shrink-0">
                    <img
                      src={party.imageUrl || "/images/party-house.png"}
                      alt={party.title}
                      className="w-full h-full object-cover"
                    />
                  </div>
                  <div className="flex-1 min-w-0 space-y-1">
                    <h3 className="font-semibold leading-tight line-clamp-1" data-testid={`text-party-title-${party.id}`}>
                      {party.title}
                    </h3>
                    <Badge variant="secondary" className="text-xs" data-testid={`badge-theme-${party.id}`}>
                      {party.theme}
                    </Badge>
                    <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                      <Calendar className="h-3.5 w-3.5 shrink-0" />
                      <span className="truncate">{formatPartyDate(party.date)}</span>
                    </div>
                    <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                      <MapPin className="h-3.5 w-3.5 shrink-0" />
                      <span className="truncate">{party.locationName}, {party.city}</span>
                    </div>
                    <div className="flex items-center gap-3 flex-wrap">
                      <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
                        <Users className="h-3.5 w-3.5" />
                        <span>{party.attendeeCount ?? 0}/{party.maxGuests}</span>
                      </div>
                      <span className="text-sm font-medium" data-testid={`text-price-${party.id}`}>
                        {(party.price ?? 0) === 0 ? "FREE" : `$${party.price}`}
                      </span>
                    </div>
                    {party.hostName && (
                      <p className="text-xs text-muted-foreground">Hosted by {party.hostName}</p>
                    )}
                  </div>
                </div>
              </Card>
            </Link>
          ))
        )}
      </main>
    </div>
  );
}

========================================
FILE: client/src/pages/profile-page.tsx
========================================
import { useState, useEffect, useRef } from "react";
import { useQuery } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Skeleton } from "@/components/ui/skeleton";
import { Separator } from "@/components/ui/separator";
import { Star, ShieldCheck, Settings, LogOut, Award, UserCheck, Calendar, PartyPopper, Camera } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import type { Review } from "@shared/schema";

function RatingStars({ rating }: { rating: number }) {
  return (
    <div className="flex items-center gap-0.5">
      {[...Array(5)].map((_, i) => (
        <Star
          key={i}
          size={14}
          className={i < Math.floor(rating) ? "fill-yellow-500 text-yellow-500" : "text-muted-foreground"}
        />
      ))}
      <span className="text-sm text-muted-foreground ml-1">{rating.toFixed(1)}</span>
    </div>
  );
}

function getInitials(name: string) {
  return name
    .split(" ")
    .map((n) => n[0])
    .join("")
    .toUpperCase()
    .slice(0, 2);
}

export default function ProfilePage() {
  const [, setLocation] = useLocation();
  const { user, isLoading, logout } = useAuth();
  const { toast } = useToast();
  const [reviewTab, setReviewTab] = useState("host");
  const [avatarUploading, setAvatarUploading] = useState(false);
  const avatarInputRef = useRef<HTMLInputElement>(null);

  async function handleAvatarUpload(file: File) {
    if (!user) return;
    setAvatarUploading(true);
    try {
      const formData = new FormData();
      formData.append("image", file);
      const res = await fetch("/api/upload/avatar", {
        method: "POST",
        body: formData,
        credentials: "include",
      });
      if (!res.ok) throw new Error("Upload failed");
      const data = await res.json();
      await apiRequest("PATCH", `/api/users/${user.id}`, { avatar: data.url });
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      toast({ title: "Avatar updated", description: "Your profile photo has been changed." });
    } catch {
      toast({ title: "Upload failed", description: "Could not update avatar. Please try again.", variant: "destructive" });
    } finally {
      setAvatarUploading(false);
    }
  }

  const { data: reviews = [], isLoading: reviewsLoading } = useQuery<Review[]>({
    queryKey: ["/api/users", user?.id, "reviews"],
    enabled: !!user?.id,
  });

  const { data: stats } = useQuery<{
    partiesAttended: number;
    partiesHosted: number;
    reviewCount: number;
    profileCompleteness: number;
  }>({
    queryKey: ["/api/users", user?.id, "stats"],
    enabled: !!user?.id,
  });

  const hostReviews = reviews.filter((r) => r.type === "host");
  const guestReviews = reviews.filter((r) => r.type === "guest");

  if (isLoading || !user) {
    return (
      <div className="min-h-screen bg-background p-4">
        <div className="max-w-lg mx-auto space-y-4">
          <Skeleton className="h-32 w-full rounded-md" />
          <Skeleton className="h-24 w-full rounded-md" />
          <Skeleton className="h-48 w-full rounded-md" />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background text-foreground p-4 pb-28">
      <div className="max-w-lg mx-auto space-y-4">
        <Card>
          <CardContent className="p-6">
            <div className="flex flex-col items-center text-center gap-3">
              <input
                ref={avatarInputRef}
                type="file"
                accept="image/*"
                capture="environment"
                className="hidden"
                data-testid="input-avatar-file"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) handleAvatarUpload(file);
                }}
              />
              <button
                type="button"
                className="relative cursor-pointer group"
                onClick={() => avatarInputRef.current?.click()}
                disabled={avatarUploading}
                data-testid="button-change-avatar"
              >
                <Avatar className="h-24 w-24" data-testid="img-avatar">
                  <AvatarImage src={user.avatar || undefined} alt={user.fullName} />
                  <AvatarFallback className="text-2xl">{getInitials(user.fullName)}</AvatarFallback>
                </Avatar>
                <div className="absolute bottom-0 right-0 bg-primary text-primary-foreground rounded-full p-1.5">
                  {avatarUploading ? (
                    <div className="h-4 w-4 border-2 border-primary-foreground border-t-transparent rounded-full animate-spin" />
                  ) : (
                    <Camera className="h-4 w-4" />
                  )}
                </div>
              </button>
              <div className="space-y-1">
                <div className="flex items-center justify-center gap-2 flex-wrap">
                  <h1 className="text-xl font-semibold" data-testid="text-fullname">{user.fullName}</h1>
                  {user.isIdVerified && (
                    <Badge variant="secondary" className="gap-1" data-testid="badge-verified">
                      <ShieldCheck size={12} />
                      Verified
                    </Badge>
                  )}
                </div>
                <p className="text-sm text-muted-foreground" data-testid="text-username">@{user.username}</p>
              </div>
              {user.bio && (
                <p className="text-sm text-muted-foreground max-w-sm" data-testid="text-bio">{user.bio}</p>
              )}
            </div>
          </CardContent>
        </Card>

        <Card data-testid="card-trust-signals">
          <CardHeader className="pb-2">
            <CardTitle className="text-base">Trust & Activity</CardTitle>
          </CardHeader>
          <CardContent className="p-4 pt-0 space-y-4">
            <div className="space-y-1.5">
              <div className="flex items-center justify-between gap-2 flex-wrap">
                <span className="text-sm text-muted-foreground">Profile Completeness</span>
                <span className="text-sm font-semibold" data-testid="text-completeness">{stats?.profileCompleteness ?? 0}%</span>
              </div>
              <div className="h-2 rounded-full bg-muted overflow-hidden">
                <div
                  className="h-full rounded-full bg-primary transition-all"
                  style={{ width: `${stats?.profileCompleteness ?? 0}%` }}
                />
              </div>
            </div>
            <div className="grid grid-cols-2 gap-3">
              <div className="flex items-center gap-2">
                <Calendar size={16} className="text-muted-foreground shrink-0" />
                <div>
                  <span className="font-semibold" data-testid="text-parties-attended">{stats?.partiesAttended ?? 0}</span>
                  <p className="text-xs text-muted-foreground">Parties Attended</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <PartyPopper size={16} className="text-muted-foreground shrink-0" />
                <div>
                  <span className="font-semibold" data-testid="text-parties-hosted">{stats?.partiesHosted ?? 0}</span>
                  <p className="text-xs text-muted-foreground">Parties Hosted</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <Star size={16} className="text-muted-foreground shrink-0" />
                <div>
                  <span className="font-semibold" data-testid="text-review-count">{stats?.reviewCount ?? 0}</span>
                  <p className="text-xs text-muted-foreground">Reviews</p>
                </div>
              </div>
              {(stats?.profileCompleteness ?? 0) < 100 && (
                <div className="flex items-center gap-2">
                  <ShieldCheck size={16} className="text-muted-foreground shrink-0" />
                  <div>
                    <p className="text-xs text-muted-foreground">Complete your profile to build trust</p>
                  </div>
                </div>
              )}
              {user.isIdVerified && (
                <div className="flex items-center gap-2">
                  <ShieldCheck size={16} className="text-primary shrink-0" />
                  <div>
                    <p className="text-xs font-semibold">ID Verified</p>
                  </div>
                </div>
              )}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="grid grid-cols-3 gap-4 text-center">
              <div className="space-y-1">
                <div className="flex items-center justify-center gap-1">
                  <Star size={16} className="fill-yellow-500 text-yellow-500" />
                  <span className="font-semibold" data-testid="text-host-rating">
                    {(user.hostRating ?? 0).toFixed(1)}
                  </span>
                </div>
                <p className="text-xs text-muted-foreground">Host Rating</p>
              </div>
              <div className="space-y-1">
                <div className="flex items-center justify-center gap-1">
                  <Star size={16} className="fill-yellow-500 text-yellow-500" />
                  <span className="font-semibold" data-testid="text-guest-rating">
                    {(user.guestRating ?? 0).toFixed(1)}
                  </span>
                </div>
                <p className="text-xs text-muted-foreground">Guest Rating</p>
              </div>
              <div className="space-y-1">
                <span className="font-semibold" data-testid="text-review-count">{reviews.length}</span>
                <p className="text-xs text-muted-foreground">Reviews</p>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-base">Reviews</CardTitle>
          </CardHeader>
          <CardContent className="p-4 pt-0">
            <Tabs value={reviewTab} onValueChange={setReviewTab}>
              <TabsList className="w-full" data-testid="tabs-reviews">
                <TabsTrigger value="host" className="flex-1" data-testid="tab-as-host">As Host</TabsTrigger>
                <TabsTrigger value="guest" className="flex-1" data-testid="tab-as-guest">As Guest</TabsTrigger>
              </TabsList>

              <TabsContent value="host" className="mt-3 space-y-3">
                {reviewsLoading ? (
                  <div className="space-y-3">
                    <Skeleton className="h-20 w-full" />
                    <Skeleton className="h-20 w-full" />
                  </div>
                ) : hostReviews.length === 0 ? (
                  <div className="text-center py-6">
                    <Award size={32} className="mx-auto text-muted-foreground mb-2" />
                    <p className="text-sm text-muted-foreground" data-testid="text-no-host-reviews">No host reviews yet</p>
                  </div>
                ) : (
                  hostReviews.map((review) => (
                    <ReviewCard key={review.id} review={review} />
                  ))
                )}
              </TabsContent>

              <TabsContent value="guest" className="mt-3 space-y-3">
                {reviewsLoading ? (
                  <div className="space-y-3">
                    <Skeleton className="h-20 w-full" />
                    <Skeleton className="h-20 w-full" />
                  </div>
                ) : guestReviews.length === 0 ? (
                  <div className="text-center py-6">
                    <UserCheck size={32} className="mx-auto text-muted-foreground mb-2" />
                    <p className="text-sm text-muted-foreground" data-testid="text-no-guest-reviews">No guest reviews yet</p>
                  </div>
                ) : (
                  guestReviews.map((review) => (
                    <ReviewCard key={review.id} review={review} />
                  ))
                )}
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>

        <div className="space-y-2">
          <Button
            className="w-full"
            onClick={() => setLocation("/settings")}
            data-testid="button-edit-profile"
          >
            <Settings size={16} className="mr-2" />
            Edit Profile
          </Button>

          {!user.isIdVerified && (
            <Button
              variant="outline"
              className="w-full"
              onClick={() =>
                toast({
                  title: "Coming Soon",
                  description: "ID verification coming soon",
                })
              }
              data-testid="button-verify-id"
            >
              <ShieldCheck size={16} className="mr-2" />
              Verify ID
            </Button>
          )}

          <Button
            variant="outline"
            className="w-full"
            onClick={() => logout()}
            data-testid="button-logout"
          >
            <LogOut size={16} className="mr-2" />
            Log Out
          </Button>
        </div>
      </div>
    </div>
  );
}

function ReviewCard({ review }: { review: Review }) {
  return (
    <Card data-testid={`card-review-${review.id}`}>
      <CardContent className="p-4">
        <div className="flex items-start gap-3">
          <Avatar className="h-8 w-8 shrink-0">
            <AvatarFallback className="text-xs">
              {review.authorId.slice(0, 2).toUpperCase()}
            </AvatarFallback>
          </Avatar>
          <div className="flex-1 min-w-0 space-y-1">
            <div className="flex items-center justify-between gap-2 flex-wrap">
              <RatingStars rating={review.rating} />
              {review.createdAt && (
                <span className="text-xs text-muted-foreground" data-testid={`text-review-date-${review.id}`}>
                  {new Date(review.createdAt).toLocaleDateString()}
                </span>
              )}
            </div>
            <p className="text-sm" data-testid={`text-review-content-${review.id}`}>{review.content}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

========================================
FILE: client/src/pages/settings-page.tsx
========================================
import { useState, useEffect } from "react";
import { useMutation } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { Slider } from "@/components/ui/slider";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Separator } from "@/components/ui/separator";
import { Skeleton } from "@/components/ui/skeleton";
import { ArrowLeft, Save, LogOut, Navigation } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useTheme } from "@/components/theme-provider";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";

const COUNTRY_DATA: Record<string, string[]> = {
  "USA": ["New York", "Los Angeles", "Chicago", "Miami", "Austin", "San Francisco", "Seattle", "Denver"],
  "United Kingdom": ["London", "Manchester", "Birmingham", "Edinburgh", "Bristol", "Glasgow", "Liverpool"],
  "Germany": ["Berlin", "Munich", "Hamburg", "Cologne", "Frankfurt", "Stuttgart", "Dsseldorf"],
  "Romania": ["Bucharest", "Cluj-Napoca", "Timioara", "Iai", "Constana", "Braov", "Sibiu", "Vama Veche"],
};

export default function SettingsPage() {
  const [, setLocation] = useLocation();
  const { user, isLoading, logout } = useAuth();
  const { theme, setTheme } = useTheme();
  const { toast } = useToast();

  const [fullName, setFullName] = useState("");
  const [nickname, setNickname] = useState("");
  const [email, setEmail] = useState("");
  const [phone, setPhone] = useState("");
  const [bio, setBio] = useState("");

  const [country, setCountry] = useState("");
  const [city, setCity] = useState("");
  const [address, setAddress] = useState("");

  const [notifications, setNotifications] = useState(true);
  const [darkMode, setDarkMode] = useState(false);
  const [searchRadius, setSearchRadius] = useState(50);

  useEffect(() => {
    if (user) {
      setFullName(user.fullName || "");
      setNickname(user.nickname || "");
      setEmail(user.email || "");
      setPhone(user.phone || "");
      setBio(user.bio || "");
      setCountry(user.country || "");
      setCity(user.city || "");
      setAddress(user.address || "");
      setNotifications(user.notificationsEnabled ?? true);
      setDarkMode(user.darkMode ?? false);
      setSearchRadius(user.searchRadius ?? 50);
    }
  }, [user]);

  const updateMutation = useMutation({
    mutationFn: async (data: Record<string, unknown>) => {
      const res = await apiRequest("PATCH", `/api/users/${user!.id}`, data);
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
      toast({ title: "Saved", description: "Your changes have been saved." });
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to save changes.", variant: "destructive" });
    },
  });

  const cities = country ? COUNTRY_DATA[country] || [] : [];

  if (isLoading) {
    return (
      <div className="min-h-screen bg-background p-4">
        <div className="max-w-lg mx-auto space-y-4">
          <Skeleton className="h-8 w-32" />
          <Skeleton className="h-48 w-full rounded-md" />
          <Skeleton className="h-48 w-full rounded-md" />
        </div>
      </div>
    );
  }

  if (!user) {
    return null;
  }

  return (
    <div className="min-h-screen bg-background text-foreground p-4 pb-28">
      <div className="max-w-lg mx-auto space-y-4">
        <Button
          variant="ghost"
          onClick={() => setLocation("/profile")}
          data-testid="button-back"
        >
          <ArrowLeft size={16} className="mr-2" />
          Back to Profile
        </Button>

        <h1 className="text-xl font-semibold" data-testid="text-settings-title">Settings</h1>

        <Card>
          <CardHeader>
            <CardTitle className="text-base">Personal Info</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="fullName">Full Name</Label>
              <Input
                id="fullName"
                value={fullName}
                onChange={(e) => setFullName(e.target.value)}
                data-testid="input-fullname"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="nickname">Nickname</Label>
              <Input
                id="nickname"
                value={nickname}
                onChange={(e) => setNickname(e.target.value)}
                data-testid="input-nickname"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                data-testid="input-email"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="phone">Phone</Label>
              <Input
                id="phone"
                value={phone}
                onChange={(e) => setPhone(e.target.value)}
                data-testid="input-phone"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="bio">Bio</Label>
              <Textarea
                id="bio"
                value={bio}
                onChange={(e) => setBio(e.target.value)}
                rows={3}
                data-testid="input-bio"
              />
            </div>
            <Button
              onClick={() =>
                updateMutation.mutate({ fullName, nickname, email, phone, bio })
              }
              disabled={updateMutation.isPending}
              data-testid="button-save-personal"
            >
              <Save size={16} className="mr-2" />
              {updateMutation.isPending ? "Saving..." : "Save Personal Info"}
            </Button>
          </CardContent>
        </Card>

        <Separator />

        <Card>
          <CardHeader>
            <CardTitle className="text-base">Location</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label>Country</Label>
              <Select
                value={country}
                onValueChange={(val) => {
                  setCountry(val);
                  setCity("");
                }}
              >
                <SelectTrigger data-testid="select-country">
                  <SelectValue placeholder="Select country" />
                </SelectTrigger>
                <SelectContent>
                  {Object.keys(COUNTRY_DATA).map((c) => (
                    <SelectItem key={c} value={c} data-testid={`option-country-${c}`}>
                      {c}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>City</Label>
              <Select value={city} onValueChange={setCity} disabled={!country}>
                <SelectTrigger data-testid="select-city">
                  <SelectValue placeholder="Select city" />
                </SelectTrigger>
                <SelectContent>
                  {cities.map((c) => (
                    <SelectItem key={c} value={c} data-testid={`option-city-${c}`}>
                      {c}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label htmlFor="address">Address</Label>
              <Input
                id="address"
                value={address}
                onChange={(e) => setAddress(e.target.value)}
                data-testid="input-address"
              />
            </div>
            {user.latitude && user.longitude && (
              <div className="rounded-md bg-muted p-3 space-y-1">
                <p className="text-xs text-muted-foreground">Current GPS Location</p>
                <p className="text-sm font-mono" data-testid="text-gps-coords">
                  {Number(user.latitude).toFixed(6)}, {Number(user.longitude).toFixed(6)}
                </p>
              </div>
            )}
            <Button
              variant="outline"
              className="w-full"
              onClick={() => {
                if (!navigator.geolocation) {
                  toast({ title: "Not supported", description: "Geolocation is not supported by your browser.", variant: "destructive" });
                  return;
                }
                toast({ title: "Detecting location...", description: "Please allow location access when prompted." });
                navigator.geolocation.getCurrentPosition(
                  (position) => {
                    const { latitude, longitude } = position.coords;
                    updateMutation.mutate({ latitude, longitude });
                  },
                  (error) => {
                    toast({ title: "Location error", description: error.message || "Could not detect your location.", variant: "destructive" });
                  },
                  { enableHighAccuracy: true, timeout: 10000 }
                );
              }}
              disabled={updateMutation.isPending}
              data-testid="button-detect-location"
            >
              <Navigation size={16} className="mr-2" />
              Detect My Location
            </Button>
            <Button
              onClick={() => updateMutation.mutate({ country, city, address })}
              disabled={updateMutation.isPending}
              data-testid="button-save-location"
            >
              <Save size={16} className="mr-2" />
              {updateMutation.isPending ? "Saving..." : "Save Location"}
            </Button>
          </CardContent>
        </Card>

        <Separator />

        <Card>
          <CardHeader>
            <CardTitle className="text-base">Preferences</CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="flex items-center justify-between gap-4">
              <div>
                <Label>Notifications</Label>
                <p className="text-xs text-muted-foreground">Receive push notifications</p>
              </div>
              <Switch
                checked={notifications}
                onCheckedChange={setNotifications}
                data-testid="switch-notifications"
              />
            </div>
            <div className="flex items-center justify-between gap-4">
              <div>
                <Label>Dark Mode</Label>
                <p className="text-xs text-muted-foreground">Toggle dark theme</p>
              </div>
              <Switch
                checked={theme === "dark"}
                onCheckedChange={(checked) => {
                  setTheme(checked ? "dark" : "light");
                  setDarkMode(checked);
                }}
                data-testid="switch-dark-mode"
              />
            </div>
            <div className="space-y-3">
              <div className="flex items-center justify-between gap-4">
                <Label>Search Radius</Label>
                <span className="text-sm text-muted-foreground" data-testid="text-search-radius">
                  {searchRadius} km
                </span>
              </div>
              <Slider
                value={[searchRadius]}
                onValueChange={(val) => setSearchRadius(val[0])}
                min={5}
                max={200}
                step={5}
                data-testid="slider-search-radius"
              />
            </div>
            <Button
              onClick={() =>
                updateMutation.mutate({
                  notificationsEnabled: notifications,
                  darkMode,
                  searchRadius,
                })
              }
              disabled={updateMutation.isPending}
              data-testid="button-save-preferences"
            >
              <Save size={16} className="mr-2" />
              {updateMutation.isPending ? "Saving..." : "Save Preferences"}
            </Button>
          </CardContent>
        </Card>

        <Separator />

        <Card>
          <CardHeader>
            <CardTitle className="text-base">Account</CardTitle>
          </CardHeader>
          <CardContent>
            <Button
              variant="outline"
              className="w-full"
              onClick={() => logout()}
              data-testid="button-logout"
            >
              <LogOut size={16} className="mr-2" />
              Log Out
            </Button>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

========================================
FILE: client/src/pages/onboarding-page.tsx
========================================
import { useState } from "react";
import { useLocation } from "wouter";
import { useMutation } from "@tanstack/react-query";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  PartyPopper,
  ChevronRight,
  ChevronLeft,
  Check,
  Loader2,
  Music,
  Users,
  Flame,
  Utensils,
  TreePine,
  Sparkles,
  Navigation,
} from "lucide-react";

const COUNTRIES = [
  { value: "USA", label: "USA" },
  { value: "United Kingdom", label: "United Kingdom" },
  { value: "Germany", label: "Germany" },
  { value: "Romania", label: "Romania" },
] as const;

const CITIES_BY_COUNTRY: Record<string, string[]> = {
  USA: ["New York", "Los Angeles", "Chicago", "Miami", "Austin", "San Francisco", "Seattle", "Denver"],
  "United Kingdom": ["London", "Manchester", "Birmingham", "Edinburgh", "Bristol", "Glasgow", "Liverpool"],
  Germany: ["Berlin", "Munich", "Hamburg", "Cologne", "Frankfurt", "Stuttgart", "Dsseldorf"],
  Romania: ["Bucharest", "Cluj-Napoca", "Timioara", "Iai", "Constana", "Braov", "Sibiu", "Vama Veche"],
};

const personalInfoSchema = z.object({
  nickname: z.string().optional(),
  dob: z.string().optional(),
  phone: z.string().optional(),
  bio: z.string().optional(),
});

const vibeSchema = z.object({
  preferredVibe: z.string().optional(),
  gatheringSizePref: z.string().optional(),
  hostOrGuest: z.string().optional(),
});

const locationSchema = z.object({
  country: z.string().min(1, "Please select a country"),
  city: z.string().min(1, "Please select a city"),
  address: z.string().optional(),
});

type PersonalInfoValues = z.infer<typeof personalInfoSchema>;
type VibeValues = z.infer<typeof vibeSchema>;
type LocationValues = z.infer<typeof locationSchema>;

const VIBE_OPTIONS = [
  { value: "chill", label: "Chill & Intimate", icon: Sparkles },
  { value: "dance", label: "Dance & Energy", icon: Flame },
  { value: "food", label: "Food & Drinks", icon: Utensils },
  { value: "music", label: "Music & Live", icon: Music },
  { value: "outdoor", label: "Outdoor & Adventure", icon: TreePine },
  { value: "mix", label: "Mix of Everything", icon: Users },
];

const SIZE_OPTIONS = [
  { value: "small", label: "Small", subtitle: "1-15 people" },
  { value: "medium", label: "Medium", subtitle: "16-40 people" },
  { value: "large", label: "Large", subtitle: "41+ people" },
];

const ROLE_OPTIONS = [
  { value: "host", label: "Host", subtitle: "I love organizing events" },
  { value: "guest", label: "Guest", subtitle: "I love attending events" },
  { value: "both", label: "Both", subtitle: "I do both!" },
];

export default function OnboardingPage() {
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const { user, isLoading } = useAuth();
  const [currentStep, setCurrentStep] = useState(1);
  const [detectingLocation, setDetectingLocation] = useState(false);

  const personalForm = useForm<PersonalInfoValues>({
    resolver: zodResolver(personalInfoSchema),
    defaultValues: { nickname: "", dob: "", phone: "", bio: "" },
  });

  const vibeForm = useForm<VibeValues>({
    resolver: zodResolver(vibeSchema),
    defaultValues: { preferredVibe: "", gatheringSizePref: "", hostOrGuest: "" },
  });

  const locationForm = useForm<LocationValues>({
    resolver: zodResolver(locationSchema),
    defaultValues: { country: "", city: "", address: "" },
  });

  const selectedCountry = locationForm.watch("country");

  const updateMutation = useMutation({
    mutationFn: async (data: Record<string, unknown>) => {
      if (!user) throw new Error("Not authenticated");
      const res = await apiRequest("PATCH", `/api/users/${user.id}`, data);
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/me"] });
    },
    onError: (error: Error) => {
      toast({
        title: "Update failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  if (isLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (!user) {
    return null;
  }

  const handleStep1Next = async (values: PersonalInfoValues) => {
    await updateMutation.mutateAsync({
      nickname: values.nickname || undefined,
      dob: values.dob || undefined,
      phone: values.phone || undefined,
      bio: values.bio || undefined,
    });
    setCurrentStep(2);
  };

  const handleStep2Next = async (values: VibeValues) => {
    await updateMutation.mutateAsync({
      preferredVibe: values.preferredVibe || undefined,
      gatheringSizePref: values.gatheringSizePref || undefined,
      hostOrGuest: values.hostOrGuest || undefined,
    });
    setCurrentStep(3);
  };

  const handleDetectLocation = () => {
    if (!navigator.geolocation) {
      toast({ title: "Geolocation not supported", description: "Your browser does not support GPS detection.", variant: "destructive" });
      return;
    }
    setDetectingLocation(true);
    navigator.geolocation.getCurrentPosition(
      async (position) => {
        try {
          await updateMutation.mutateAsync({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
          });
          toast({ title: "Location detected", description: "Your GPS coordinates have been saved." });
        } catch {
        } finally {
          setDetectingLocation(false);
        }
      },
      (error) => {
        setDetectingLocation(false);
        toast({ title: "Location detection failed", description: error.message, variant: "destructive" });
      },
    );
  };

  const handleStep3Next = async (values: LocationValues) => {
    await updateMutation.mutateAsync({
      country: values.country,
      city: values.city,
      address: values.address || undefined,
      onboardingComplete: true,
    });
    toast({ title: "Welcome to CambuApp!", description: "Your profile is all set. Start exploring parties!" });
    setLocation("/");
  };

  const handleSkip = () => {
    toast({ title: "Welcome to CambuApp!", description: "You can update your profile anytime." });
    setLocation("/");
  };

  const steps = [
    { number: 1, label: "Personal" },
    { number: 2, label: "Your Vibe" },
    { number: 3, label: "Location" },
  ];

  return (
    <div className="min-h-screen bg-background flex flex-col">
      <div
        className="relative overflow-hidden py-10 px-4 flex flex-col items-center"
        style={{
          background: "linear-gradient(135deg, hsl(280 85% 15%) 0%, hsl(280 85% 8%) 50%, hsl(300 60% 10%) 100%)",
        }}
      >
        <div
          className="absolute inset-0 opacity-20"
          style={{
            background: "radial-gradient(circle at 30% 50%, hsl(280 85% 55% / 0.4) 0%, transparent 50%)",
          }}
        />
        <div className="relative z-10 text-center">
          <div className="flex items-center justify-center gap-2 mb-2">
            <PartyPopper className="w-7 h-7 text-primary-foreground" />
            <h1 className="text-2xl font-bold text-primary-foreground" data-testid="text-onboarding-title">
              Set Up Your Profile
            </h1>
          </div>
          <p className="text-primary-foreground/70 text-sm" data-testid="text-onboarding-subtitle">
            Step {currentStep} of 3
          </p>
        </div>
      </div>

      <div className="flex items-center justify-center gap-2 px-4 -mt-4 relative z-10 mb-6">
        {steps.map((step) => (
          <div key={step.number} className="flex items-center gap-2">
            <div
              className={`w-9 h-9 rounded-full flex items-center justify-center text-sm font-medium transition-colors ${
                currentStep > step.number
                  ? "bg-primary text-primary-foreground"
                  : currentStep === step.number
                    ? "bg-primary text-primary-foreground"
                    : "bg-muted text-muted-foreground"
              }`}
              data-testid={`step-indicator-${step.number}`}
            >
              {currentStep > step.number ? <Check className="w-4 h-4" /> : step.number}
            </div>
            {step.number < 3 && (
              <div
                className={`w-12 h-0.5 ${
                  currentStep > step.number ? "bg-primary" : "bg-muted"
                }`}
              />
            )}
          </div>
        ))}
      </div>

      <div className="flex-1 flex items-start justify-center px-4 pb-12">
        <Card className="w-full max-w-md">
          {currentStep === 1 && (
            <>
              <CardHeader>
                <CardTitle data-testid="text-step1-title">Personal Info</CardTitle>
              </CardHeader>
              <CardContent>
                <Form {...personalForm}>
                  <form
                    onSubmit={personalForm.handleSubmit(handleStep1Next)}
                    className="space-y-4"
                    data-testid="form-personal-info"
                  >
                    <FormField
                      control={personalForm.control}
                      name="nickname"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Nickname (optional)</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="What should people call you?"
                              data-testid="input-nickname"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={personalForm.control}
                      name="dob"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Date of Birth</FormLabel>
                          <FormControl>
                            <Input
                              type="date"
                              data-testid="input-dob"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={personalForm.control}
                      name="phone"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Phone Number</FormLabel>
                          <FormControl>
                            <Input
                              type="tel"
                              placeholder="+1 555-0123"
                              data-testid="input-phone"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={personalForm.control}
                      name="bio"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Bio</FormLabel>
                          <FormControl>
                            <Textarea
                              placeholder="Tell people about yourself and what kind of parties you like..."
                              className="resize-none"
                              rows={3}
                              data-testid="input-bio"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <div className="flex items-center gap-3 justify-between pt-2">
                      <Button
                        type="button"
                        variant="ghost"
                        onClick={handleSkip}
                        data-testid="button-skip-onboarding"
                      >
                        Skip for now
                      </Button>
                      <Button
                        type="submit"
                        disabled={updateMutation.isPending}
                        data-testid="button-step1-next"
                      >
                        {updateMutation.isPending ? (
                          <Loader2 className="w-4 h-4 animate-spin mr-2" />
                        ) : null}
                        Next
                        <ChevronRight className="w-4 h-4 ml-1" />
                      </Button>
                    </div>
                  </form>
                </Form>
              </CardContent>
            </>
          )}

          {currentStep === 2 && (
            <>
              <CardHeader>
                <CardTitle data-testid="text-step2-title">Your Vibe</CardTitle>
              </CardHeader>
              <CardContent>
                <Form {...vibeForm}>
                  <form
                    onSubmit={vibeForm.handleSubmit(handleStep2Next)}
                    className="space-y-6"
                    data-testid="form-vibe"
                  >
                    <FormField
                      control={vibeForm.control}
                      name="preferredVibe"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Preferred Vibe</FormLabel>
                          <FormControl>
                            <div className="grid grid-cols-2 gap-2">
                              {VIBE_OPTIONS.map((option) => {
                                const Icon = option.icon;
                                const isSelected = field.value === option.value;
                                return (
                                  <div
                                    key={option.value}
                                    className={`cursor-pointer rounded-md border p-3 text-center transition-colors ${
                                      isSelected
                                        ? "border-primary bg-primary/10"
                                        : ""
                                    }`}
                                    onClick={() => field.onChange(option.value)}
                                    data-testid={`option-vibe-${option.value}`}
                                  >
                                    <Icon className="w-5 h-5 mx-auto mb-1 text-muted-foreground" />
                                    <span className="text-sm font-medium">{option.label}</span>
                                  </div>
                                );
                              })}
                            </div>
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={vibeForm.control}
                      name="gatheringSizePref"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Gathering Size Preference</FormLabel>
                          <FormControl>
                            <div className="grid grid-cols-3 gap-2">
                              {SIZE_OPTIONS.map((option) => {
                                const isSelected = field.value === option.value;
                                return (
                                  <div
                                    key={option.value}
                                    className={`cursor-pointer rounded-md border p-3 text-center transition-colors ${
                                      isSelected
                                        ? "border-primary bg-primary/10"
                                        : ""
                                    }`}
                                    onClick={() => field.onChange(option.value)}
                                    data-testid={`option-size-${option.value}`}
                                  >
                                    <span className="text-sm font-medium block">{option.label}</span>
                                    <span className="text-xs text-muted-foreground">{option.subtitle}</span>
                                  </div>
                                );
                              })}
                            </div>
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={vibeForm.control}
                      name="hostOrGuest"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Are you mainly a...</FormLabel>
                          <FormControl>
                            <div className="grid grid-cols-3 gap-2">
                              {ROLE_OPTIONS.map((option) => {
                                const isSelected = field.value === option.value;
                                return (
                                  <div
                                    key={option.value}
                                    className={`cursor-pointer rounded-md border p-3 text-center transition-colors ${
                                      isSelected
                                        ? "border-primary bg-primary/10"
                                        : ""
                                    }`}
                                    onClick={() => field.onChange(option.value)}
                                    data-testid={`option-role-${option.value}`}
                                  >
                                    <span className="text-sm font-medium block">{option.label}</span>
                                    <span className="text-xs text-muted-foreground">{option.subtitle}</span>
                                  </div>
                                );
                              })}
                            </div>
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <div className="flex items-center gap-3 justify-between pt-2">
                      <Button
                        type="button"
                        variant="ghost"
                        onClick={() => setCurrentStep(1)}
                        data-testid="button-step2-back"
                      >
                        <ChevronLeft className="w-4 h-4 mr-1" />
                        Back
                      </Button>
                      <Button
                        type="submit"
                        disabled={updateMutation.isPending}
                        data-testid="button-step2-next"
                      >
                        {updateMutation.isPending ? (
                          <Loader2 className="w-4 h-4 animate-spin mr-2" />
                        ) : null}
                        Next
                        <ChevronRight className="w-4 h-4 ml-1" />
                      </Button>
                    </div>
                  </form>
                </Form>
              </CardContent>
            </>
          )}

          {currentStep === 3 && (
            <>
              <CardHeader>
                <CardTitle data-testid="text-step3-title">Your Location</CardTitle>
              </CardHeader>
              <CardContent>
                <Form {...locationForm}>
                  <form
                    onSubmit={locationForm.handleSubmit(handleStep3Next)}
                    className="space-y-4"
                    data-testid="form-location"
                  >
                    <Button
                      type="button"
                      variant="outline"
                      className="w-full"
                      onClick={handleDetectLocation}
                      disabled={detectingLocation}
                      data-testid="button-detect-location"
                    >
                      {detectingLocation ? (
                        <Loader2 className="w-4 h-4 animate-spin mr-2" />
                      ) : (
                        <Navigation className="w-4 h-4 mr-2" />
                      )}
                      {detectingLocation ? "Detecting..." : "Detect My Location"}
                    </Button>
                    <FormField
                      control={locationForm.control}
                      name="country"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Country</FormLabel>
                          <Select
                            onValueChange={(val) => {
                              field.onChange(val);
                              locationForm.setValue("city", "");
                            }}
                            value={field.value}
                          >
                            <FormControl>
                              <SelectTrigger data-testid="select-country">
                                <SelectValue placeholder="Select your country" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              {COUNTRIES.map((c) => (
                                <SelectItem key={c.value} value={c.value} data-testid={`option-country-${c.value}`}>
                                  {c.label}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={locationForm.control}
                      name="city"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>City</FormLabel>
                          <Select
                            onValueChange={field.onChange}
                            value={field.value}
                            disabled={!selectedCountry}
                          >
                            <FormControl>
                              <SelectTrigger data-testid="select-city">
                                <SelectValue placeholder={selectedCountry ? "Select your city" : "Select a country first"} />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              {(CITIES_BY_COUNTRY[selectedCountry] || []).map((city) => (
                                <SelectItem key={city} value={city} data-testid={`option-city-${city}`}>
                                  {city}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={locationForm.control}
                      name="address"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Address (optional)</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="Street address"
                              data-testid="input-address"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <div className="flex items-center gap-3 justify-between pt-2">
                      <Button
                        type="button"
                        variant="ghost"
                        onClick={() => setCurrentStep(2)}
                        data-testid="button-step3-back"
                      >
                        <ChevronLeft className="w-4 h-4 mr-1" />
                        Back
                      </Button>
                      <Button
                        type="submit"
                        disabled={updateMutation.isPending}
                        data-testid="button-complete-setup"
                      >
                        {updateMutation.isPending ? (
                          <Loader2 className="w-4 h-4 animate-spin mr-2" />
                        ) : null}
                        <Check className="w-4 h-4 mr-1" />
                        Complete Setup
                      </Button>
                    </div>
                  </form>
                </Form>
              </CardContent>
            </>
          )}
        </Card>
      </div>
    </div>
  );
}

========================================
FILE: client/src/pages/legal-page.tsx
========================================
import { useQuery } from "@tanstack/react-query";
import { useRoute } from "wouter";
import { Link } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { ArrowLeft } from "lucide-react";

const TITLES: Record<string, string> = {
  terms: "Terms of Service",
  privacy: "Privacy Policy",
  eula: "End User License Agreement",
};

export default function LegalPage() {
  const [, params] = useRoute("/legal/:type");
  const type = params?.type ?? "terms";

  const { data, isLoading, isError } = useQuery<{ content: string }>({
    queryKey: ["/api/legal", type],
  });

  return (
    <div className="min-h-screen bg-background pb-12">
      <header className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-3xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/auth">
            <Button variant="ghost" size="icon" data-testid="button-back">
              <ArrowLeft className="h-4 w-4" />
            </Button>
          </Link>
          <h1 className="text-lg font-semibold" data-testid="text-legal-title">
            {TITLES[type] || "Legal"}
          </h1>
        </div>
      </header>

      <main className="max-w-3xl mx-auto px-4 py-6">
        {isLoading ? (
          <Card>
            <CardContent className="p-6 space-y-4">
              <Skeleton className="h-6 w-1/3" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-5/6" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-2/3" />
            </CardContent>
          </Card>
        ) : isError ? (
          <Card>
            <CardContent className="p-6 text-center">
              <p className="text-muted-foreground" data-testid="text-legal-error">
                Failed to load content. Please try again later.
              </p>
            </CardContent>
          </Card>
        ) : (
          <Card>
            <CardContent className="p-6">
              <div
                className="prose prose-sm dark:prose-invert max-w-none whitespace-pre-wrap"
                data-testid="text-legal-content"
              >
                {data?.content}
              </div>
            </CardContent>
          </Card>
        )}
      </main>
    </div>
  );
}

========================================
FILE: client/src/hooks/use-auth.ts
========================================
import { useQuery, useMutation } from "@tanstack/react-query";
import { apiRequest, queryClient, getQueryFn } from "@/lib/queryClient";
import { useLocation } from "wouter";
import type { User } from "@shared/schema";

export function useAuth() {
  const [, setLocation] = useLocation();

  const { data: user, isLoading } = useQuery<User | null>({
    queryKey: ["/api/auth/me"],
    queryFn: getQueryFn({ on401: "returnNull" }),
    retry: false,
    staleTime: 5 * 60 * 1000,
  });

  const logoutMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", "/api/auth/logout");
    },
    onSuccess: () => {
      queryClient.setQueryData(["/api/auth/me"], null);
      setLocation("/auth");
    },
  });

  return {
    user: user ?? null,
    isLoading,
    isAuthenticated: !!user,
    logout: logoutMutation.mutate,
  };
}

========================================
FILE: client/src/lib/queryClient.ts
========================================
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const res = await fetch(queryKey.join("/") as string, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});

========================================
FILE: client/src/components/mobile-nav.tsx
========================================
import { useLocation } from "wouter";
import { Search, Home, Calendar, User, Plus } from "lucide-react";

const navItems = [
  { path: "/browse", label: "Browse", icon: Search },
  { path: "/host", label: "Host", icon: Home },
  { path: "/create-party", label: "Create", icon: Plus },
  { path: "/attending", label: "Going", icon: Calendar },
  { path: "/profile", label: "Profile", icon: User },
];

export function MobileNav() {
  const [location, setLocation] = useLocation();

  const isActive = (path: string) => {
    if (path === "/browse") return location === "/" || location === "/browse";
    return location === path;
  };

  return (
    <nav className="fixed bottom-4 inset-x-4 glass border border-border/30 p-1.5 flex justify-around z-50 rounded-[28px]" data-testid="mobile-nav">
      {navItems.map((item) => {
        const active = isActive(item.path);
        const Icon = item.icon;
        const isCreate = item.path === "/create-party";

        return (
          <button
            key={item.path}
            onClick={() => setLocation(item.path)}
            data-testid={`nav-${item.label.toLowerCase()}`}
            className={`relative flex flex-col items-center gap-0.5 px-3 py-2 rounded-[22px] transition-all duration-200 ${
              isCreate
                ? "bg-primary text-primary-foreground px-4"
                : active
                  ? "bg-foreground/10 dark:bg-foreground/15 text-foreground"
                  : "text-muted-foreground"
            }`}
          >
            <Icon size={20} strokeWidth={active || isCreate ? 2.5 : 2} />
            <span className="text-[10px] font-medium leading-none">{item.label}</span>
          </button>
        );
      })}
    </nav>
  );
}

